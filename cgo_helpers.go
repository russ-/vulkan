// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Wed, 15 Jan 2020 13:03:26 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package vulkan

/*
#cgo CFLAGS: -I. -DVK_NO_PROTOTYPES
#include "vulkan/vulkan.h"
#include "vk_wrapper.h"
#include "vk_bridge.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocApplicationInfoMemory allocates memory for type C.VkApplicationInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocApplicationInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfApplicationInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfApplicationInfoValue = unsafe.Sizeof([1]C.VkApplicationInfo{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ApplicationInfo) Ref() *C.VkApplicationInfo {
	if x == nil {
		return nil
	}
	return x.refb0af7378
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ApplicationInfo) Free() {
	if x != nil && x.allocsb0af7378 != nil {
		x.allocsb0af7378.(*cgoAllocMap).Free()
		x.refb0af7378 = nil
	}
}

// NewApplicationInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewApplicationInfoRef(ref unsafe.Pointer) *ApplicationInfo {
	if ref == nil {
		return nil
	}
	obj := new(ApplicationInfo)
	obj.refb0af7378 = (*C.VkApplicationInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ApplicationInfo) PassRef() (*C.VkApplicationInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb0af7378 != nil {
		return x.refb0af7378, nil
	}
	memb0af7378 := allocApplicationInfoMemory(1)
	refb0af7378 := (*C.VkApplicationInfo)(memb0af7378)
	allocsb0af7378 := new(cgoAllocMap)
	allocsb0af7378.Add(memb0af7378)

	var csType_allocs *cgoAllocMap
	refb0af7378.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb0af7378.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb0af7378.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb0af7378.Borrow(cpNext_allocs)

	var cpApplicationName_allocs *cgoAllocMap
	refb0af7378.pApplicationName, cpApplicationName_allocs = unpackPCharString(x.PApplicationName)
	allocsb0af7378.Borrow(cpApplicationName_allocs)

	var capplicationVersion_allocs *cgoAllocMap
	refb0af7378.applicationVersion, capplicationVersion_allocs = (C.uint32_t)(x.ApplicationVersion), cgoAllocsUnknown
	allocsb0af7378.Borrow(capplicationVersion_allocs)

	var cpEngineName_allocs *cgoAllocMap
	refb0af7378.pEngineName, cpEngineName_allocs = unpackPCharString(x.PEngineName)
	allocsb0af7378.Borrow(cpEngineName_allocs)

	var cengineVersion_allocs *cgoAllocMap
	refb0af7378.engineVersion, cengineVersion_allocs = (C.uint32_t)(x.EngineVersion), cgoAllocsUnknown
	allocsb0af7378.Borrow(cengineVersion_allocs)

	var capiVersion_allocs *cgoAllocMap
	refb0af7378.apiVersion, capiVersion_allocs = (C.uint32_t)(x.ApiVersion), cgoAllocsUnknown
	allocsb0af7378.Borrow(capiVersion_allocs)

	x.refb0af7378 = refb0af7378
	x.allocsb0af7378 = allocsb0af7378
	return refb0af7378, allocsb0af7378

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ApplicationInfo) PassValue() (C.VkApplicationInfo, *cgoAllocMap) {
	if x.refb0af7378 != nil {
		return *x.refb0af7378, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ApplicationInfo) Deref() {
	if x.refb0af7378 == nil {
		return
	}
	x.SType = (StructureType)(x.refb0af7378.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb0af7378.pNext))
	x.PApplicationName = packPCharString(x.refb0af7378.pApplicationName)
	x.ApplicationVersion = (uint32)(x.refb0af7378.applicationVersion)
	x.PEngineName = packPCharString(x.refb0af7378.pEngineName)
	x.EngineVersion = (uint32)(x.refb0af7378.engineVersion)
	x.ApiVersion = (uint32)(x.refb0af7378.apiVersion)
}

// allocInstanceCreateInfoMemory allocates memory for type C.VkInstanceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInstanceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInstanceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfInstanceCreateInfoValue = unsafe.Sizeof([1]C.VkInstanceCreateInfo{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSString transforms a sliced Go data structure into plain C format.
func unpackSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *InstanceCreateInfo) Ref() *C.VkInstanceCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref9b760798
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *InstanceCreateInfo) Free() {
	if x != nil && x.allocs9b760798 != nil {
		x.allocs9b760798.(*cgoAllocMap).Free()
		x.ref9b760798 = nil
	}
}

// NewInstanceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewInstanceCreateInfoRef(ref unsafe.Pointer) *InstanceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(InstanceCreateInfo)
	obj.ref9b760798 = (*C.VkInstanceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *InstanceCreateInfo) PassRef() (*C.VkInstanceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9b760798 != nil {
		return x.ref9b760798, nil
	}
	mem9b760798 := allocInstanceCreateInfoMemory(1)
	ref9b760798 := (*C.VkInstanceCreateInfo)(mem9b760798)
	allocs9b760798 := new(cgoAllocMap)
	allocs9b760798.Add(mem9b760798)

	var csType_allocs *cgoAllocMap
	ref9b760798.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9b760798.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9b760798.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9b760798.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref9b760798.flags, cflags_allocs = (C.VkInstanceCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs9b760798.Borrow(cflags_allocs)

	var cpApplicationInfo_allocs *cgoAllocMap
	ref9b760798.pApplicationInfo, cpApplicationInfo_allocs = x.PApplicationInfo.PassRef()
	allocs9b760798.Borrow(cpApplicationInfo_allocs)

	var cenabledLayerCount_allocs *cgoAllocMap
	ref9b760798.enabledLayerCount, cenabledLayerCount_allocs = (C.uint32_t)(x.EnabledLayerCount), cgoAllocsUnknown
	allocs9b760798.Borrow(cenabledLayerCount_allocs)

	var cppEnabledLayerNames_allocs *cgoAllocMap
	ref9b760798.ppEnabledLayerNames, cppEnabledLayerNames_allocs = unpackSString(x.PpEnabledLayerNames)
	allocs9b760798.Borrow(cppEnabledLayerNames_allocs)

	var cenabledExtensionCount_allocs *cgoAllocMap
	ref9b760798.enabledExtensionCount, cenabledExtensionCount_allocs = (C.uint32_t)(x.EnabledExtensionCount), cgoAllocsUnknown
	allocs9b760798.Borrow(cenabledExtensionCount_allocs)

	var cppEnabledExtensionNames_allocs *cgoAllocMap
	ref9b760798.ppEnabledExtensionNames, cppEnabledExtensionNames_allocs = unpackSString(x.PpEnabledExtensionNames)
	allocs9b760798.Borrow(cppEnabledExtensionNames_allocs)

	x.ref9b760798 = ref9b760798
	x.allocs9b760798 = allocs9b760798
	return ref9b760798, allocs9b760798

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x InstanceCreateInfo) PassValue() (C.VkInstanceCreateInfo, *cgoAllocMap) {
	if x.ref9b760798 != nil {
		return *x.ref9b760798, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *InstanceCreateInfo) Deref() {
	if x.ref9b760798 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9b760798.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9b760798.pNext))
	x.Flags = (InstanceCreateFlags)(x.ref9b760798.flags)
	x.PApplicationInfo = NewApplicationInfoRef(unsafe.Pointer(x.ref9b760798.pApplicationInfo))
	x.EnabledLayerCount = (uint32)(x.ref9b760798.enabledLayerCount)
	packSString(x.PpEnabledLayerNames, x.ref9b760798.ppEnabledLayerNames)
	x.EnabledExtensionCount = (uint32)(x.ref9b760798.enabledExtensionCount)
	packSString(x.PpEnabledExtensionNames, x.ref9b760798.ppEnabledExtensionNames)
}

// Ref returns a reference to C object as it is.
func (x *AllocationCallbacks) Ref() *C.VkAllocationCallbacks {
	if x == nil {
		return nil
	}
	return (*C.VkAllocationCallbacks)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *AllocationCallbacks) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewAllocationCallbacksRef converts the C object reference into a raw struct reference without wrapping.
func NewAllocationCallbacksRef(ref unsafe.Pointer) *AllocationCallbacks {
	return (*AllocationCallbacks)(ref)
}

// NewAllocationCallbacks allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewAllocationCallbacks() *AllocationCallbacks {
	return (*AllocationCallbacks)(allocAllocationCallbacksMemory(1))
}

// allocAllocationCallbacksMemory allocates memory for type C.VkAllocationCallbacks in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAllocationCallbacksMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAllocationCallbacksValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAllocationCallbacksValue = unsafe.Sizeof([1]C.VkAllocationCallbacks{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *AllocationCallbacks) PassRef() *C.VkAllocationCallbacks {
	if x == nil {
		x = (*AllocationCallbacks)(allocAllocationCallbacksMemory(1))
	}
	return (*C.VkAllocationCallbacks)(unsafe.Pointer(x))
}

// allocPhysicalDeviceFeaturesMemory allocates memory for type C.VkPhysicalDeviceFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFeatures) Ref() *C.VkPhysicalDeviceFeatures {
	if x == nil {
		return nil
	}
	return x.reff97e405d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFeatures) Free() {
	if x != nil && x.allocsf97e405d != nil {
		x.allocsf97e405d.(*cgoAllocMap).Free()
		x.reff97e405d = nil
	}
}

// NewPhysicalDeviceFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFeatures)
	obj.reff97e405d = (*C.VkPhysicalDeviceFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFeatures) PassRef() (*C.VkPhysicalDeviceFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff97e405d != nil {
		return x.reff97e405d, nil
	}
	memf97e405d := allocPhysicalDeviceFeaturesMemory(1)
	reff97e405d := (*C.VkPhysicalDeviceFeatures)(memf97e405d)
	allocsf97e405d := new(cgoAllocMap)
	allocsf97e405d.Add(memf97e405d)

	var crobustBufferAccess_allocs *cgoAllocMap
	reff97e405d.robustBufferAccess, crobustBufferAccess_allocs = (C.VkBool32)(x.RobustBufferAccess), cgoAllocsUnknown
	allocsf97e405d.Borrow(crobustBufferAccess_allocs)

	var cfullDrawIndexUint32_allocs *cgoAllocMap
	reff97e405d.fullDrawIndexUint32, cfullDrawIndexUint32_allocs = (C.VkBool32)(x.FullDrawIndexUint32), cgoAllocsUnknown
	allocsf97e405d.Borrow(cfullDrawIndexUint32_allocs)

	var cimageCubeArray_allocs *cgoAllocMap
	reff97e405d.imageCubeArray, cimageCubeArray_allocs = (C.VkBool32)(x.ImageCubeArray), cgoAllocsUnknown
	allocsf97e405d.Borrow(cimageCubeArray_allocs)

	var cindependentBlend_allocs *cgoAllocMap
	reff97e405d.independentBlend, cindependentBlend_allocs = (C.VkBool32)(x.IndependentBlend), cgoAllocsUnknown
	allocsf97e405d.Borrow(cindependentBlend_allocs)

	var cgeometryShader_allocs *cgoAllocMap
	reff97e405d.geometryShader, cgeometryShader_allocs = (C.VkBool32)(x.GeometryShader), cgoAllocsUnknown
	allocsf97e405d.Borrow(cgeometryShader_allocs)

	var ctessellationShader_allocs *cgoAllocMap
	reff97e405d.tessellationShader, ctessellationShader_allocs = (C.VkBool32)(x.TessellationShader), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctessellationShader_allocs)

	var csampleRateShading_allocs *cgoAllocMap
	reff97e405d.sampleRateShading, csampleRateShading_allocs = (C.VkBool32)(x.SampleRateShading), cgoAllocsUnknown
	allocsf97e405d.Borrow(csampleRateShading_allocs)

	var cdualSrcBlend_allocs *cgoAllocMap
	reff97e405d.dualSrcBlend, cdualSrcBlend_allocs = (C.VkBool32)(x.DualSrcBlend), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdualSrcBlend_allocs)

	var clogicOp_allocs *cgoAllocMap
	reff97e405d.logicOp, clogicOp_allocs = (C.VkBool32)(x.LogicOp), cgoAllocsUnknown
	allocsf97e405d.Borrow(clogicOp_allocs)

	var cmultiDrawIndirect_allocs *cgoAllocMap
	reff97e405d.multiDrawIndirect, cmultiDrawIndirect_allocs = (C.VkBool32)(x.MultiDrawIndirect), cgoAllocsUnknown
	allocsf97e405d.Borrow(cmultiDrawIndirect_allocs)

	var cdrawIndirectFirstInstance_allocs *cgoAllocMap
	reff97e405d.drawIndirectFirstInstance, cdrawIndirectFirstInstance_allocs = (C.VkBool32)(x.DrawIndirectFirstInstance), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdrawIndirectFirstInstance_allocs)

	var cdepthClamp_allocs *cgoAllocMap
	reff97e405d.depthClamp, cdepthClamp_allocs = (C.VkBool32)(x.DepthClamp), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdepthClamp_allocs)

	var cdepthBiasClamp_allocs *cgoAllocMap
	reff97e405d.depthBiasClamp, cdepthBiasClamp_allocs = (C.VkBool32)(x.DepthBiasClamp), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdepthBiasClamp_allocs)

	var cfillModeNonSolid_allocs *cgoAllocMap
	reff97e405d.fillModeNonSolid, cfillModeNonSolid_allocs = (C.VkBool32)(x.FillModeNonSolid), cgoAllocsUnknown
	allocsf97e405d.Borrow(cfillModeNonSolid_allocs)

	var cdepthBounds_allocs *cgoAllocMap
	reff97e405d.depthBounds, cdepthBounds_allocs = (C.VkBool32)(x.DepthBounds), cgoAllocsUnknown
	allocsf97e405d.Borrow(cdepthBounds_allocs)

	var cwideLines_allocs *cgoAllocMap
	reff97e405d.wideLines, cwideLines_allocs = (C.VkBool32)(x.WideLines), cgoAllocsUnknown
	allocsf97e405d.Borrow(cwideLines_allocs)

	var clargePoints_allocs *cgoAllocMap
	reff97e405d.largePoints, clargePoints_allocs = (C.VkBool32)(x.LargePoints), cgoAllocsUnknown
	allocsf97e405d.Borrow(clargePoints_allocs)

	var calphaToOne_allocs *cgoAllocMap
	reff97e405d.alphaToOne, calphaToOne_allocs = (C.VkBool32)(x.AlphaToOne), cgoAllocsUnknown
	allocsf97e405d.Borrow(calphaToOne_allocs)

	var cmultiViewport_allocs *cgoAllocMap
	reff97e405d.multiViewport, cmultiViewport_allocs = (C.VkBool32)(x.MultiViewport), cgoAllocsUnknown
	allocsf97e405d.Borrow(cmultiViewport_allocs)

	var csamplerAnisotropy_allocs *cgoAllocMap
	reff97e405d.samplerAnisotropy, csamplerAnisotropy_allocs = (C.VkBool32)(x.SamplerAnisotropy), cgoAllocsUnknown
	allocsf97e405d.Borrow(csamplerAnisotropy_allocs)

	var ctextureCompressionETC2_allocs *cgoAllocMap
	reff97e405d.textureCompressionETC2, ctextureCompressionETC2_allocs = (C.VkBool32)(x.TextureCompressionETC2), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctextureCompressionETC2_allocs)

	var ctextureCompressionASTC_LDR_allocs *cgoAllocMap
	reff97e405d.textureCompressionASTC_LDR, ctextureCompressionASTC_LDR_allocs = (C.VkBool32)(x.TextureCompressionASTC_LDR), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctextureCompressionASTC_LDR_allocs)

	var ctextureCompressionBC_allocs *cgoAllocMap
	reff97e405d.textureCompressionBC, ctextureCompressionBC_allocs = (C.VkBool32)(x.TextureCompressionBC), cgoAllocsUnknown
	allocsf97e405d.Borrow(ctextureCompressionBC_allocs)

	var cocclusionQueryPrecise_allocs *cgoAllocMap
	reff97e405d.occlusionQueryPrecise, cocclusionQueryPrecise_allocs = (C.VkBool32)(x.OcclusionQueryPrecise), cgoAllocsUnknown
	allocsf97e405d.Borrow(cocclusionQueryPrecise_allocs)

	var cpipelineStatisticsQuery_allocs *cgoAllocMap
	reff97e405d.pipelineStatisticsQuery, cpipelineStatisticsQuery_allocs = (C.VkBool32)(x.PipelineStatisticsQuery), cgoAllocsUnknown
	allocsf97e405d.Borrow(cpipelineStatisticsQuery_allocs)

	var cvertexPipelineStoresAndAtomics_allocs *cgoAllocMap
	reff97e405d.vertexPipelineStoresAndAtomics, cvertexPipelineStoresAndAtomics_allocs = (C.VkBool32)(x.VertexPipelineStoresAndAtomics), cgoAllocsUnknown
	allocsf97e405d.Borrow(cvertexPipelineStoresAndAtomics_allocs)

	var cfragmentStoresAndAtomics_allocs *cgoAllocMap
	reff97e405d.fragmentStoresAndAtomics, cfragmentStoresAndAtomics_allocs = (C.VkBool32)(x.FragmentStoresAndAtomics), cgoAllocsUnknown
	allocsf97e405d.Borrow(cfragmentStoresAndAtomics_allocs)

	var cshaderTessellationAndGeometryPointSize_allocs *cgoAllocMap
	reff97e405d.shaderTessellationAndGeometryPointSize, cshaderTessellationAndGeometryPointSize_allocs = (C.VkBool32)(x.ShaderTessellationAndGeometryPointSize), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderTessellationAndGeometryPointSize_allocs)

	var cshaderImageGatherExtended_allocs *cgoAllocMap
	reff97e405d.shaderImageGatherExtended, cshaderImageGatherExtended_allocs = (C.VkBool32)(x.ShaderImageGatherExtended), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderImageGatherExtended_allocs)

	var cshaderStorageImageExtendedFormats_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageExtendedFormats, cshaderStorageImageExtendedFormats_allocs = (C.VkBool32)(x.ShaderStorageImageExtendedFormats), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageExtendedFormats_allocs)

	var cshaderStorageImageMultisample_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageMultisample, cshaderStorageImageMultisample_allocs = (C.VkBool32)(x.ShaderStorageImageMultisample), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageMultisample_allocs)

	var cshaderStorageImageReadWithoutFormat_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageReadWithoutFormat, cshaderStorageImageReadWithoutFormat_allocs = (C.VkBool32)(x.ShaderStorageImageReadWithoutFormat), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageReadWithoutFormat_allocs)

	var cshaderStorageImageWriteWithoutFormat_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageWriteWithoutFormat, cshaderStorageImageWriteWithoutFormat_allocs = (C.VkBool32)(x.ShaderStorageImageWriteWithoutFormat), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageWriteWithoutFormat_allocs)

	var cshaderUniformBufferArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderUniformBufferArrayDynamicIndexing, cshaderUniformBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderUniformBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderUniformBufferArrayDynamicIndexing_allocs)

	var cshaderSampledImageArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderSampledImageArrayDynamicIndexing, cshaderSampledImageArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderSampledImageArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderSampledImageArrayDynamicIndexing_allocs)

	var cshaderStorageBufferArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderStorageBufferArrayDynamicIndexing, cshaderStorageBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderStorageBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageBufferArrayDynamicIndexing_allocs)

	var cshaderStorageImageArrayDynamicIndexing_allocs *cgoAllocMap
	reff97e405d.shaderStorageImageArrayDynamicIndexing, cshaderStorageImageArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderStorageImageArrayDynamicIndexing), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderStorageImageArrayDynamicIndexing_allocs)

	var cshaderClipDistance_allocs *cgoAllocMap
	reff97e405d.shaderClipDistance, cshaderClipDistance_allocs = (C.VkBool32)(x.ShaderClipDistance), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderClipDistance_allocs)

	var cshaderCullDistance_allocs *cgoAllocMap
	reff97e405d.shaderCullDistance, cshaderCullDistance_allocs = (C.VkBool32)(x.ShaderCullDistance), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderCullDistance_allocs)

	var cshaderFloat64_allocs *cgoAllocMap
	reff97e405d.shaderFloat64, cshaderFloat64_allocs = (C.VkBool32)(x.ShaderFloat64), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderFloat64_allocs)

	var cshaderInt64_allocs *cgoAllocMap
	reff97e405d.shaderInt64, cshaderInt64_allocs = (C.VkBool32)(x.ShaderInt64), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderInt64_allocs)

	var cshaderInt16_allocs *cgoAllocMap
	reff97e405d.shaderInt16, cshaderInt16_allocs = (C.VkBool32)(x.ShaderInt16), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderInt16_allocs)

	var cshaderResourceResidency_allocs *cgoAllocMap
	reff97e405d.shaderResourceResidency, cshaderResourceResidency_allocs = (C.VkBool32)(x.ShaderResourceResidency), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderResourceResidency_allocs)

	var cshaderResourceMinLod_allocs *cgoAllocMap
	reff97e405d.shaderResourceMinLod, cshaderResourceMinLod_allocs = (C.VkBool32)(x.ShaderResourceMinLod), cgoAllocsUnknown
	allocsf97e405d.Borrow(cshaderResourceMinLod_allocs)

	var csparseBinding_allocs *cgoAllocMap
	reff97e405d.sparseBinding, csparseBinding_allocs = (C.VkBool32)(x.SparseBinding), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseBinding_allocs)

	var csparseResidencyBuffer_allocs *cgoAllocMap
	reff97e405d.sparseResidencyBuffer, csparseResidencyBuffer_allocs = (C.VkBool32)(x.SparseResidencyBuffer), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyBuffer_allocs)

	var csparseResidencyImage2D_allocs *cgoAllocMap
	reff97e405d.sparseResidencyImage2D, csparseResidencyImage2D_allocs = (C.VkBool32)(x.SparseResidencyImage2D), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyImage2D_allocs)

	var csparseResidencyImage3D_allocs *cgoAllocMap
	reff97e405d.sparseResidencyImage3D, csparseResidencyImage3D_allocs = (C.VkBool32)(x.SparseResidencyImage3D), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyImage3D_allocs)

	var csparseResidency2Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency2Samples, csparseResidency2Samples_allocs = (C.VkBool32)(x.SparseResidency2Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency2Samples_allocs)

	var csparseResidency4Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency4Samples, csparseResidency4Samples_allocs = (C.VkBool32)(x.SparseResidency4Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency4Samples_allocs)

	var csparseResidency8Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency8Samples, csparseResidency8Samples_allocs = (C.VkBool32)(x.SparseResidency8Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency8Samples_allocs)

	var csparseResidency16Samples_allocs *cgoAllocMap
	reff97e405d.sparseResidency16Samples, csparseResidency16Samples_allocs = (C.VkBool32)(x.SparseResidency16Samples), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidency16Samples_allocs)

	var csparseResidencyAliased_allocs *cgoAllocMap
	reff97e405d.sparseResidencyAliased, csparseResidencyAliased_allocs = (C.VkBool32)(x.SparseResidencyAliased), cgoAllocsUnknown
	allocsf97e405d.Borrow(csparseResidencyAliased_allocs)

	var cvariableMultisampleRate_allocs *cgoAllocMap
	reff97e405d.variableMultisampleRate, cvariableMultisampleRate_allocs = (C.VkBool32)(x.VariableMultisampleRate), cgoAllocsUnknown
	allocsf97e405d.Borrow(cvariableMultisampleRate_allocs)

	var cinheritedQueries_allocs *cgoAllocMap
	reff97e405d.inheritedQueries, cinheritedQueries_allocs = (C.VkBool32)(x.InheritedQueries), cgoAllocsUnknown
	allocsf97e405d.Borrow(cinheritedQueries_allocs)

	x.reff97e405d = reff97e405d
	x.allocsf97e405d = allocsf97e405d
	return reff97e405d, allocsf97e405d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFeatures) PassValue() (C.VkPhysicalDeviceFeatures, *cgoAllocMap) {
	if x.reff97e405d != nil {
		return *x.reff97e405d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFeatures) Deref() {
	if x.reff97e405d == nil {
		return
	}
	x.RobustBufferAccess = (Bool32)(x.reff97e405d.robustBufferAccess)
	x.FullDrawIndexUint32 = (Bool32)(x.reff97e405d.fullDrawIndexUint32)
	x.ImageCubeArray = (Bool32)(x.reff97e405d.imageCubeArray)
	x.IndependentBlend = (Bool32)(x.reff97e405d.independentBlend)
	x.GeometryShader = (Bool32)(x.reff97e405d.geometryShader)
	x.TessellationShader = (Bool32)(x.reff97e405d.tessellationShader)
	x.SampleRateShading = (Bool32)(x.reff97e405d.sampleRateShading)
	x.DualSrcBlend = (Bool32)(x.reff97e405d.dualSrcBlend)
	x.LogicOp = (Bool32)(x.reff97e405d.logicOp)
	x.MultiDrawIndirect = (Bool32)(x.reff97e405d.multiDrawIndirect)
	x.DrawIndirectFirstInstance = (Bool32)(x.reff97e405d.drawIndirectFirstInstance)
	x.DepthClamp = (Bool32)(x.reff97e405d.depthClamp)
	x.DepthBiasClamp = (Bool32)(x.reff97e405d.depthBiasClamp)
	x.FillModeNonSolid = (Bool32)(x.reff97e405d.fillModeNonSolid)
	x.DepthBounds = (Bool32)(x.reff97e405d.depthBounds)
	x.WideLines = (Bool32)(x.reff97e405d.wideLines)
	x.LargePoints = (Bool32)(x.reff97e405d.largePoints)
	x.AlphaToOne = (Bool32)(x.reff97e405d.alphaToOne)
	x.MultiViewport = (Bool32)(x.reff97e405d.multiViewport)
	x.SamplerAnisotropy = (Bool32)(x.reff97e405d.samplerAnisotropy)
	x.TextureCompressionETC2 = (Bool32)(x.reff97e405d.textureCompressionETC2)
	x.TextureCompressionASTC_LDR = (Bool32)(x.reff97e405d.textureCompressionASTC_LDR)
	x.TextureCompressionBC = (Bool32)(x.reff97e405d.textureCompressionBC)
	x.OcclusionQueryPrecise = (Bool32)(x.reff97e405d.occlusionQueryPrecise)
	x.PipelineStatisticsQuery = (Bool32)(x.reff97e405d.pipelineStatisticsQuery)
	x.VertexPipelineStoresAndAtomics = (Bool32)(x.reff97e405d.vertexPipelineStoresAndAtomics)
	x.FragmentStoresAndAtomics = (Bool32)(x.reff97e405d.fragmentStoresAndAtomics)
	x.ShaderTessellationAndGeometryPointSize = (Bool32)(x.reff97e405d.shaderTessellationAndGeometryPointSize)
	x.ShaderImageGatherExtended = (Bool32)(x.reff97e405d.shaderImageGatherExtended)
	x.ShaderStorageImageExtendedFormats = (Bool32)(x.reff97e405d.shaderStorageImageExtendedFormats)
	x.ShaderStorageImageMultisample = (Bool32)(x.reff97e405d.shaderStorageImageMultisample)
	x.ShaderStorageImageReadWithoutFormat = (Bool32)(x.reff97e405d.shaderStorageImageReadWithoutFormat)
	x.ShaderStorageImageWriteWithoutFormat = (Bool32)(x.reff97e405d.shaderStorageImageWriteWithoutFormat)
	x.ShaderUniformBufferArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderUniformBufferArrayDynamicIndexing)
	x.ShaderSampledImageArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderSampledImageArrayDynamicIndexing)
	x.ShaderStorageBufferArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderStorageBufferArrayDynamicIndexing)
	x.ShaderStorageImageArrayDynamicIndexing = (Bool32)(x.reff97e405d.shaderStorageImageArrayDynamicIndexing)
	x.ShaderClipDistance = (Bool32)(x.reff97e405d.shaderClipDistance)
	x.ShaderCullDistance = (Bool32)(x.reff97e405d.shaderCullDistance)
	x.ShaderFloat64 = (Bool32)(x.reff97e405d.shaderFloat64)
	x.ShaderInt64 = (Bool32)(x.reff97e405d.shaderInt64)
	x.ShaderInt16 = (Bool32)(x.reff97e405d.shaderInt16)
	x.ShaderResourceResidency = (Bool32)(x.reff97e405d.shaderResourceResidency)
	x.ShaderResourceMinLod = (Bool32)(x.reff97e405d.shaderResourceMinLod)
	x.SparseBinding = (Bool32)(x.reff97e405d.sparseBinding)
	x.SparseResidencyBuffer = (Bool32)(x.reff97e405d.sparseResidencyBuffer)
	x.SparseResidencyImage2D = (Bool32)(x.reff97e405d.sparseResidencyImage2D)
	x.SparseResidencyImage3D = (Bool32)(x.reff97e405d.sparseResidencyImage3D)
	x.SparseResidency2Samples = (Bool32)(x.reff97e405d.sparseResidency2Samples)
	x.SparseResidency4Samples = (Bool32)(x.reff97e405d.sparseResidency4Samples)
	x.SparseResidency8Samples = (Bool32)(x.reff97e405d.sparseResidency8Samples)
	x.SparseResidency16Samples = (Bool32)(x.reff97e405d.sparseResidency16Samples)
	x.SparseResidencyAliased = (Bool32)(x.reff97e405d.sparseResidencyAliased)
	x.VariableMultisampleRate = (Bool32)(x.reff97e405d.variableMultisampleRate)
	x.InheritedQueries = (Bool32)(x.reff97e405d.inheritedQueries)
}

// allocFormatPropertiesMemory allocates memory for type C.VkFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFormatPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFormatPropertiesValue = unsafe.Sizeof([1]C.VkFormatProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FormatProperties) Ref() *C.VkFormatProperties {
	if x == nil {
		return nil
	}
	return x.refc4b9937b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FormatProperties) Free() {
	if x != nil && x.allocsc4b9937b != nil {
		x.allocsc4b9937b.(*cgoAllocMap).Free()
		x.refc4b9937b = nil
	}
}

// NewFormatPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFormatPropertiesRef(ref unsafe.Pointer) *FormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(FormatProperties)
	obj.refc4b9937b = (*C.VkFormatProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FormatProperties) PassRef() (*C.VkFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc4b9937b != nil {
		return x.refc4b9937b, nil
	}
	memc4b9937b := allocFormatPropertiesMemory(1)
	refc4b9937b := (*C.VkFormatProperties)(memc4b9937b)
	allocsc4b9937b := new(cgoAllocMap)
	allocsc4b9937b.Add(memc4b9937b)

	var clinearTilingFeatures_allocs *cgoAllocMap
	refc4b9937b.linearTilingFeatures, clinearTilingFeatures_allocs = (C.VkFormatFeatureFlags)(x.LinearTilingFeatures), cgoAllocsUnknown
	allocsc4b9937b.Borrow(clinearTilingFeatures_allocs)

	var coptimalTilingFeatures_allocs *cgoAllocMap
	refc4b9937b.optimalTilingFeatures, coptimalTilingFeatures_allocs = (C.VkFormatFeatureFlags)(x.OptimalTilingFeatures), cgoAllocsUnknown
	allocsc4b9937b.Borrow(coptimalTilingFeatures_allocs)

	var cbufferFeatures_allocs *cgoAllocMap
	refc4b9937b.bufferFeatures, cbufferFeatures_allocs = (C.VkFormatFeatureFlags)(x.BufferFeatures), cgoAllocsUnknown
	allocsc4b9937b.Borrow(cbufferFeatures_allocs)

	x.refc4b9937b = refc4b9937b
	x.allocsc4b9937b = allocsc4b9937b
	return refc4b9937b, allocsc4b9937b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FormatProperties) PassValue() (C.VkFormatProperties, *cgoAllocMap) {
	if x.refc4b9937b != nil {
		return *x.refc4b9937b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FormatProperties) Deref() {
	if x.refc4b9937b == nil {
		return
	}
	x.LinearTilingFeatures = (FormatFeatureFlags)(x.refc4b9937b.linearTilingFeatures)
	x.OptimalTilingFeatures = (FormatFeatureFlags)(x.refc4b9937b.optimalTilingFeatures)
	x.BufferFeatures = (FormatFeatureFlags)(x.refc4b9937b.bufferFeatures)
}

// allocExtent3DMemory allocates memory for type C.VkExtent3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExtent3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExtent3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExtent3DValue = unsafe.Sizeof([1]C.VkExtent3D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Extent3D) Ref() *C.VkExtent3D {
	if x == nil {
		return nil
	}
	return x.reffbf6c42a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Extent3D) Free() {
	if x != nil && x.allocsfbf6c42a != nil {
		x.allocsfbf6c42a.(*cgoAllocMap).Free()
		x.reffbf6c42a = nil
	}
}

// NewExtent3DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExtent3DRef(ref unsafe.Pointer) *Extent3D {
	if ref == nil {
		return nil
	}
	obj := new(Extent3D)
	obj.reffbf6c42a = (*C.VkExtent3D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Extent3D) PassRef() (*C.VkExtent3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffbf6c42a != nil {
		return x.reffbf6c42a, nil
	}
	memfbf6c42a := allocExtent3DMemory(1)
	reffbf6c42a := (*C.VkExtent3D)(memfbf6c42a)
	allocsfbf6c42a := new(cgoAllocMap)
	allocsfbf6c42a.Add(memfbf6c42a)

	var cwidth_allocs *cgoAllocMap
	reffbf6c42a.width, cwidth_allocs = (C.uint32_t)(x.Width), cgoAllocsUnknown
	allocsfbf6c42a.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	reffbf6c42a.height, cheight_allocs = (C.uint32_t)(x.Height), cgoAllocsUnknown
	allocsfbf6c42a.Borrow(cheight_allocs)

	var cdepth_allocs *cgoAllocMap
	reffbf6c42a.depth, cdepth_allocs = (C.uint32_t)(x.Depth), cgoAllocsUnknown
	allocsfbf6c42a.Borrow(cdepth_allocs)

	x.reffbf6c42a = reffbf6c42a
	x.allocsfbf6c42a = allocsfbf6c42a
	return reffbf6c42a, allocsfbf6c42a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Extent3D) PassValue() (C.VkExtent3D, *cgoAllocMap) {
	if x.reffbf6c42a != nil {
		return *x.reffbf6c42a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Extent3D) Deref() {
	if x.reffbf6c42a == nil {
		return
	}
	x.Width = (uint32)(x.reffbf6c42a.width)
	x.Height = (uint32)(x.reffbf6c42a.height)
	x.Depth = (uint32)(x.reffbf6c42a.depth)
}

// allocImageFormatPropertiesMemory allocates memory for type C.VkImageFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageFormatPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkImageFormatProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageFormatProperties) Ref() *C.VkImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.ref4cfb2ea2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageFormatProperties) Free() {
	if x != nil && x.allocs4cfb2ea2 != nil {
		x.allocs4cfb2ea2.(*cgoAllocMap).Free()
		x.ref4cfb2ea2 = nil
	}
}

// NewImageFormatPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageFormatPropertiesRef(ref unsafe.Pointer) *ImageFormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(ImageFormatProperties)
	obj.ref4cfb2ea2 = (*C.VkImageFormatProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageFormatProperties) PassRef() (*C.VkImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4cfb2ea2 != nil {
		return x.ref4cfb2ea2, nil
	}
	mem4cfb2ea2 := allocImageFormatPropertiesMemory(1)
	ref4cfb2ea2 := (*C.VkImageFormatProperties)(mem4cfb2ea2)
	allocs4cfb2ea2 := new(cgoAllocMap)
	allocs4cfb2ea2.Add(mem4cfb2ea2)

	var cmaxExtent_allocs *cgoAllocMap
	ref4cfb2ea2.maxExtent, cmaxExtent_allocs = x.MaxExtent.PassValue()
	allocs4cfb2ea2.Borrow(cmaxExtent_allocs)

	var cmaxMipLevels_allocs *cgoAllocMap
	ref4cfb2ea2.maxMipLevels, cmaxMipLevels_allocs = (C.uint32_t)(x.MaxMipLevels), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(cmaxMipLevels_allocs)

	var cmaxArrayLayers_allocs *cgoAllocMap
	ref4cfb2ea2.maxArrayLayers, cmaxArrayLayers_allocs = (C.uint32_t)(x.MaxArrayLayers), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(cmaxArrayLayers_allocs)

	var csampleCounts_allocs *cgoAllocMap
	ref4cfb2ea2.sampleCounts, csampleCounts_allocs = (C.VkSampleCountFlags)(x.SampleCounts), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(csampleCounts_allocs)

	var cmaxResourceSize_allocs *cgoAllocMap
	ref4cfb2ea2.maxResourceSize, cmaxResourceSize_allocs = (C.VkDeviceSize)(x.MaxResourceSize), cgoAllocsUnknown
	allocs4cfb2ea2.Borrow(cmaxResourceSize_allocs)

	x.ref4cfb2ea2 = ref4cfb2ea2
	x.allocs4cfb2ea2 = allocs4cfb2ea2
	return ref4cfb2ea2, allocs4cfb2ea2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageFormatProperties) PassValue() (C.VkImageFormatProperties, *cgoAllocMap) {
	if x.ref4cfb2ea2 != nil {
		return *x.ref4cfb2ea2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageFormatProperties) Deref() {
	if x.ref4cfb2ea2 == nil {
		return
	}
	x.MaxExtent = *NewExtent3DRef(unsafe.Pointer(&x.ref4cfb2ea2.maxExtent))
	x.MaxMipLevels = (uint32)(x.ref4cfb2ea2.maxMipLevels)
	x.MaxArrayLayers = (uint32)(x.ref4cfb2ea2.maxArrayLayers)
	x.SampleCounts = (SampleCountFlags)(x.ref4cfb2ea2.sampleCounts)
	x.MaxResourceSize = (DeviceSize)(x.ref4cfb2ea2.maxResourceSize)
}

// allocPhysicalDeviceLimitsMemory allocates memory for type C.VkPhysicalDeviceLimits in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceLimitsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceLimitsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceLimitsValue = unsafe.Sizeof([1]C.VkPhysicalDeviceLimits{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceLimits) Ref() *C.VkPhysicalDeviceLimits {
	if x == nil {
		return nil
	}
	return x.ref7926795a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceLimits) Free() {
	if x != nil && x.allocs7926795a != nil {
		x.allocs7926795a.(*cgoAllocMap).Free()
		x.ref7926795a = nil
	}
}

// NewPhysicalDeviceLimitsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceLimitsRef(ref unsafe.Pointer) *PhysicalDeviceLimits {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceLimits)
	obj.ref7926795a = (*C.VkPhysicalDeviceLimits)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceLimits) PassRef() (*C.VkPhysicalDeviceLimits, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7926795a != nil {
		return x.ref7926795a, nil
	}
	mem7926795a := allocPhysicalDeviceLimitsMemory(1)
	ref7926795a := (*C.VkPhysicalDeviceLimits)(mem7926795a)
	allocs7926795a := new(cgoAllocMap)
	allocs7926795a.Add(mem7926795a)

	var cmaxImageDimension1D_allocs *cgoAllocMap
	ref7926795a.maxImageDimension1D, cmaxImageDimension1D_allocs = (C.uint32_t)(x.MaxImageDimension1D), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimension1D_allocs)

	var cmaxImageDimension2D_allocs *cgoAllocMap
	ref7926795a.maxImageDimension2D, cmaxImageDimension2D_allocs = (C.uint32_t)(x.MaxImageDimension2D), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimension2D_allocs)

	var cmaxImageDimension3D_allocs *cgoAllocMap
	ref7926795a.maxImageDimension3D, cmaxImageDimension3D_allocs = (C.uint32_t)(x.MaxImageDimension3D), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimension3D_allocs)

	var cmaxImageDimensionCube_allocs *cgoAllocMap
	ref7926795a.maxImageDimensionCube, cmaxImageDimensionCube_allocs = (C.uint32_t)(x.MaxImageDimensionCube), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageDimensionCube_allocs)

	var cmaxImageArrayLayers_allocs *cgoAllocMap
	ref7926795a.maxImageArrayLayers, cmaxImageArrayLayers_allocs = (C.uint32_t)(x.MaxImageArrayLayers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxImageArrayLayers_allocs)

	var cmaxTexelBufferElements_allocs *cgoAllocMap
	ref7926795a.maxTexelBufferElements, cmaxTexelBufferElements_allocs = (C.uint32_t)(x.MaxTexelBufferElements), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTexelBufferElements_allocs)

	var cmaxUniformBufferRange_allocs *cgoAllocMap
	ref7926795a.maxUniformBufferRange, cmaxUniformBufferRange_allocs = (C.uint32_t)(x.MaxUniformBufferRange), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxUniformBufferRange_allocs)

	var cmaxStorageBufferRange_allocs *cgoAllocMap
	ref7926795a.maxStorageBufferRange, cmaxStorageBufferRange_allocs = (C.uint32_t)(x.MaxStorageBufferRange), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxStorageBufferRange_allocs)

	var cmaxPushConstantsSize_allocs *cgoAllocMap
	ref7926795a.maxPushConstantsSize, cmaxPushConstantsSize_allocs = (C.uint32_t)(x.MaxPushConstantsSize), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPushConstantsSize_allocs)

	var cmaxMemoryAllocationCount_allocs *cgoAllocMap
	ref7926795a.maxMemoryAllocationCount, cmaxMemoryAllocationCount_allocs = (C.uint32_t)(x.MaxMemoryAllocationCount), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxMemoryAllocationCount_allocs)

	var cmaxSamplerAllocationCount_allocs *cgoAllocMap
	ref7926795a.maxSamplerAllocationCount, cmaxSamplerAllocationCount_allocs = (C.uint32_t)(x.MaxSamplerAllocationCount), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSamplerAllocationCount_allocs)

	var cbufferImageGranularity_allocs *cgoAllocMap
	ref7926795a.bufferImageGranularity, cbufferImageGranularity_allocs = (C.VkDeviceSize)(x.BufferImageGranularity), cgoAllocsUnknown
	allocs7926795a.Borrow(cbufferImageGranularity_allocs)

	var csparseAddressSpaceSize_allocs *cgoAllocMap
	ref7926795a.sparseAddressSpaceSize, csparseAddressSpaceSize_allocs = (C.VkDeviceSize)(x.SparseAddressSpaceSize), cgoAllocsUnknown
	allocs7926795a.Borrow(csparseAddressSpaceSize_allocs)

	var cmaxBoundDescriptorSets_allocs *cgoAllocMap
	ref7926795a.maxBoundDescriptorSets, cmaxBoundDescriptorSets_allocs = (C.uint32_t)(x.MaxBoundDescriptorSets), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxBoundDescriptorSets_allocs)

	var cmaxPerStageDescriptorSamplers_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorSamplers, cmaxPerStageDescriptorSamplers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorSamplers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorSamplers_allocs)

	var cmaxPerStageDescriptorUniformBuffers_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorUniformBuffers, cmaxPerStageDescriptorUniformBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUniformBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorUniformBuffers_allocs)

	var cmaxPerStageDescriptorStorageBuffers_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorStorageBuffers, cmaxPerStageDescriptorStorageBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorStorageBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorStorageBuffers_allocs)

	var cmaxPerStageDescriptorSampledImages_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorSampledImages, cmaxPerStageDescriptorSampledImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorSampledImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorSampledImages_allocs)

	var cmaxPerStageDescriptorStorageImages_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorStorageImages, cmaxPerStageDescriptorStorageImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorStorageImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorStorageImages_allocs)

	var cmaxPerStageDescriptorInputAttachments_allocs *cgoAllocMap
	ref7926795a.maxPerStageDescriptorInputAttachments, cmaxPerStageDescriptorInputAttachments_allocs = (C.uint32_t)(x.MaxPerStageDescriptorInputAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageDescriptorInputAttachments_allocs)

	var cmaxPerStageResources_allocs *cgoAllocMap
	ref7926795a.maxPerStageResources, cmaxPerStageResources_allocs = (C.uint32_t)(x.MaxPerStageResources), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxPerStageResources_allocs)

	var cmaxDescriptorSetSamplers_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetSamplers, cmaxDescriptorSetSamplers_allocs = (C.uint32_t)(x.MaxDescriptorSetSamplers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetSamplers_allocs)

	var cmaxDescriptorSetUniformBuffers_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetUniformBuffers, cmaxDescriptorSetUniformBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetUniformBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetUniformBuffers_allocs)

	var cmaxDescriptorSetUniformBuffersDynamic_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetUniformBuffersDynamic, cmaxDescriptorSetUniformBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetUniformBuffersDynamic), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetUniformBuffersDynamic_allocs)

	var cmaxDescriptorSetStorageBuffers_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetStorageBuffers, cmaxDescriptorSetStorageBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetStorageBuffers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetStorageBuffers_allocs)

	var cmaxDescriptorSetStorageBuffersDynamic_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetStorageBuffersDynamic, cmaxDescriptorSetStorageBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetStorageBuffersDynamic), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetStorageBuffersDynamic_allocs)

	var cmaxDescriptorSetSampledImages_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetSampledImages, cmaxDescriptorSetSampledImages_allocs = (C.uint32_t)(x.MaxDescriptorSetSampledImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetSampledImages_allocs)

	var cmaxDescriptorSetStorageImages_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetStorageImages, cmaxDescriptorSetStorageImages_allocs = (C.uint32_t)(x.MaxDescriptorSetStorageImages), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetStorageImages_allocs)

	var cmaxDescriptorSetInputAttachments_allocs *cgoAllocMap
	ref7926795a.maxDescriptorSetInputAttachments, cmaxDescriptorSetInputAttachments_allocs = (C.uint32_t)(x.MaxDescriptorSetInputAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDescriptorSetInputAttachments_allocs)

	var cmaxVertexInputAttributes_allocs *cgoAllocMap
	ref7926795a.maxVertexInputAttributes, cmaxVertexInputAttributes_allocs = (C.uint32_t)(x.MaxVertexInputAttributes), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputAttributes_allocs)

	var cmaxVertexInputBindings_allocs *cgoAllocMap
	ref7926795a.maxVertexInputBindings, cmaxVertexInputBindings_allocs = (C.uint32_t)(x.MaxVertexInputBindings), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputBindings_allocs)

	var cmaxVertexInputAttributeOffset_allocs *cgoAllocMap
	ref7926795a.maxVertexInputAttributeOffset, cmaxVertexInputAttributeOffset_allocs = (C.uint32_t)(x.MaxVertexInputAttributeOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputAttributeOffset_allocs)

	var cmaxVertexInputBindingStride_allocs *cgoAllocMap
	ref7926795a.maxVertexInputBindingStride, cmaxVertexInputBindingStride_allocs = (C.uint32_t)(x.MaxVertexInputBindingStride), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexInputBindingStride_allocs)

	var cmaxVertexOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxVertexOutputComponents, cmaxVertexOutputComponents_allocs = (C.uint32_t)(x.MaxVertexOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxVertexOutputComponents_allocs)

	var cmaxTessellationGenerationLevel_allocs *cgoAllocMap
	ref7926795a.maxTessellationGenerationLevel, cmaxTessellationGenerationLevel_allocs = (C.uint32_t)(x.MaxTessellationGenerationLevel), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationGenerationLevel_allocs)

	var cmaxTessellationPatchSize_allocs *cgoAllocMap
	ref7926795a.maxTessellationPatchSize, cmaxTessellationPatchSize_allocs = (C.uint32_t)(x.MaxTessellationPatchSize), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationPatchSize_allocs)

	var cmaxTessellationControlPerVertexInputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlPerVertexInputComponents, cmaxTessellationControlPerVertexInputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlPerVertexInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlPerVertexInputComponents_allocs)

	var cmaxTessellationControlPerVertexOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlPerVertexOutputComponents, cmaxTessellationControlPerVertexOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlPerVertexOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlPerVertexOutputComponents_allocs)

	var cmaxTessellationControlPerPatchOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlPerPatchOutputComponents, cmaxTessellationControlPerPatchOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlPerPatchOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlPerPatchOutputComponents_allocs)

	var cmaxTessellationControlTotalOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationControlTotalOutputComponents, cmaxTessellationControlTotalOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationControlTotalOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationControlTotalOutputComponents_allocs)

	var cmaxTessellationEvaluationInputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationEvaluationInputComponents, cmaxTessellationEvaluationInputComponents_allocs = (C.uint32_t)(x.MaxTessellationEvaluationInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationEvaluationInputComponents_allocs)

	var cmaxTessellationEvaluationOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxTessellationEvaluationOutputComponents, cmaxTessellationEvaluationOutputComponents_allocs = (C.uint32_t)(x.MaxTessellationEvaluationOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTessellationEvaluationOutputComponents_allocs)

	var cmaxGeometryShaderInvocations_allocs *cgoAllocMap
	ref7926795a.maxGeometryShaderInvocations, cmaxGeometryShaderInvocations_allocs = (C.uint32_t)(x.MaxGeometryShaderInvocations), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryShaderInvocations_allocs)

	var cmaxGeometryInputComponents_allocs *cgoAllocMap
	ref7926795a.maxGeometryInputComponents, cmaxGeometryInputComponents_allocs = (C.uint32_t)(x.MaxGeometryInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryInputComponents_allocs)

	var cmaxGeometryOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxGeometryOutputComponents, cmaxGeometryOutputComponents_allocs = (C.uint32_t)(x.MaxGeometryOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryOutputComponents_allocs)

	var cmaxGeometryOutputVertices_allocs *cgoAllocMap
	ref7926795a.maxGeometryOutputVertices, cmaxGeometryOutputVertices_allocs = (C.uint32_t)(x.MaxGeometryOutputVertices), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryOutputVertices_allocs)

	var cmaxGeometryTotalOutputComponents_allocs *cgoAllocMap
	ref7926795a.maxGeometryTotalOutputComponents, cmaxGeometryTotalOutputComponents_allocs = (C.uint32_t)(x.MaxGeometryTotalOutputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxGeometryTotalOutputComponents_allocs)

	var cmaxFragmentInputComponents_allocs *cgoAllocMap
	ref7926795a.maxFragmentInputComponents, cmaxFragmentInputComponents_allocs = (C.uint32_t)(x.MaxFragmentInputComponents), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentInputComponents_allocs)

	var cmaxFragmentOutputAttachments_allocs *cgoAllocMap
	ref7926795a.maxFragmentOutputAttachments, cmaxFragmentOutputAttachments_allocs = (C.uint32_t)(x.MaxFragmentOutputAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentOutputAttachments_allocs)

	var cmaxFragmentDualSrcAttachments_allocs *cgoAllocMap
	ref7926795a.maxFragmentDualSrcAttachments, cmaxFragmentDualSrcAttachments_allocs = (C.uint32_t)(x.MaxFragmentDualSrcAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentDualSrcAttachments_allocs)

	var cmaxFragmentCombinedOutputResources_allocs *cgoAllocMap
	ref7926795a.maxFragmentCombinedOutputResources, cmaxFragmentCombinedOutputResources_allocs = (C.uint32_t)(x.MaxFragmentCombinedOutputResources), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFragmentCombinedOutputResources_allocs)

	var cmaxComputeSharedMemorySize_allocs *cgoAllocMap
	ref7926795a.maxComputeSharedMemorySize, cmaxComputeSharedMemorySize_allocs = (C.uint32_t)(x.MaxComputeSharedMemorySize), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeSharedMemorySize_allocs)

	var cmaxComputeWorkGroupCount_allocs *cgoAllocMap
	ref7926795a.maxComputeWorkGroupCount, cmaxComputeWorkGroupCount_allocs = *(*[3]C.uint32_t)(unsafe.Pointer(&x.MaxComputeWorkGroupCount)), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeWorkGroupCount_allocs)

	var cmaxComputeWorkGroupInvocations_allocs *cgoAllocMap
	ref7926795a.maxComputeWorkGroupInvocations, cmaxComputeWorkGroupInvocations_allocs = (C.uint32_t)(x.MaxComputeWorkGroupInvocations), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeWorkGroupInvocations_allocs)

	var cmaxComputeWorkGroupSize_allocs *cgoAllocMap
	ref7926795a.maxComputeWorkGroupSize, cmaxComputeWorkGroupSize_allocs = *(*[3]C.uint32_t)(unsafe.Pointer(&x.MaxComputeWorkGroupSize)), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxComputeWorkGroupSize_allocs)

	var csubPixelPrecisionBits_allocs *cgoAllocMap
	ref7926795a.subPixelPrecisionBits, csubPixelPrecisionBits_allocs = (C.uint32_t)(x.SubPixelPrecisionBits), cgoAllocsUnknown
	allocs7926795a.Borrow(csubPixelPrecisionBits_allocs)

	var csubTexelPrecisionBits_allocs *cgoAllocMap
	ref7926795a.subTexelPrecisionBits, csubTexelPrecisionBits_allocs = (C.uint32_t)(x.SubTexelPrecisionBits), cgoAllocsUnknown
	allocs7926795a.Borrow(csubTexelPrecisionBits_allocs)

	var cmipmapPrecisionBits_allocs *cgoAllocMap
	ref7926795a.mipmapPrecisionBits, cmipmapPrecisionBits_allocs = (C.uint32_t)(x.MipmapPrecisionBits), cgoAllocsUnknown
	allocs7926795a.Borrow(cmipmapPrecisionBits_allocs)

	var cmaxDrawIndexedIndexValue_allocs *cgoAllocMap
	ref7926795a.maxDrawIndexedIndexValue, cmaxDrawIndexedIndexValue_allocs = (C.uint32_t)(x.MaxDrawIndexedIndexValue), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDrawIndexedIndexValue_allocs)

	var cmaxDrawIndirectCount_allocs *cgoAllocMap
	ref7926795a.maxDrawIndirectCount, cmaxDrawIndirectCount_allocs = (C.uint32_t)(x.MaxDrawIndirectCount), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxDrawIndirectCount_allocs)

	var cmaxSamplerLodBias_allocs *cgoAllocMap
	ref7926795a.maxSamplerLodBias, cmaxSamplerLodBias_allocs = (C.float)(x.MaxSamplerLodBias), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSamplerLodBias_allocs)

	var cmaxSamplerAnisotropy_allocs *cgoAllocMap
	ref7926795a.maxSamplerAnisotropy, cmaxSamplerAnisotropy_allocs = (C.float)(x.MaxSamplerAnisotropy), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSamplerAnisotropy_allocs)

	var cmaxViewports_allocs *cgoAllocMap
	ref7926795a.maxViewports, cmaxViewports_allocs = (C.uint32_t)(x.MaxViewports), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxViewports_allocs)

	var cmaxViewportDimensions_allocs *cgoAllocMap
	ref7926795a.maxViewportDimensions, cmaxViewportDimensions_allocs = *(*[2]C.uint32_t)(unsafe.Pointer(&x.MaxViewportDimensions)), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxViewportDimensions_allocs)

	var cviewportBoundsRange_allocs *cgoAllocMap
	ref7926795a.viewportBoundsRange, cviewportBoundsRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.ViewportBoundsRange)), cgoAllocsUnknown
	allocs7926795a.Borrow(cviewportBoundsRange_allocs)

	var cviewportSubPixelBits_allocs *cgoAllocMap
	ref7926795a.viewportSubPixelBits, cviewportSubPixelBits_allocs = (C.uint32_t)(x.ViewportSubPixelBits), cgoAllocsUnknown
	allocs7926795a.Borrow(cviewportSubPixelBits_allocs)

	var cminMemoryMapAlignment_allocs *cgoAllocMap
	ref7926795a.minMemoryMapAlignment, cminMemoryMapAlignment_allocs = (C.size_t)(x.MinMemoryMapAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminMemoryMapAlignment_allocs)

	var cminTexelBufferOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.minTexelBufferOffsetAlignment, cminTexelBufferOffsetAlignment_allocs = (C.VkDeviceSize)(x.MinTexelBufferOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminTexelBufferOffsetAlignment_allocs)

	var cminUniformBufferOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.minUniformBufferOffsetAlignment, cminUniformBufferOffsetAlignment_allocs = (C.VkDeviceSize)(x.MinUniformBufferOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminUniformBufferOffsetAlignment_allocs)

	var cminStorageBufferOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.minStorageBufferOffsetAlignment, cminStorageBufferOffsetAlignment_allocs = (C.VkDeviceSize)(x.MinStorageBufferOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(cminStorageBufferOffsetAlignment_allocs)

	var cminTexelOffset_allocs *cgoAllocMap
	ref7926795a.minTexelOffset, cminTexelOffset_allocs = (C.int32_t)(x.MinTexelOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cminTexelOffset_allocs)

	var cmaxTexelOffset_allocs *cgoAllocMap
	ref7926795a.maxTexelOffset, cmaxTexelOffset_allocs = (C.uint32_t)(x.MaxTexelOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTexelOffset_allocs)

	var cminTexelGatherOffset_allocs *cgoAllocMap
	ref7926795a.minTexelGatherOffset, cminTexelGatherOffset_allocs = (C.int32_t)(x.MinTexelGatherOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cminTexelGatherOffset_allocs)

	var cmaxTexelGatherOffset_allocs *cgoAllocMap
	ref7926795a.maxTexelGatherOffset, cmaxTexelGatherOffset_allocs = (C.uint32_t)(x.MaxTexelGatherOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxTexelGatherOffset_allocs)

	var cminInterpolationOffset_allocs *cgoAllocMap
	ref7926795a.minInterpolationOffset, cminInterpolationOffset_allocs = (C.float)(x.MinInterpolationOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cminInterpolationOffset_allocs)

	var cmaxInterpolationOffset_allocs *cgoAllocMap
	ref7926795a.maxInterpolationOffset, cmaxInterpolationOffset_allocs = (C.float)(x.MaxInterpolationOffset), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxInterpolationOffset_allocs)

	var csubPixelInterpolationOffsetBits_allocs *cgoAllocMap
	ref7926795a.subPixelInterpolationOffsetBits, csubPixelInterpolationOffsetBits_allocs = (C.uint32_t)(x.SubPixelInterpolationOffsetBits), cgoAllocsUnknown
	allocs7926795a.Borrow(csubPixelInterpolationOffsetBits_allocs)

	var cmaxFramebufferWidth_allocs *cgoAllocMap
	ref7926795a.maxFramebufferWidth, cmaxFramebufferWidth_allocs = (C.uint32_t)(x.MaxFramebufferWidth), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFramebufferWidth_allocs)

	var cmaxFramebufferHeight_allocs *cgoAllocMap
	ref7926795a.maxFramebufferHeight, cmaxFramebufferHeight_allocs = (C.uint32_t)(x.MaxFramebufferHeight), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFramebufferHeight_allocs)

	var cmaxFramebufferLayers_allocs *cgoAllocMap
	ref7926795a.maxFramebufferLayers, cmaxFramebufferLayers_allocs = (C.uint32_t)(x.MaxFramebufferLayers), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxFramebufferLayers_allocs)

	var cframebufferColorSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferColorSampleCounts, cframebufferColorSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferColorSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferColorSampleCounts_allocs)

	var cframebufferDepthSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferDepthSampleCounts, cframebufferDepthSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferDepthSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferDepthSampleCounts_allocs)

	var cframebufferStencilSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferStencilSampleCounts, cframebufferStencilSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferStencilSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferStencilSampleCounts_allocs)

	var cframebufferNoAttachmentsSampleCounts_allocs *cgoAllocMap
	ref7926795a.framebufferNoAttachmentsSampleCounts, cframebufferNoAttachmentsSampleCounts_allocs = (C.VkSampleCountFlags)(x.FramebufferNoAttachmentsSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cframebufferNoAttachmentsSampleCounts_allocs)

	var cmaxColorAttachments_allocs *cgoAllocMap
	ref7926795a.maxColorAttachments, cmaxColorAttachments_allocs = (C.uint32_t)(x.MaxColorAttachments), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxColorAttachments_allocs)

	var csampledImageColorSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageColorSampleCounts, csampledImageColorSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageColorSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageColorSampleCounts_allocs)

	var csampledImageIntegerSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageIntegerSampleCounts, csampledImageIntegerSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageIntegerSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageIntegerSampleCounts_allocs)

	var csampledImageDepthSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageDepthSampleCounts, csampledImageDepthSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageDepthSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageDepthSampleCounts_allocs)

	var csampledImageStencilSampleCounts_allocs *cgoAllocMap
	ref7926795a.sampledImageStencilSampleCounts, csampledImageStencilSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampledImageStencilSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(csampledImageStencilSampleCounts_allocs)

	var cstorageImageSampleCounts_allocs *cgoAllocMap
	ref7926795a.storageImageSampleCounts, cstorageImageSampleCounts_allocs = (C.VkSampleCountFlags)(x.StorageImageSampleCounts), cgoAllocsUnknown
	allocs7926795a.Borrow(cstorageImageSampleCounts_allocs)

	var cmaxSampleMaskWords_allocs *cgoAllocMap
	ref7926795a.maxSampleMaskWords, cmaxSampleMaskWords_allocs = (C.uint32_t)(x.MaxSampleMaskWords), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxSampleMaskWords_allocs)

	var ctimestampComputeAndGraphics_allocs *cgoAllocMap
	ref7926795a.timestampComputeAndGraphics, ctimestampComputeAndGraphics_allocs = (C.VkBool32)(x.TimestampComputeAndGraphics), cgoAllocsUnknown
	allocs7926795a.Borrow(ctimestampComputeAndGraphics_allocs)

	var ctimestampPeriod_allocs *cgoAllocMap
	ref7926795a.timestampPeriod, ctimestampPeriod_allocs = (C.float)(x.TimestampPeriod), cgoAllocsUnknown
	allocs7926795a.Borrow(ctimestampPeriod_allocs)

	var cmaxClipDistances_allocs *cgoAllocMap
	ref7926795a.maxClipDistances, cmaxClipDistances_allocs = (C.uint32_t)(x.MaxClipDistances), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxClipDistances_allocs)

	var cmaxCullDistances_allocs *cgoAllocMap
	ref7926795a.maxCullDistances, cmaxCullDistances_allocs = (C.uint32_t)(x.MaxCullDistances), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxCullDistances_allocs)

	var cmaxCombinedClipAndCullDistances_allocs *cgoAllocMap
	ref7926795a.maxCombinedClipAndCullDistances, cmaxCombinedClipAndCullDistances_allocs = (C.uint32_t)(x.MaxCombinedClipAndCullDistances), cgoAllocsUnknown
	allocs7926795a.Borrow(cmaxCombinedClipAndCullDistances_allocs)

	var cdiscreteQueuePriorities_allocs *cgoAllocMap
	ref7926795a.discreteQueuePriorities, cdiscreteQueuePriorities_allocs = (C.uint32_t)(x.DiscreteQueuePriorities), cgoAllocsUnknown
	allocs7926795a.Borrow(cdiscreteQueuePriorities_allocs)

	var cpointSizeRange_allocs *cgoAllocMap
	ref7926795a.pointSizeRange, cpointSizeRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.PointSizeRange)), cgoAllocsUnknown
	allocs7926795a.Borrow(cpointSizeRange_allocs)

	var clineWidthRange_allocs *cgoAllocMap
	ref7926795a.lineWidthRange, clineWidthRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.LineWidthRange)), cgoAllocsUnknown
	allocs7926795a.Borrow(clineWidthRange_allocs)

	var cpointSizeGranularity_allocs *cgoAllocMap
	ref7926795a.pointSizeGranularity, cpointSizeGranularity_allocs = (C.float)(x.PointSizeGranularity), cgoAllocsUnknown
	allocs7926795a.Borrow(cpointSizeGranularity_allocs)

	var clineWidthGranularity_allocs *cgoAllocMap
	ref7926795a.lineWidthGranularity, clineWidthGranularity_allocs = (C.float)(x.LineWidthGranularity), cgoAllocsUnknown
	allocs7926795a.Borrow(clineWidthGranularity_allocs)

	var cstrictLines_allocs *cgoAllocMap
	ref7926795a.strictLines, cstrictLines_allocs = (C.VkBool32)(x.StrictLines), cgoAllocsUnknown
	allocs7926795a.Borrow(cstrictLines_allocs)

	var cstandardSampleLocations_allocs *cgoAllocMap
	ref7926795a.standardSampleLocations, cstandardSampleLocations_allocs = (C.VkBool32)(x.StandardSampleLocations), cgoAllocsUnknown
	allocs7926795a.Borrow(cstandardSampleLocations_allocs)

	var coptimalBufferCopyOffsetAlignment_allocs *cgoAllocMap
	ref7926795a.optimalBufferCopyOffsetAlignment, coptimalBufferCopyOffsetAlignment_allocs = (C.VkDeviceSize)(x.OptimalBufferCopyOffsetAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(coptimalBufferCopyOffsetAlignment_allocs)

	var coptimalBufferCopyRowPitchAlignment_allocs *cgoAllocMap
	ref7926795a.optimalBufferCopyRowPitchAlignment, coptimalBufferCopyRowPitchAlignment_allocs = (C.VkDeviceSize)(x.OptimalBufferCopyRowPitchAlignment), cgoAllocsUnknown
	allocs7926795a.Borrow(coptimalBufferCopyRowPitchAlignment_allocs)

	var cnonCoherentAtomSize_allocs *cgoAllocMap
	ref7926795a.nonCoherentAtomSize, cnonCoherentAtomSize_allocs = (C.VkDeviceSize)(x.NonCoherentAtomSize), cgoAllocsUnknown
	allocs7926795a.Borrow(cnonCoherentAtomSize_allocs)

	x.ref7926795a = ref7926795a
	x.allocs7926795a = allocs7926795a
	return ref7926795a, allocs7926795a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceLimits) PassValue() (C.VkPhysicalDeviceLimits, *cgoAllocMap) {
	if x.ref7926795a != nil {
		return *x.ref7926795a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceLimits) Deref() {
	if x.ref7926795a == nil {
		return
	}
	x.MaxImageDimension1D = (uint32)(x.ref7926795a.maxImageDimension1D)
	x.MaxImageDimension2D = (uint32)(x.ref7926795a.maxImageDimension2D)
	x.MaxImageDimension3D = (uint32)(x.ref7926795a.maxImageDimension3D)
	x.MaxImageDimensionCube = (uint32)(x.ref7926795a.maxImageDimensionCube)
	x.MaxImageArrayLayers = (uint32)(x.ref7926795a.maxImageArrayLayers)
	x.MaxTexelBufferElements = (uint32)(x.ref7926795a.maxTexelBufferElements)
	x.MaxUniformBufferRange = (uint32)(x.ref7926795a.maxUniformBufferRange)
	x.MaxStorageBufferRange = (uint32)(x.ref7926795a.maxStorageBufferRange)
	x.MaxPushConstantsSize = (uint32)(x.ref7926795a.maxPushConstantsSize)
	x.MaxMemoryAllocationCount = (uint32)(x.ref7926795a.maxMemoryAllocationCount)
	x.MaxSamplerAllocationCount = (uint32)(x.ref7926795a.maxSamplerAllocationCount)
	x.BufferImageGranularity = (DeviceSize)(x.ref7926795a.bufferImageGranularity)
	x.SparseAddressSpaceSize = (DeviceSize)(x.ref7926795a.sparseAddressSpaceSize)
	x.MaxBoundDescriptorSets = (uint32)(x.ref7926795a.maxBoundDescriptorSets)
	x.MaxPerStageDescriptorSamplers = (uint32)(x.ref7926795a.maxPerStageDescriptorSamplers)
	x.MaxPerStageDescriptorUniformBuffers = (uint32)(x.ref7926795a.maxPerStageDescriptorUniformBuffers)
	x.MaxPerStageDescriptorStorageBuffers = (uint32)(x.ref7926795a.maxPerStageDescriptorStorageBuffers)
	x.MaxPerStageDescriptorSampledImages = (uint32)(x.ref7926795a.maxPerStageDescriptorSampledImages)
	x.MaxPerStageDescriptorStorageImages = (uint32)(x.ref7926795a.maxPerStageDescriptorStorageImages)
	x.MaxPerStageDescriptorInputAttachments = (uint32)(x.ref7926795a.maxPerStageDescriptorInputAttachments)
	x.MaxPerStageResources = (uint32)(x.ref7926795a.maxPerStageResources)
	x.MaxDescriptorSetSamplers = (uint32)(x.ref7926795a.maxDescriptorSetSamplers)
	x.MaxDescriptorSetUniformBuffers = (uint32)(x.ref7926795a.maxDescriptorSetUniformBuffers)
	x.MaxDescriptorSetUniformBuffersDynamic = (uint32)(x.ref7926795a.maxDescriptorSetUniformBuffersDynamic)
	x.MaxDescriptorSetStorageBuffers = (uint32)(x.ref7926795a.maxDescriptorSetStorageBuffers)
	x.MaxDescriptorSetStorageBuffersDynamic = (uint32)(x.ref7926795a.maxDescriptorSetStorageBuffersDynamic)
	x.MaxDescriptorSetSampledImages = (uint32)(x.ref7926795a.maxDescriptorSetSampledImages)
	x.MaxDescriptorSetStorageImages = (uint32)(x.ref7926795a.maxDescriptorSetStorageImages)
	x.MaxDescriptorSetInputAttachments = (uint32)(x.ref7926795a.maxDescriptorSetInputAttachments)
	x.MaxVertexInputAttributes = (uint32)(x.ref7926795a.maxVertexInputAttributes)
	x.MaxVertexInputBindings = (uint32)(x.ref7926795a.maxVertexInputBindings)
	x.MaxVertexInputAttributeOffset = (uint32)(x.ref7926795a.maxVertexInputAttributeOffset)
	x.MaxVertexInputBindingStride = (uint32)(x.ref7926795a.maxVertexInputBindingStride)
	x.MaxVertexOutputComponents = (uint32)(x.ref7926795a.maxVertexOutputComponents)
	x.MaxTessellationGenerationLevel = (uint32)(x.ref7926795a.maxTessellationGenerationLevel)
	x.MaxTessellationPatchSize = (uint32)(x.ref7926795a.maxTessellationPatchSize)
	x.MaxTessellationControlPerVertexInputComponents = (uint32)(x.ref7926795a.maxTessellationControlPerVertexInputComponents)
	x.MaxTessellationControlPerVertexOutputComponents = (uint32)(x.ref7926795a.maxTessellationControlPerVertexOutputComponents)
	x.MaxTessellationControlPerPatchOutputComponents = (uint32)(x.ref7926795a.maxTessellationControlPerPatchOutputComponents)
	x.MaxTessellationControlTotalOutputComponents = (uint32)(x.ref7926795a.maxTessellationControlTotalOutputComponents)
	x.MaxTessellationEvaluationInputComponents = (uint32)(x.ref7926795a.maxTessellationEvaluationInputComponents)
	x.MaxTessellationEvaluationOutputComponents = (uint32)(x.ref7926795a.maxTessellationEvaluationOutputComponents)
	x.MaxGeometryShaderInvocations = (uint32)(x.ref7926795a.maxGeometryShaderInvocations)
	x.MaxGeometryInputComponents = (uint32)(x.ref7926795a.maxGeometryInputComponents)
	x.MaxGeometryOutputComponents = (uint32)(x.ref7926795a.maxGeometryOutputComponents)
	x.MaxGeometryOutputVertices = (uint32)(x.ref7926795a.maxGeometryOutputVertices)
	x.MaxGeometryTotalOutputComponents = (uint32)(x.ref7926795a.maxGeometryTotalOutputComponents)
	x.MaxFragmentInputComponents = (uint32)(x.ref7926795a.maxFragmentInputComponents)
	x.MaxFragmentOutputAttachments = (uint32)(x.ref7926795a.maxFragmentOutputAttachments)
	x.MaxFragmentDualSrcAttachments = (uint32)(x.ref7926795a.maxFragmentDualSrcAttachments)
	x.MaxFragmentCombinedOutputResources = (uint32)(x.ref7926795a.maxFragmentCombinedOutputResources)
	x.MaxComputeSharedMemorySize = (uint32)(x.ref7926795a.maxComputeSharedMemorySize)
	x.MaxComputeWorkGroupCount = *(*[3]uint32)(unsafe.Pointer(&x.ref7926795a.maxComputeWorkGroupCount))
	x.MaxComputeWorkGroupInvocations = (uint32)(x.ref7926795a.maxComputeWorkGroupInvocations)
	x.MaxComputeWorkGroupSize = *(*[3]uint32)(unsafe.Pointer(&x.ref7926795a.maxComputeWorkGroupSize))
	x.SubPixelPrecisionBits = (uint32)(x.ref7926795a.subPixelPrecisionBits)
	x.SubTexelPrecisionBits = (uint32)(x.ref7926795a.subTexelPrecisionBits)
	x.MipmapPrecisionBits = (uint32)(x.ref7926795a.mipmapPrecisionBits)
	x.MaxDrawIndexedIndexValue = (uint32)(x.ref7926795a.maxDrawIndexedIndexValue)
	x.MaxDrawIndirectCount = (uint32)(x.ref7926795a.maxDrawIndirectCount)
	x.MaxSamplerLodBias = (float32)(x.ref7926795a.maxSamplerLodBias)
	x.MaxSamplerAnisotropy = (float32)(x.ref7926795a.maxSamplerAnisotropy)
	x.MaxViewports = (uint32)(x.ref7926795a.maxViewports)
	x.MaxViewportDimensions = *(*[2]uint32)(unsafe.Pointer(&x.ref7926795a.maxViewportDimensions))
	x.ViewportBoundsRange = *(*[2]float32)(unsafe.Pointer(&x.ref7926795a.viewportBoundsRange))
	x.ViewportSubPixelBits = (uint32)(x.ref7926795a.viewportSubPixelBits)
	x.MinMemoryMapAlignment = (uint64)(x.ref7926795a.minMemoryMapAlignment)
	x.MinTexelBufferOffsetAlignment = (DeviceSize)(x.ref7926795a.minTexelBufferOffsetAlignment)
	x.MinUniformBufferOffsetAlignment = (DeviceSize)(x.ref7926795a.minUniformBufferOffsetAlignment)
	x.MinStorageBufferOffsetAlignment = (DeviceSize)(x.ref7926795a.minStorageBufferOffsetAlignment)
	x.MinTexelOffset = (int32)(x.ref7926795a.minTexelOffset)
	x.MaxTexelOffset = (uint32)(x.ref7926795a.maxTexelOffset)
	x.MinTexelGatherOffset = (int32)(x.ref7926795a.minTexelGatherOffset)
	x.MaxTexelGatherOffset = (uint32)(x.ref7926795a.maxTexelGatherOffset)
	x.MinInterpolationOffset = (float32)(x.ref7926795a.minInterpolationOffset)
	x.MaxInterpolationOffset = (float32)(x.ref7926795a.maxInterpolationOffset)
	x.SubPixelInterpolationOffsetBits = (uint32)(x.ref7926795a.subPixelInterpolationOffsetBits)
	x.MaxFramebufferWidth = (uint32)(x.ref7926795a.maxFramebufferWidth)
	x.MaxFramebufferHeight = (uint32)(x.ref7926795a.maxFramebufferHeight)
	x.MaxFramebufferLayers = (uint32)(x.ref7926795a.maxFramebufferLayers)
	x.FramebufferColorSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferColorSampleCounts)
	x.FramebufferDepthSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferDepthSampleCounts)
	x.FramebufferStencilSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferStencilSampleCounts)
	x.FramebufferNoAttachmentsSampleCounts = (SampleCountFlags)(x.ref7926795a.framebufferNoAttachmentsSampleCounts)
	x.MaxColorAttachments = (uint32)(x.ref7926795a.maxColorAttachments)
	x.SampledImageColorSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageColorSampleCounts)
	x.SampledImageIntegerSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageIntegerSampleCounts)
	x.SampledImageDepthSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageDepthSampleCounts)
	x.SampledImageStencilSampleCounts = (SampleCountFlags)(x.ref7926795a.sampledImageStencilSampleCounts)
	x.StorageImageSampleCounts = (SampleCountFlags)(x.ref7926795a.storageImageSampleCounts)
	x.MaxSampleMaskWords = (uint32)(x.ref7926795a.maxSampleMaskWords)
	x.TimestampComputeAndGraphics = (Bool32)(x.ref7926795a.timestampComputeAndGraphics)
	x.TimestampPeriod = (float32)(x.ref7926795a.timestampPeriod)
	x.MaxClipDistances = (uint32)(x.ref7926795a.maxClipDistances)
	x.MaxCullDistances = (uint32)(x.ref7926795a.maxCullDistances)
	x.MaxCombinedClipAndCullDistances = (uint32)(x.ref7926795a.maxCombinedClipAndCullDistances)
	x.DiscreteQueuePriorities = (uint32)(x.ref7926795a.discreteQueuePriorities)
	x.PointSizeRange = *(*[2]float32)(unsafe.Pointer(&x.ref7926795a.pointSizeRange))
	x.LineWidthRange = *(*[2]float32)(unsafe.Pointer(&x.ref7926795a.lineWidthRange))
	x.PointSizeGranularity = (float32)(x.ref7926795a.pointSizeGranularity)
	x.LineWidthGranularity = (float32)(x.ref7926795a.lineWidthGranularity)
	x.StrictLines = (Bool32)(x.ref7926795a.strictLines)
	x.StandardSampleLocations = (Bool32)(x.ref7926795a.standardSampleLocations)
	x.OptimalBufferCopyOffsetAlignment = (DeviceSize)(x.ref7926795a.optimalBufferCopyOffsetAlignment)
	x.OptimalBufferCopyRowPitchAlignment = (DeviceSize)(x.ref7926795a.optimalBufferCopyRowPitchAlignment)
	x.NonCoherentAtomSize = (DeviceSize)(x.ref7926795a.nonCoherentAtomSize)
}

// allocPhysicalDeviceSparsePropertiesMemory allocates memory for type C.VkPhysicalDeviceSparseProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSparsePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSparsePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceSparsePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSparseProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSparseProperties) Ref() *C.VkPhysicalDeviceSparseProperties {
	if x == nil {
		return nil
	}
	return x.ref6d7c11e6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSparseProperties) Free() {
	if x != nil && x.allocs6d7c11e6 != nil {
		x.allocs6d7c11e6.(*cgoAllocMap).Free()
		x.ref6d7c11e6 = nil
	}
}

// NewPhysicalDeviceSparsePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSparsePropertiesRef(ref unsafe.Pointer) *PhysicalDeviceSparseProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSparseProperties)
	obj.ref6d7c11e6 = (*C.VkPhysicalDeviceSparseProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSparseProperties) PassRef() (*C.VkPhysicalDeviceSparseProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6d7c11e6 != nil {
		return x.ref6d7c11e6, nil
	}
	mem6d7c11e6 := allocPhysicalDeviceSparsePropertiesMemory(1)
	ref6d7c11e6 := (*C.VkPhysicalDeviceSparseProperties)(mem6d7c11e6)
	allocs6d7c11e6 := new(cgoAllocMap)
	allocs6d7c11e6.Add(mem6d7c11e6)

	var cresidencyStandard2DBlockShape_allocs *cgoAllocMap
	ref6d7c11e6.residencyStandard2DBlockShape, cresidencyStandard2DBlockShape_allocs = (C.VkBool32)(x.ResidencyStandard2DBlockShape), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyStandard2DBlockShape_allocs)

	var cresidencyStandard2DMultisampleBlockShape_allocs *cgoAllocMap
	ref6d7c11e6.residencyStandard2DMultisampleBlockShape, cresidencyStandard2DMultisampleBlockShape_allocs = (C.VkBool32)(x.ResidencyStandard2DMultisampleBlockShape), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyStandard2DMultisampleBlockShape_allocs)

	var cresidencyStandard3DBlockShape_allocs *cgoAllocMap
	ref6d7c11e6.residencyStandard3DBlockShape, cresidencyStandard3DBlockShape_allocs = (C.VkBool32)(x.ResidencyStandard3DBlockShape), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyStandard3DBlockShape_allocs)

	var cresidencyAlignedMipSize_allocs *cgoAllocMap
	ref6d7c11e6.residencyAlignedMipSize, cresidencyAlignedMipSize_allocs = (C.VkBool32)(x.ResidencyAlignedMipSize), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyAlignedMipSize_allocs)

	var cresidencyNonResidentStrict_allocs *cgoAllocMap
	ref6d7c11e6.residencyNonResidentStrict, cresidencyNonResidentStrict_allocs = (C.VkBool32)(x.ResidencyNonResidentStrict), cgoAllocsUnknown
	allocs6d7c11e6.Borrow(cresidencyNonResidentStrict_allocs)

	x.ref6d7c11e6 = ref6d7c11e6
	x.allocs6d7c11e6 = allocs6d7c11e6
	return ref6d7c11e6, allocs6d7c11e6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSparseProperties) PassValue() (C.VkPhysicalDeviceSparseProperties, *cgoAllocMap) {
	if x.ref6d7c11e6 != nil {
		return *x.ref6d7c11e6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSparseProperties) Deref() {
	if x.ref6d7c11e6 == nil {
		return
	}
	x.ResidencyStandard2DBlockShape = (Bool32)(x.ref6d7c11e6.residencyStandard2DBlockShape)
	x.ResidencyStandard2DMultisampleBlockShape = (Bool32)(x.ref6d7c11e6.residencyStandard2DMultisampleBlockShape)
	x.ResidencyStandard3DBlockShape = (Bool32)(x.ref6d7c11e6.residencyStandard3DBlockShape)
	x.ResidencyAlignedMipSize = (Bool32)(x.ref6d7c11e6.residencyAlignedMipSize)
	x.ResidencyNonResidentStrict = (Bool32)(x.ref6d7c11e6.residencyNonResidentStrict)
}

// allocPhysicalDevicePropertiesMemory allocates memory for type C.VkPhysicalDeviceProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDevicePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceProperties) Ref() *C.VkPhysicalDeviceProperties {
	if x == nil {
		return nil
	}
	return x.ref1080ca9d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceProperties) Free() {
	if x != nil && x.allocs1080ca9d != nil {
		x.allocs1080ca9d.(*cgoAllocMap).Free()
		x.ref1080ca9d = nil
	}
}

// NewPhysicalDevicePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePropertiesRef(ref unsafe.Pointer) *PhysicalDeviceProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProperties)
	obj.ref1080ca9d = (*C.VkPhysicalDeviceProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceProperties) PassRef() (*C.VkPhysicalDeviceProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1080ca9d != nil {
		return x.ref1080ca9d, nil
	}
	mem1080ca9d := allocPhysicalDevicePropertiesMemory(1)
	ref1080ca9d := (*C.VkPhysicalDeviceProperties)(mem1080ca9d)
	allocs1080ca9d := new(cgoAllocMap)
	allocs1080ca9d.Add(mem1080ca9d)

	var capiVersion_allocs *cgoAllocMap
	ref1080ca9d.apiVersion, capiVersion_allocs = (C.uint32_t)(x.ApiVersion), cgoAllocsUnknown
	allocs1080ca9d.Borrow(capiVersion_allocs)

	var cdriverVersion_allocs *cgoAllocMap
	ref1080ca9d.driverVersion, cdriverVersion_allocs = (C.uint32_t)(x.DriverVersion), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdriverVersion_allocs)

	var cvendorID_allocs *cgoAllocMap
	ref1080ca9d.vendorID, cvendorID_allocs = (C.uint32_t)(x.VendorID), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cvendorID_allocs)

	var cdeviceID_allocs *cgoAllocMap
	ref1080ca9d.deviceID, cdeviceID_allocs = (C.uint32_t)(x.DeviceID), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdeviceID_allocs)

	var cdeviceType_allocs *cgoAllocMap
	ref1080ca9d.deviceType, cdeviceType_allocs = (C.VkPhysicalDeviceType)(x.DeviceType), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdeviceType_allocs)

	var cdeviceName_allocs *cgoAllocMap
	ref1080ca9d.deviceName, cdeviceName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.DeviceName)), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cdeviceName_allocs)

	var cpipelineCacheUUID_allocs *cgoAllocMap
	ref1080ca9d.pipelineCacheUUID, cpipelineCacheUUID_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.PipelineCacheUUID)), cgoAllocsUnknown
	allocs1080ca9d.Borrow(cpipelineCacheUUID_allocs)

	var climits_allocs *cgoAllocMap
	ref1080ca9d.limits, climits_allocs = x.Limits.PassValue()
	allocs1080ca9d.Borrow(climits_allocs)

	var csparseProperties_allocs *cgoAllocMap
	ref1080ca9d.sparseProperties, csparseProperties_allocs = x.SparseProperties.PassValue()
	allocs1080ca9d.Borrow(csparseProperties_allocs)

	x.ref1080ca9d = ref1080ca9d
	x.allocs1080ca9d = allocs1080ca9d
	return ref1080ca9d, allocs1080ca9d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceProperties) PassValue() (C.VkPhysicalDeviceProperties, *cgoAllocMap) {
	if x.ref1080ca9d != nil {
		return *x.ref1080ca9d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceProperties) Deref() {
	if x.ref1080ca9d == nil {
		return
	}
	x.ApiVersion = (uint32)(x.ref1080ca9d.apiVersion)
	x.DriverVersion = (uint32)(x.ref1080ca9d.driverVersion)
	x.VendorID = (uint32)(x.ref1080ca9d.vendorID)
	x.DeviceID = (uint32)(x.ref1080ca9d.deviceID)
	x.DeviceType = (PhysicalDeviceType)(x.ref1080ca9d.deviceType)
	x.DeviceName = *(*[256]byte)(unsafe.Pointer(&x.ref1080ca9d.deviceName))
	x.PipelineCacheUUID = *(*[16]byte)(unsafe.Pointer(&x.ref1080ca9d.pipelineCacheUUID))
	x.Limits = *NewPhysicalDeviceLimitsRef(unsafe.Pointer(&x.ref1080ca9d.limits))
	x.SparseProperties = *NewPhysicalDeviceSparsePropertiesRef(unsafe.Pointer(&x.ref1080ca9d.sparseProperties))
}

// allocQueueFamilyPropertiesMemory allocates memory for type C.VkQueueFamilyProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueueFamilyPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueueFamilyPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfQueueFamilyPropertiesValue = unsafe.Sizeof([1]C.VkQueueFamilyProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueueFamilyProperties) Ref() *C.VkQueueFamilyProperties {
	if x == nil {
		return nil
	}
	return x.refd538c446
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueueFamilyProperties) Free() {
	if x != nil && x.allocsd538c446 != nil {
		x.allocsd538c446.(*cgoAllocMap).Free()
		x.refd538c446 = nil
	}
}

// NewQueueFamilyPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueueFamilyPropertiesRef(ref unsafe.Pointer) *QueueFamilyProperties {
	if ref == nil {
		return nil
	}
	obj := new(QueueFamilyProperties)
	obj.refd538c446 = (*C.VkQueueFamilyProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueueFamilyProperties) PassRef() (*C.VkQueueFamilyProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd538c446 != nil {
		return x.refd538c446, nil
	}
	memd538c446 := allocQueueFamilyPropertiesMemory(1)
	refd538c446 := (*C.VkQueueFamilyProperties)(memd538c446)
	allocsd538c446 := new(cgoAllocMap)
	allocsd538c446.Add(memd538c446)

	var cqueueFlags_allocs *cgoAllocMap
	refd538c446.queueFlags, cqueueFlags_allocs = (C.VkQueueFlags)(x.QueueFlags), cgoAllocsUnknown
	allocsd538c446.Borrow(cqueueFlags_allocs)

	var cqueueCount_allocs *cgoAllocMap
	refd538c446.queueCount, cqueueCount_allocs = (C.uint32_t)(x.QueueCount), cgoAllocsUnknown
	allocsd538c446.Borrow(cqueueCount_allocs)

	var ctimestampValidBits_allocs *cgoAllocMap
	refd538c446.timestampValidBits, ctimestampValidBits_allocs = (C.uint32_t)(x.TimestampValidBits), cgoAllocsUnknown
	allocsd538c446.Borrow(ctimestampValidBits_allocs)

	var cminImageTransferGranularity_allocs *cgoAllocMap
	refd538c446.minImageTransferGranularity, cminImageTransferGranularity_allocs = x.MinImageTransferGranularity.PassValue()
	allocsd538c446.Borrow(cminImageTransferGranularity_allocs)

	x.refd538c446 = refd538c446
	x.allocsd538c446 = allocsd538c446
	return refd538c446, allocsd538c446

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueueFamilyProperties) PassValue() (C.VkQueueFamilyProperties, *cgoAllocMap) {
	if x.refd538c446 != nil {
		return *x.refd538c446, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueueFamilyProperties) Deref() {
	if x.refd538c446 == nil {
		return
	}
	x.QueueFlags = (QueueFlags)(x.refd538c446.queueFlags)
	x.QueueCount = (uint32)(x.refd538c446.queueCount)
	x.TimestampValidBits = (uint32)(x.refd538c446.timestampValidBits)
	x.MinImageTransferGranularity = *NewExtent3DRef(unsafe.Pointer(&x.refd538c446.minImageTransferGranularity))
}

// allocMemoryTypeMemory allocates memory for type C.VkMemoryType in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryTypeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryTypeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryTypeValue = unsafe.Sizeof([1]C.VkMemoryType{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryType) Ref() *C.VkMemoryType {
	if x == nil {
		return nil
	}
	return x.ref2f46e01d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryType) Free() {
	if x != nil && x.allocs2f46e01d != nil {
		x.allocs2f46e01d.(*cgoAllocMap).Free()
		x.ref2f46e01d = nil
	}
}

// NewMemoryTypeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryTypeRef(ref unsafe.Pointer) *MemoryType {
	if ref == nil {
		return nil
	}
	obj := new(MemoryType)
	obj.ref2f46e01d = (*C.VkMemoryType)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryType) PassRef() (*C.VkMemoryType, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f46e01d != nil {
		return x.ref2f46e01d, nil
	}
	mem2f46e01d := allocMemoryTypeMemory(1)
	ref2f46e01d := (*C.VkMemoryType)(mem2f46e01d)
	allocs2f46e01d := new(cgoAllocMap)
	allocs2f46e01d.Add(mem2f46e01d)

	var cpropertyFlags_allocs *cgoAllocMap
	ref2f46e01d.propertyFlags, cpropertyFlags_allocs = (C.VkMemoryPropertyFlags)(x.PropertyFlags), cgoAllocsUnknown
	allocs2f46e01d.Borrow(cpropertyFlags_allocs)

	var cheapIndex_allocs *cgoAllocMap
	ref2f46e01d.heapIndex, cheapIndex_allocs = (C.uint32_t)(x.HeapIndex), cgoAllocsUnknown
	allocs2f46e01d.Borrow(cheapIndex_allocs)

	x.ref2f46e01d = ref2f46e01d
	x.allocs2f46e01d = allocs2f46e01d
	return ref2f46e01d, allocs2f46e01d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryType) PassValue() (C.VkMemoryType, *cgoAllocMap) {
	if x.ref2f46e01d != nil {
		return *x.ref2f46e01d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryType) Deref() {
	if x.ref2f46e01d == nil {
		return
	}
	x.PropertyFlags = (MemoryPropertyFlags)(x.ref2f46e01d.propertyFlags)
	x.HeapIndex = (uint32)(x.ref2f46e01d.heapIndex)
}

// allocMemoryHeapMemory allocates memory for type C.VkMemoryHeap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryHeapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryHeapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryHeapValue = unsafe.Sizeof([1]C.VkMemoryHeap{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryHeap) Ref() *C.VkMemoryHeap {
	if x == nil {
		return nil
	}
	return x.ref1eb195d5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryHeap) Free() {
	if x != nil && x.allocs1eb195d5 != nil {
		x.allocs1eb195d5.(*cgoAllocMap).Free()
		x.ref1eb195d5 = nil
	}
}

// NewMemoryHeapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryHeapRef(ref unsafe.Pointer) *MemoryHeap {
	if ref == nil {
		return nil
	}
	obj := new(MemoryHeap)
	obj.ref1eb195d5 = (*C.VkMemoryHeap)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryHeap) PassRef() (*C.VkMemoryHeap, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1eb195d5 != nil {
		return x.ref1eb195d5, nil
	}
	mem1eb195d5 := allocMemoryHeapMemory(1)
	ref1eb195d5 := (*C.VkMemoryHeap)(mem1eb195d5)
	allocs1eb195d5 := new(cgoAllocMap)
	allocs1eb195d5.Add(mem1eb195d5)

	var csize_allocs *cgoAllocMap
	ref1eb195d5.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs1eb195d5.Borrow(csize_allocs)

	var cflags_allocs *cgoAllocMap
	ref1eb195d5.flags, cflags_allocs = (C.VkMemoryHeapFlags)(x.Flags), cgoAllocsUnknown
	allocs1eb195d5.Borrow(cflags_allocs)

	x.ref1eb195d5 = ref1eb195d5
	x.allocs1eb195d5 = allocs1eb195d5
	return ref1eb195d5, allocs1eb195d5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryHeap) PassValue() (C.VkMemoryHeap, *cgoAllocMap) {
	if x.ref1eb195d5 != nil {
		return *x.ref1eb195d5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryHeap) Deref() {
	if x.ref1eb195d5 == nil {
		return
	}
	x.Size = (DeviceSize)(x.ref1eb195d5.size)
	x.Flags = (MemoryHeapFlags)(x.ref1eb195d5.flags)
}

// allocPhysicalDeviceMemoryPropertiesMemory allocates memory for type C.VkPhysicalDeviceMemoryProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMemoryPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMemoryPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceMemoryPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMemoryProperties{})

// allocA32MemoryTypeMemory allocates memory for type [32]C.VkMemoryType in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA32MemoryTypeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA32MemoryTypeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA32MemoryTypeValue = unsafe.Sizeof([1][32]C.VkMemoryType{})

// unpackA32MemoryType transforms a sliced Go data structure into plain C format.
func unpackA32MemoryType(x [32]MemoryType) (unpacked [32]C.VkMemoryType, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[32]C.VkMemoryType) {
		go allocs.Free()
	})

	mem0 := allocA32MemoryTypeMemory(1)
	allocs.Add(mem0)
	v0 := (*[32]C.VkMemoryType)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[32]C.VkMemoryType)(mem0)
	return
}

// allocA16MemoryHeapMemory allocates memory for type [16]C.VkMemoryHeap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA16MemoryHeapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA16MemoryHeapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA16MemoryHeapValue = unsafe.Sizeof([1][16]C.VkMemoryHeap{})

// unpackA16MemoryHeap transforms a sliced Go data structure into plain C format.
func unpackA16MemoryHeap(x [16]MemoryHeap) (unpacked [16]C.VkMemoryHeap, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[16]C.VkMemoryHeap) {
		go allocs.Free()
	})

	mem0 := allocA16MemoryHeapMemory(1)
	allocs.Add(mem0)
	v0 := (*[16]C.VkMemoryHeap)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[16]C.VkMemoryHeap)(mem0)
	return
}

// packA32MemoryType reads sliced Go data structure out from plain C format.
func packA32MemoryType(v *[32]MemoryType, ptr0 *[32]C.VkMemoryType) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewMemoryTypeRef(unsafe.Pointer(&ptr1))
	}
}

// packA16MemoryHeap reads sliced Go data structure out from plain C format.
func packA16MemoryHeap(v *[16]MemoryHeap, ptr0 *[16]C.VkMemoryHeap) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewMemoryHeapRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMemoryProperties) Ref() *C.VkPhysicalDeviceMemoryProperties {
	if x == nil {
		return nil
	}
	return x.ref3aabb5fd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMemoryProperties) Free() {
	if x != nil && x.allocs3aabb5fd != nil {
		x.allocs3aabb5fd.(*cgoAllocMap).Free()
		x.ref3aabb5fd = nil
	}
}

// NewPhysicalDeviceMemoryPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMemoryPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceMemoryProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMemoryProperties)
	obj.ref3aabb5fd = (*C.VkPhysicalDeviceMemoryProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMemoryProperties) PassRef() (*C.VkPhysicalDeviceMemoryProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3aabb5fd != nil {
		return x.ref3aabb5fd, nil
	}
	mem3aabb5fd := allocPhysicalDeviceMemoryPropertiesMemory(1)
	ref3aabb5fd := (*C.VkPhysicalDeviceMemoryProperties)(mem3aabb5fd)
	allocs3aabb5fd := new(cgoAllocMap)
	allocs3aabb5fd.Add(mem3aabb5fd)

	var cmemoryTypeCount_allocs *cgoAllocMap
	ref3aabb5fd.memoryTypeCount, cmemoryTypeCount_allocs = (C.uint32_t)(x.MemoryTypeCount), cgoAllocsUnknown
	allocs3aabb5fd.Borrow(cmemoryTypeCount_allocs)

	var cmemoryTypes_allocs *cgoAllocMap
	ref3aabb5fd.memoryTypes, cmemoryTypes_allocs = unpackA32MemoryType(x.MemoryTypes)
	allocs3aabb5fd.Borrow(cmemoryTypes_allocs)

	var cmemoryHeapCount_allocs *cgoAllocMap
	ref3aabb5fd.memoryHeapCount, cmemoryHeapCount_allocs = (C.uint32_t)(x.MemoryHeapCount), cgoAllocsUnknown
	allocs3aabb5fd.Borrow(cmemoryHeapCount_allocs)

	var cmemoryHeaps_allocs *cgoAllocMap
	ref3aabb5fd.memoryHeaps, cmemoryHeaps_allocs = unpackA16MemoryHeap(x.MemoryHeaps)
	allocs3aabb5fd.Borrow(cmemoryHeaps_allocs)

	x.ref3aabb5fd = ref3aabb5fd
	x.allocs3aabb5fd = allocs3aabb5fd
	return ref3aabb5fd, allocs3aabb5fd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMemoryProperties) PassValue() (C.VkPhysicalDeviceMemoryProperties, *cgoAllocMap) {
	if x.ref3aabb5fd != nil {
		return *x.ref3aabb5fd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMemoryProperties) Deref() {
	if x.ref3aabb5fd == nil {
		return
	}
	x.MemoryTypeCount = (uint32)(x.ref3aabb5fd.memoryTypeCount)
	packA32MemoryType(&x.MemoryTypes, (*[32]C.VkMemoryType)(unsafe.Pointer(&x.ref3aabb5fd.memoryTypes)))
	x.MemoryHeapCount = (uint32)(x.ref3aabb5fd.memoryHeapCount)
	packA16MemoryHeap(&x.MemoryHeaps, (*[16]C.VkMemoryHeap)(unsafe.Pointer(&x.ref3aabb5fd.memoryHeaps)))
}

// allocDeviceQueueCreateInfoMemory allocates memory for type C.VkDeviceQueueCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceQueueCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceQueueCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceQueueCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceQueueCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceQueueCreateInfo) Ref() *C.VkDeviceQueueCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref6087b30d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceQueueCreateInfo) Free() {
	if x != nil && x.allocs6087b30d != nil {
		x.allocs6087b30d.(*cgoAllocMap).Free()
		x.ref6087b30d = nil
	}
}

// NewDeviceQueueCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceQueueCreateInfoRef(ref unsafe.Pointer) *DeviceQueueCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceQueueCreateInfo)
	obj.ref6087b30d = (*C.VkDeviceQueueCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceQueueCreateInfo) PassRef() (*C.VkDeviceQueueCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6087b30d != nil {
		return x.ref6087b30d, nil
	}
	mem6087b30d := allocDeviceQueueCreateInfoMemory(1)
	ref6087b30d := (*C.VkDeviceQueueCreateInfo)(mem6087b30d)
	allocs6087b30d := new(cgoAllocMap)
	allocs6087b30d.Add(mem6087b30d)

	var csType_allocs *cgoAllocMap
	ref6087b30d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6087b30d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6087b30d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6087b30d.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref6087b30d.flags, cflags_allocs = (C.VkDeviceQueueCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs6087b30d.Borrow(cflags_allocs)

	var cqueueFamilyIndex_allocs *cgoAllocMap
	ref6087b30d.queueFamilyIndex, cqueueFamilyIndex_allocs = (C.uint32_t)(x.QueueFamilyIndex), cgoAllocsUnknown
	allocs6087b30d.Borrow(cqueueFamilyIndex_allocs)

	var cqueueCount_allocs *cgoAllocMap
	ref6087b30d.queueCount, cqueueCount_allocs = (C.uint32_t)(x.QueueCount), cgoAllocsUnknown
	allocs6087b30d.Borrow(cqueueCount_allocs)

	var cpQueuePriorities_allocs *cgoAllocMap
	ref6087b30d.pQueuePriorities, cpQueuePriorities_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PQueuePriorities)).Data)), cgoAllocsUnknown
	allocs6087b30d.Borrow(cpQueuePriorities_allocs)

	x.ref6087b30d = ref6087b30d
	x.allocs6087b30d = allocs6087b30d
	return ref6087b30d, allocs6087b30d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceQueueCreateInfo) PassValue() (C.VkDeviceQueueCreateInfo, *cgoAllocMap) {
	if x.ref6087b30d != nil {
		return *x.ref6087b30d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceQueueCreateInfo) Deref() {
	if x.ref6087b30d == nil {
		return
	}
	x.SType = (StructureType)(x.ref6087b30d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6087b30d.pNext))
	x.Flags = (DeviceQueueCreateFlags)(x.ref6087b30d.flags)
	x.QueueFamilyIndex = (uint32)(x.ref6087b30d.queueFamilyIndex)
	x.QueueCount = (uint32)(x.ref6087b30d.queueCount)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.PQueuePriorities))
	hxfc4425b.Data = unsafe.Pointer(x.ref6087b30d.pQueuePriorities)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

}

// allocDeviceCreateInfoMemory allocates memory for type C.VkDeviceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceCreateInfo{})

// unpackSDeviceQueueCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSDeviceQueueCreateInfo(x []DeviceQueueCreateInfo) (unpacked *C.VkDeviceQueueCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDeviceQueueCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDeviceQueueCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDeviceQueueCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDeviceQueueCreateInfo)(h.Data)
	return
}

// unpackSPhysicalDeviceFeatures transforms a sliced Go data structure into plain C format.
func unpackSPhysicalDeviceFeatures(x []PhysicalDeviceFeatures) (unpacked *C.VkPhysicalDeviceFeatures, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPhysicalDeviceFeatures) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPhysicalDeviceFeaturesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPhysicalDeviceFeatures)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPhysicalDeviceFeatures)(h.Data)
	return
}

// packSDeviceQueueCreateInfo reads sliced Go data structure out from plain C format.
func packSDeviceQueueCreateInfo(v []DeviceQueueCreateInfo, ptr0 *C.VkDeviceQueueCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDeviceQueueCreateInfoValue]C.VkDeviceQueueCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDeviceQueueCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSPhysicalDeviceFeatures reads sliced Go data structure out from plain C format.
func packSPhysicalDeviceFeatures(v []PhysicalDeviceFeatures, ptr0 *C.VkPhysicalDeviceFeatures) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPhysicalDeviceFeaturesValue]C.VkPhysicalDeviceFeatures)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPhysicalDeviceFeaturesRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceCreateInfo) Ref() *C.VkDeviceCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc0d8b997
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceCreateInfo) Free() {
	if x != nil && x.allocsc0d8b997 != nil {
		x.allocsc0d8b997.(*cgoAllocMap).Free()
		x.refc0d8b997 = nil
	}
}

// NewDeviceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceCreateInfoRef(ref unsafe.Pointer) *DeviceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceCreateInfo)
	obj.refc0d8b997 = (*C.VkDeviceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceCreateInfo) PassRef() (*C.VkDeviceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0d8b997 != nil {
		return x.refc0d8b997, nil
	}
	memc0d8b997 := allocDeviceCreateInfoMemory(1)
	refc0d8b997 := (*C.VkDeviceCreateInfo)(memc0d8b997)
	allocsc0d8b997 := new(cgoAllocMap)
	allocsc0d8b997.Add(memc0d8b997)

	var csType_allocs *cgoAllocMap
	refc0d8b997.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc0d8b997.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc0d8b997.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc0d8b997.flags, cflags_allocs = (C.VkDeviceCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cflags_allocs)

	var cqueueCreateInfoCount_allocs *cgoAllocMap
	refc0d8b997.queueCreateInfoCount, cqueueCreateInfoCount_allocs = (C.uint32_t)(x.QueueCreateInfoCount), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cqueueCreateInfoCount_allocs)

	var cpQueueCreateInfos_allocs *cgoAllocMap
	refc0d8b997.pQueueCreateInfos, cpQueueCreateInfos_allocs = unpackSDeviceQueueCreateInfo(x.PQueueCreateInfos)
	allocsc0d8b997.Borrow(cpQueueCreateInfos_allocs)

	var cenabledLayerCount_allocs *cgoAllocMap
	refc0d8b997.enabledLayerCount, cenabledLayerCount_allocs = (C.uint32_t)(x.EnabledLayerCount), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cenabledLayerCount_allocs)

	var cppEnabledLayerNames_allocs *cgoAllocMap
	refc0d8b997.ppEnabledLayerNames, cppEnabledLayerNames_allocs = unpackSString(x.PpEnabledLayerNames)
	allocsc0d8b997.Borrow(cppEnabledLayerNames_allocs)

	var cenabledExtensionCount_allocs *cgoAllocMap
	refc0d8b997.enabledExtensionCount, cenabledExtensionCount_allocs = (C.uint32_t)(x.EnabledExtensionCount), cgoAllocsUnknown
	allocsc0d8b997.Borrow(cenabledExtensionCount_allocs)

	var cppEnabledExtensionNames_allocs *cgoAllocMap
	refc0d8b997.ppEnabledExtensionNames, cppEnabledExtensionNames_allocs = unpackSString(x.PpEnabledExtensionNames)
	allocsc0d8b997.Borrow(cppEnabledExtensionNames_allocs)

	var cpEnabledFeatures_allocs *cgoAllocMap
	refc0d8b997.pEnabledFeatures, cpEnabledFeatures_allocs = unpackSPhysicalDeviceFeatures(x.PEnabledFeatures)
	allocsc0d8b997.Borrow(cpEnabledFeatures_allocs)

	x.refc0d8b997 = refc0d8b997
	x.allocsc0d8b997 = allocsc0d8b997
	return refc0d8b997, allocsc0d8b997

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceCreateInfo) PassValue() (C.VkDeviceCreateInfo, *cgoAllocMap) {
	if x.refc0d8b997 != nil {
		return *x.refc0d8b997, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceCreateInfo) Deref() {
	if x.refc0d8b997 == nil {
		return
	}
	x.SType = (StructureType)(x.refc0d8b997.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc0d8b997.pNext))
	x.Flags = (DeviceCreateFlags)(x.refc0d8b997.flags)
	x.QueueCreateInfoCount = (uint32)(x.refc0d8b997.queueCreateInfoCount)
	packSDeviceQueueCreateInfo(x.PQueueCreateInfos, x.refc0d8b997.pQueueCreateInfos)
	x.EnabledLayerCount = (uint32)(x.refc0d8b997.enabledLayerCount)
	packSString(x.PpEnabledLayerNames, x.refc0d8b997.ppEnabledLayerNames)
	x.EnabledExtensionCount = (uint32)(x.refc0d8b997.enabledExtensionCount)
	packSString(x.PpEnabledExtensionNames, x.refc0d8b997.ppEnabledExtensionNames)
	packSPhysicalDeviceFeatures(x.PEnabledFeatures, x.refc0d8b997.pEnabledFeatures)
}

// allocExtensionPropertiesMemory allocates memory for type C.VkExtensionProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExtensionPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExtensionPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExtensionPropertiesValue = unsafe.Sizeof([1]C.VkExtensionProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExtensionProperties) Ref() *C.VkExtensionProperties {
	if x == nil {
		return nil
	}
	return x.ref2f001956
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExtensionProperties) Free() {
	if x != nil && x.allocs2f001956 != nil {
		x.allocs2f001956.(*cgoAllocMap).Free()
		x.ref2f001956 = nil
	}
}

// NewExtensionPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExtensionPropertiesRef(ref unsafe.Pointer) *ExtensionProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExtensionProperties)
	obj.ref2f001956 = (*C.VkExtensionProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExtensionProperties) PassRef() (*C.VkExtensionProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f001956 != nil {
		return x.ref2f001956, nil
	}
	mem2f001956 := allocExtensionPropertiesMemory(1)
	ref2f001956 := (*C.VkExtensionProperties)(mem2f001956)
	allocs2f001956 := new(cgoAllocMap)
	allocs2f001956.Add(mem2f001956)

	var cextensionName_allocs *cgoAllocMap
	ref2f001956.extensionName, cextensionName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.ExtensionName)), cgoAllocsUnknown
	allocs2f001956.Borrow(cextensionName_allocs)

	var cspecVersion_allocs *cgoAllocMap
	ref2f001956.specVersion, cspecVersion_allocs = (C.uint32_t)(x.SpecVersion), cgoAllocsUnknown
	allocs2f001956.Borrow(cspecVersion_allocs)

	x.ref2f001956 = ref2f001956
	x.allocs2f001956 = allocs2f001956
	return ref2f001956, allocs2f001956

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExtensionProperties) PassValue() (C.VkExtensionProperties, *cgoAllocMap) {
	if x.ref2f001956 != nil {
		return *x.ref2f001956, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExtensionProperties) Deref() {
	if x.ref2f001956 == nil {
		return
	}
	x.ExtensionName = *(*[256]byte)(unsafe.Pointer(&x.ref2f001956.extensionName))
	x.SpecVersion = (uint32)(x.ref2f001956.specVersion)
}

// allocLayerPropertiesMemory allocates memory for type C.VkLayerProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLayerPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLayerPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfLayerPropertiesValue = unsafe.Sizeof([1]C.VkLayerProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LayerProperties) Ref() *C.VkLayerProperties {
	if x == nil {
		return nil
	}
	return x.refd9407ce7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LayerProperties) Free() {
	if x != nil && x.allocsd9407ce7 != nil {
		x.allocsd9407ce7.(*cgoAllocMap).Free()
		x.refd9407ce7 = nil
	}
}

// NewLayerPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLayerPropertiesRef(ref unsafe.Pointer) *LayerProperties {
	if ref == nil {
		return nil
	}
	obj := new(LayerProperties)
	obj.refd9407ce7 = (*C.VkLayerProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LayerProperties) PassRef() (*C.VkLayerProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd9407ce7 != nil {
		return x.refd9407ce7, nil
	}
	memd9407ce7 := allocLayerPropertiesMemory(1)
	refd9407ce7 := (*C.VkLayerProperties)(memd9407ce7)
	allocsd9407ce7 := new(cgoAllocMap)
	allocsd9407ce7.Add(memd9407ce7)

	var clayerName_allocs *cgoAllocMap
	refd9407ce7.layerName, clayerName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.LayerName)), cgoAllocsUnknown
	allocsd9407ce7.Borrow(clayerName_allocs)

	var cspecVersion_allocs *cgoAllocMap
	refd9407ce7.specVersion, cspecVersion_allocs = (C.uint32_t)(x.SpecVersion), cgoAllocsUnknown
	allocsd9407ce7.Borrow(cspecVersion_allocs)

	var cimplementationVersion_allocs *cgoAllocMap
	refd9407ce7.implementationVersion, cimplementationVersion_allocs = (C.uint32_t)(x.ImplementationVersion), cgoAllocsUnknown
	allocsd9407ce7.Borrow(cimplementationVersion_allocs)

	var cdescription_allocs *cgoAllocMap
	refd9407ce7.description, cdescription_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Description)), cgoAllocsUnknown
	allocsd9407ce7.Borrow(cdescription_allocs)

	x.refd9407ce7 = refd9407ce7
	x.allocsd9407ce7 = allocsd9407ce7
	return refd9407ce7, allocsd9407ce7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LayerProperties) PassValue() (C.VkLayerProperties, *cgoAllocMap) {
	if x.refd9407ce7 != nil {
		return *x.refd9407ce7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LayerProperties) Deref() {
	if x.refd9407ce7 == nil {
		return
	}
	x.LayerName = *(*[256]byte)(unsafe.Pointer(&x.refd9407ce7.layerName))
	x.SpecVersion = (uint32)(x.refd9407ce7.specVersion)
	x.ImplementationVersion = (uint32)(x.refd9407ce7.implementationVersion)
	x.Description = *(*[256]byte)(unsafe.Pointer(&x.refd9407ce7.description))
}

// allocSubmitInfoMemory allocates memory for type C.VkSubmitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubmitInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubmitInfoValue = unsafe.Sizeof([1]C.VkSubmitInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubmitInfo) Ref() *C.VkSubmitInfo {
	if x == nil {
		return nil
	}
	return x.ref22884025
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubmitInfo) Free() {
	if x != nil && x.allocs22884025 != nil {
		x.allocs22884025.(*cgoAllocMap).Free()
		x.ref22884025 = nil
	}
}

// NewSubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubmitInfoRef(ref unsafe.Pointer) *SubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(SubmitInfo)
	obj.ref22884025 = (*C.VkSubmitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubmitInfo) PassRef() (*C.VkSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref22884025 != nil {
		return x.ref22884025, nil
	}
	mem22884025 := allocSubmitInfoMemory(1)
	ref22884025 := (*C.VkSubmitInfo)(mem22884025)
	allocs22884025 := new(cgoAllocMap)
	allocs22884025.Add(mem22884025)

	var csType_allocs *cgoAllocMap
	ref22884025.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs22884025.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref22884025.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs22884025.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	ref22884025.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocs22884025.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphores_allocs *cgoAllocMap
	ref22884025.pWaitSemaphores, cpWaitSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)).Data)), cgoAllocsUnknown
	allocs22884025.Borrow(cpWaitSemaphores_allocs)

	var cpWaitDstStageMask_allocs *cgoAllocMap
	ref22884025.pWaitDstStageMask, cpWaitDstStageMask_allocs = (*C.VkPipelineStageFlags)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitDstStageMask)).Data)), cgoAllocsUnknown
	allocs22884025.Borrow(cpWaitDstStageMask_allocs)

	var ccommandBufferCount_allocs *cgoAllocMap
	ref22884025.commandBufferCount, ccommandBufferCount_allocs = (C.uint32_t)(x.CommandBufferCount), cgoAllocsUnknown
	allocs22884025.Borrow(ccommandBufferCount_allocs)

	var cpCommandBuffers_allocs *cgoAllocMap
	ref22884025.pCommandBuffers, cpCommandBuffers_allocs = (*C.VkCommandBuffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCommandBuffers)).Data)), cgoAllocsUnknown
	allocs22884025.Borrow(cpCommandBuffers_allocs)

	var csignalSemaphoreCount_allocs *cgoAllocMap
	ref22884025.signalSemaphoreCount, csignalSemaphoreCount_allocs = (C.uint32_t)(x.SignalSemaphoreCount), cgoAllocsUnknown
	allocs22884025.Borrow(csignalSemaphoreCount_allocs)

	var cpSignalSemaphores_allocs *cgoAllocMap
	ref22884025.pSignalSemaphores, cpSignalSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores)).Data)), cgoAllocsUnknown
	allocs22884025.Borrow(cpSignalSemaphores_allocs)

	x.ref22884025 = ref22884025
	x.allocs22884025 = allocs22884025
	return ref22884025, allocs22884025

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubmitInfo) PassValue() (C.VkSubmitInfo, *cgoAllocMap) {
	if x.ref22884025 != nil {
		return *x.ref22884025, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubmitInfo) Deref() {
	if x.ref22884025 == nil {
		return
	}
	x.SType = (StructureType)(x.ref22884025.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref22884025.pNext))
	x.WaitSemaphoreCount = (uint32)(x.ref22884025.waitSemaphoreCount)
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxf95e7c8.Data = unsafe.Pointer(x.ref22884025.pWaitSemaphores)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.PWaitDstStageMask))
	hxff2234b.Data = unsafe.Pointer(x.ref22884025.pWaitDstStageMask)
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	x.CommandBufferCount = (uint32)(x.ref22884025.commandBufferCount)
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.PCommandBuffers))
	hxff73280.Data = unsafe.Pointer(x.ref22884025.pCommandBuffers)
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	x.SignalSemaphoreCount = (uint32)(x.ref22884025.signalSemaphoreCount)
	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores))
	hxfa9955c.Data = unsafe.Pointer(x.ref22884025.pSignalSemaphores)
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ?

}

// allocMemoryAllocateInfoMemory allocates memory for type C.VkMemoryAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryAllocateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryAllocateInfoValue = unsafe.Sizeof([1]C.VkMemoryAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryAllocateInfo) Ref() *C.VkMemoryAllocateInfo {
	if x == nil {
		return nil
	}
	return x.ref31032b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryAllocateInfo) Free() {
	if x != nil && x.allocs31032b != nil {
		x.allocs31032b.(*cgoAllocMap).Free()
		x.ref31032b = nil
	}
}

// NewMemoryAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryAllocateInfoRef(ref unsafe.Pointer) *MemoryAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(MemoryAllocateInfo)
	obj.ref31032b = (*C.VkMemoryAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryAllocateInfo) PassRef() (*C.VkMemoryAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref31032b != nil {
		return x.ref31032b, nil
	}
	mem31032b := allocMemoryAllocateInfoMemory(1)
	ref31032b := (*C.VkMemoryAllocateInfo)(mem31032b)
	allocs31032b := new(cgoAllocMap)
	allocs31032b.Add(mem31032b)

	var csType_allocs *cgoAllocMap
	ref31032b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs31032b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref31032b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs31032b.Borrow(cpNext_allocs)

	var callocationSize_allocs *cgoAllocMap
	ref31032b.allocationSize, callocationSize_allocs = (C.VkDeviceSize)(x.AllocationSize), cgoAllocsUnknown
	allocs31032b.Borrow(callocationSize_allocs)

	var cmemoryTypeIndex_allocs *cgoAllocMap
	ref31032b.memoryTypeIndex, cmemoryTypeIndex_allocs = (C.uint32_t)(x.MemoryTypeIndex), cgoAllocsUnknown
	allocs31032b.Borrow(cmemoryTypeIndex_allocs)

	x.ref31032b = ref31032b
	x.allocs31032b = allocs31032b
	return ref31032b, allocs31032b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryAllocateInfo) PassValue() (C.VkMemoryAllocateInfo, *cgoAllocMap) {
	if x.ref31032b != nil {
		return *x.ref31032b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryAllocateInfo) Deref() {
	if x.ref31032b == nil {
		return
	}
	x.SType = (StructureType)(x.ref31032b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref31032b.pNext))
	x.AllocationSize = (DeviceSize)(x.ref31032b.allocationSize)
	x.MemoryTypeIndex = (uint32)(x.ref31032b.memoryTypeIndex)
}

// allocMappedMemoryRangeMemory allocates memory for type C.VkMappedMemoryRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMappedMemoryRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMappedMemoryRangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMappedMemoryRangeValue = unsafe.Sizeof([1]C.VkMappedMemoryRange{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MappedMemoryRange) Ref() *C.VkMappedMemoryRange {
	if x == nil {
		return nil
	}
	return x.ref42a37320
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MappedMemoryRange) Free() {
	if x != nil && x.allocs42a37320 != nil {
		x.allocs42a37320.(*cgoAllocMap).Free()
		x.ref42a37320 = nil
	}
}

// NewMappedMemoryRangeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMappedMemoryRangeRef(ref unsafe.Pointer) *MappedMemoryRange {
	if ref == nil {
		return nil
	}
	obj := new(MappedMemoryRange)
	obj.ref42a37320 = (*C.VkMappedMemoryRange)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MappedMemoryRange) PassRef() (*C.VkMappedMemoryRange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref42a37320 != nil {
		return x.ref42a37320, nil
	}
	mem42a37320 := allocMappedMemoryRangeMemory(1)
	ref42a37320 := (*C.VkMappedMemoryRange)(mem42a37320)
	allocs42a37320 := new(cgoAllocMap)
	allocs42a37320.Add(mem42a37320)

	var csType_allocs *cgoAllocMap
	ref42a37320.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs42a37320.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref42a37320.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs42a37320.Borrow(cpNext_allocs)

	var cmemory_allocs *cgoAllocMap
	ref42a37320.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs42a37320.Borrow(cmemory_allocs)

	var coffset_allocs *cgoAllocMap
	ref42a37320.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs42a37320.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref42a37320.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs42a37320.Borrow(csize_allocs)

	x.ref42a37320 = ref42a37320
	x.allocs42a37320 = allocs42a37320
	return ref42a37320, allocs42a37320

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MappedMemoryRange) PassValue() (C.VkMappedMemoryRange, *cgoAllocMap) {
	if x.ref42a37320 != nil {
		return *x.ref42a37320, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MappedMemoryRange) Deref() {
	if x.ref42a37320 == nil {
		return
	}
	x.SType = (StructureType)(x.ref42a37320.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref42a37320.pNext))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref42a37320.memory))
	x.Offset = (DeviceSize)(x.ref42a37320.offset)
	x.Size = (DeviceSize)(x.ref42a37320.size)
}

// allocMemoryRequirementsMemory allocates memory for type C.VkMemoryRequirements in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryRequirementsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryRequirementsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryRequirementsValue = unsafe.Sizeof([1]C.VkMemoryRequirements{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryRequirements) Ref() *C.VkMemoryRequirements {
	if x == nil {
		return nil
	}
	return x.ref5259fc6b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryRequirements) Free() {
	if x != nil && x.allocs5259fc6b != nil {
		x.allocs5259fc6b.(*cgoAllocMap).Free()
		x.ref5259fc6b = nil
	}
}

// NewMemoryRequirementsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryRequirementsRef(ref unsafe.Pointer) *MemoryRequirements {
	if ref == nil {
		return nil
	}
	obj := new(MemoryRequirements)
	obj.ref5259fc6b = (*C.VkMemoryRequirements)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryRequirements) PassRef() (*C.VkMemoryRequirements, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5259fc6b != nil {
		return x.ref5259fc6b, nil
	}
	mem5259fc6b := allocMemoryRequirementsMemory(1)
	ref5259fc6b := (*C.VkMemoryRequirements)(mem5259fc6b)
	allocs5259fc6b := new(cgoAllocMap)
	allocs5259fc6b.Add(mem5259fc6b)

	var csize_allocs *cgoAllocMap
	ref5259fc6b.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs5259fc6b.Borrow(csize_allocs)

	var calignment_allocs *cgoAllocMap
	ref5259fc6b.alignment, calignment_allocs = (C.VkDeviceSize)(x.Alignment), cgoAllocsUnknown
	allocs5259fc6b.Borrow(calignment_allocs)

	var cmemoryTypeBits_allocs *cgoAllocMap
	ref5259fc6b.memoryTypeBits, cmemoryTypeBits_allocs = (C.uint32_t)(x.MemoryTypeBits), cgoAllocsUnknown
	allocs5259fc6b.Borrow(cmemoryTypeBits_allocs)

	x.ref5259fc6b = ref5259fc6b
	x.allocs5259fc6b = allocs5259fc6b
	return ref5259fc6b, allocs5259fc6b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryRequirements) PassValue() (C.VkMemoryRequirements, *cgoAllocMap) {
	if x.ref5259fc6b != nil {
		return *x.ref5259fc6b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryRequirements) Deref() {
	if x.ref5259fc6b == nil {
		return
	}
	x.Size = (DeviceSize)(x.ref5259fc6b.size)
	x.Alignment = (DeviceSize)(x.ref5259fc6b.alignment)
	x.MemoryTypeBits = (uint32)(x.ref5259fc6b.memoryTypeBits)
}

// allocSparseImageFormatPropertiesMemory allocates memory for type C.VkSparseImageFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageFormatPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkSparseImageFormatProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageFormatProperties) Ref() *C.VkSparseImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.ref2c12cf44
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageFormatProperties) Free() {
	if x != nil && x.allocs2c12cf44 != nil {
		x.allocs2c12cf44.(*cgoAllocMap).Free()
		x.ref2c12cf44 = nil
	}
}

// NewSparseImageFormatPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageFormatPropertiesRef(ref unsafe.Pointer) *SparseImageFormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageFormatProperties)
	obj.ref2c12cf44 = (*C.VkSparseImageFormatProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageFormatProperties) PassRef() (*C.VkSparseImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2c12cf44 != nil {
		return x.ref2c12cf44, nil
	}
	mem2c12cf44 := allocSparseImageFormatPropertiesMemory(1)
	ref2c12cf44 := (*C.VkSparseImageFormatProperties)(mem2c12cf44)
	allocs2c12cf44 := new(cgoAllocMap)
	allocs2c12cf44.Add(mem2c12cf44)

	var caspectMask_allocs *cgoAllocMap
	ref2c12cf44.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs2c12cf44.Borrow(caspectMask_allocs)

	var cimageGranularity_allocs *cgoAllocMap
	ref2c12cf44.imageGranularity, cimageGranularity_allocs = x.ImageGranularity.PassValue()
	allocs2c12cf44.Borrow(cimageGranularity_allocs)

	var cflags_allocs *cgoAllocMap
	ref2c12cf44.flags, cflags_allocs = (C.VkSparseImageFormatFlags)(x.Flags), cgoAllocsUnknown
	allocs2c12cf44.Borrow(cflags_allocs)

	x.ref2c12cf44 = ref2c12cf44
	x.allocs2c12cf44 = allocs2c12cf44
	return ref2c12cf44, allocs2c12cf44

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageFormatProperties) PassValue() (C.VkSparseImageFormatProperties, *cgoAllocMap) {
	if x.ref2c12cf44 != nil {
		return *x.ref2c12cf44, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageFormatProperties) Deref() {
	if x.ref2c12cf44 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.ref2c12cf44.aspectMask)
	x.ImageGranularity = *NewExtent3DRef(unsafe.Pointer(&x.ref2c12cf44.imageGranularity))
	x.Flags = (SparseImageFormatFlags)(x.ref2c12cf44.flags)
}

// allocSparseImageMemoryRequirementsMemory allocates memory for type C.VkSparseImageMemoryRequirements in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryRequirementsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryRequirementsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageMemoryRequirementsValue = unsafe.Sizeof([1]C.VkSparseImageMemoryRequirements{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageMemoryRequirements) Ref() *C.VkSparseImageMemoryRequirements {
	if x == nil {
		return nil
	}
	return x.ref685a2323
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageMemoryRequirements) Free() {
	if x != nil && x.allocs685a2323 != nil {
		x.allocs685a2323.(*cgoAllocMap).Free()
		x.ref685a2323 = nil
	}
}

// NewSparseImageMemoryRequirementsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageMemoryRequirementsRef(ref unsafe.Pointer) *SparseImageMemoryRequirements {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryRequirements)
	obj.ref685a2323 = (*C.VkSparseImageMemoryRequirements)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageMemoryRequirements) PassRef() (*C.VkSparseImageMemoryRequirements, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref685a2323 != nil {
		return x.ref685a2323, nil
	}
	mem685a2323 := allocSparseImageMemoryRequirementsMemory(1)
	ref685a2323 := (*C.VkSparseImageMemoryRequirements)(mem685a2323)
	allocs685a2323 := new(cgoAllocMap)
	allocs685a2323.Add(mem685a2323)

	var cformatProperties_allocs *cgoAllocMap
	ref685a2323.formatProperties, cformatProperties_allocs = x.FormatProperties.PassValue()
	allocs685a2323.Borrow(cformatProperties_allocs)

	var cimageMipTailFirstLod_allocs *cgoAllocMap
	ref685a2323.imageMipTailFirstLod, cimageMipTailFirstLod_allocs = (C.uint32_t)(x.ImageMipTailFirstLod), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailFirstLod_allocs)

	var cimageMipTailSize_allocs *cgoAllocMap
	ref685a2323.imageMipTailSize, cimageMipTailSize_allocs = (C.VkDeviceSize)(x.ImageMipTailSize), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailSize_allocs)

	var cimageMipTailOffset_allocs *cgoAllocMap
	ref685a2323.imageMipTailOffset, cimageMipTailOffset_allocs = (C.VkDeviceSize)(x.ImageMipTailOffset), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailOffset_allocs)

	var cimageMipTailStride_allocs *cgoAllocMap
	ref685a2323.imageMipTailStride, cimageMipTailStride_allocs = (C.VkDeviceSize)(x.ImageMipTailStride), cgoAllocsUnknown
	allocs685a2323.Borrow(cimageMipTailStride_allocs)

	x.ref685a2323 = ref685a2323
	x.allocs685a2323 = allocs685a2323
	return ref685a2323, allocs685a2323

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageMemoryRequirements) PassValue() (C.VkSparseImageMemoryRequirements, *cgoAllocMap) {
	if x.ref685a2323 != nil {
		return *x.ref685a2323, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageMemoryRequirements) Deref() {
	if x.ref685a2323 == nil {
		return
	}
	x.FormatProperties = *NewSparseImageFormatPropertiesRef(unsafe.Pointer(&x.ref685a2323.formatProperties))
	x.ImageMipTailFirstLod = (uint32)(x.ref685a2323.imageMipTailFirstLod)
	x.ImageMipTailSize = (DeviceSize)(x.ref685a2323.imageMipTailSize)
	x.ImageMipTailOffset = (DeviceSize)(x.ref685a2323.imageMipTailOffset)
	x.ImageMipTailStride = (DeviceSize)(x.ref685a2323.imageMipTailStride)
}

// allocSparseMemoryBindMemory allocates memory for type C.VkSparseMemoryBind in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseMemoryBindMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseMemoryBindValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseMemoryBindValue = unsafe.Sizeof([1]C.VkSparseMemoryBind{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseMemoryBind) Ref() *C.VkSparseMemoryBind {
	if x == nil {
		return nil
	}
	return x.ref5bf418e8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseMemoryBind) Free() {
	if x != nil && x.allocs5bf418e8 != nil {
		x.allocs5bf418e8.(*cgoAllocMap).Free()
		x.ref5bf418e8 = nil
	}
}

// NewSparseMemoryBindRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseMemoryBindRef(ref unsafe.Pointer) *SparseMemoryBind {
	if ref == nil {
		return nil
	}
	obj := new(SparseMemoryBind)
	obj.ref5bf418e8 = (*C.VkSparseMemoryBind)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseMemoryBind) PassRef() (*C.VkSparseMemoryBind, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5bf418e8 != nil {
		return x.ref5bf418e8, nil
	}
	mem5bf418e8 := allocSparseMemoryBindMemory(1)
	ref5bf418e8 := (*C.VkSparseMemoryBind)(mem5bf418e8)
	allocs5bf418e8 := new(cgoAllocMap)
	allocs5bf418e8.Add(mem5bf418e8)

	var cresourceOffset_allocs *cgoAllocMap
	ref5bf418e8.resourceOffset, cresourceOffset_allocs = (C.VkDeviceSize)(x.ResourceOffset), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cresourceOffset_allocs)

	var csize_allocs *cgoAllocMap
	ref5bf418e8.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs5bf418e8.Borrow(csize_allocs)

	var cmemory_allocs *cgoAllocMap
	ref5bf418e8.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	ref5bf418e8.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cmemoryOffset_allocs)

	var cflags_allocs *cgoAllocMap
	ref5bf418e8.flags, cflags_allocs = (C.VkSparseMemoryBindFlags)(x.Flags), cgoAllocsUnknown
	allocs5bf418e8.Borrow(cflags_allocs)

	x.ref5bf418e8 = ref5bf418e8
	x.allocs5bf418e8 = allocs5bf418e8
	return ref5bf418e8, allocs5bf418e8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseMemoryBind) PassValue() (C.VkSparseMemoryBind, *cgoAllocMap) {
	if x.ref5bf418e8 != nil {
		return *x.ref5bf418e8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseMemoryBind) Deref() {
	if x.ref5bf418e8 == nil {
		return
	}
	x.ResourceOffset = (DeviceSize)(x.ref5bf418e8.resourceOffset)
	x.Size = (DeviceSize)(x.ref5bf418e8.size)
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref5bf418e8.memory))
	x.MemoryOffset = (DeviceSize)(x.ref5bf418e8.memoryOffset)
	x.Flags = (SparseMemoryBindFlags)(x.ref5bf418e8.flags)
}

// allocSparseBufferMemoryBindInfoMemory allocates memory for type C.VkSparseBufferMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseBufferMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseBufferMemoryBindInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseBufferMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseBufferMemoryBindInfo{})

// unpackSSparseMemoryBind transforms a sliced Go data structure into plain C format.
func unpackSSparseMemoryBind(x []SparseMemoryBind) (unpacked *C.VkSparseMemoryBind, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseMemoryBind) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseMemoryBindMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseMemoryBind)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseMemoryBind)(h.Data)
	return
}

// packSSparseMemoryBind reads sliced Go data structure out from plain C format.
func packSSparseMemoryBind(v []SparseMemoryBind, ptr0 *C.VkSparseMemoryBind) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseMemoryBindValue]C.VkSparseMemoryBind)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseMemoryBindRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseBufferMemoryBindInfo) Ref() *C.VkSparseBufferMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.refebcaf40c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseBufferMemoryBindInfo) Free() {
	if x != nil && x.allocsebcaf40c != nil {
		x.allocsebcaf40c.(*cgoAllocMap).Free()
		x.refebcaf40c = nil
	}
}

// NewSparseBufferMemoryBindInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseBufferMemoryBindInfoRef(ref unsafe.Pointer) *SparseBufferMemoryBindInfo {
	if ref == nil {
		return nil
	}
	obj := new(SparseBufferMemoryBindInfo)
	obj.refebcaf40c = (*C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseBufferMemoryBindInfo) PassRef() (*C.VkSparseBufferMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refebcaf40c != nil {
		return x.refebcaf40c, nil
	}
	memebcaf40c := allocSparseBufferMemoryBindInfoMemory(1)
	refebcaf40c := (*C.VkSparseBufferMemoryBindInfo)(memebcaf40c)
	allocsebcaf40c := new(cgoAllocMap)
	allocsebcaf40c.Add(memebcaf40c)

	var cbuffer_allocs *cgoAllocMap
	refebcaf40c.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsebcaf40c.Borrow(cbuffer_allocs)

	var cbindCount_allocs *cgoAllocMap
	refebcaf40c.bindCount, cbindCount_allocs = (C.uint32_t)(x.BindCount), cgoAllocsUnknown
	allocsebcaf40c.Borrow(cbindCount_allocs)

	var cpBinds_allocs *cgoAllocMap
	refebcaf40c.pBinds, cpBinds_allocs = unpackSSparseMemoryBind(x.PBinds)
	allocsebcaf40c.Borrow(cpBinds_allocs)

	x.refebcaf40c = refebcaf40c
	x.allocsebcaf40c = allocsebcaf40c
	return refebcaf40c, allocsebcaf40c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseBufferMemoryBindInfo) PassValue() (C.VkSparseBufferMemoryBindInfo, *cgoAllocMap) {
	if x.refebcaf40c != nil {
		return *x.refebcaf40c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseBufferMemoryBindInfo) Deref() {
	if x.refebcaf40c == nil {
		return
	}
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refebcaf40c.buffer))
	x.BindCount = (uint32)(x.refebcaf40c.bindCount)
	packSSparseMemoryBind(x.PBinds, x.refebcaf40c.pBinds)
}

// allocSparseImageOpaqueMemoryBindInfoMemory allocates memory for type C.VkSparseImageOpaqueMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageOpaqueMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageOpaqueMemoryBindInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageOpaqueMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseImageOpaqueMemoryBindInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageOpaqueMemoryBindInfo) Ref() *C.VkSparseImageOpaqueMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.reffb1b3d56
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageOpaqueMemoryBindInfo) Free() {
	if x != nil && x.allocsfb1b3d56 != nil {
		x.allocsfb1b3d56.(*cgoAllocMap).Free()
		x.reffb1b3d56 = nil
	}
}

// NewSparseImageOpaqueMemoryBindInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageOpaqueMemoryBindInfoRef(ref unsafe.Pointer) *SparseImageOpaqueMemoryBindInfo {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageOpaqueMemoryBindInfo)
	obj.reffb1b3d56 = (*C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageOpaqueMemoryBindInfo) PassRef() (*C.VkSparseImageOpaqueMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffb1b3d56 != nil {
		return x.reffb1b3d56, nil
	}
	memfb1b3d56 := allocSparseImageOpaqueMemoryBindInfoMemory(1)
	reffb1b3d56 := (*C.VkSparseImageOpaqueMemoryBindInfo)(memfb1b3d56)
	allocsfb1b3d56 := new(cgoAllocMap)
	allocsfb1b3d56.Add(memfb1b3d56)

	var cimage_allocs *cgoAllocMap
	reffb1b3d56.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocsfb1b3d56.Borrow(cimage_allocs)

	var cbindCount_allocs *cgoAllocMap
	reffb1b3d56.bindCount, cbindCount_allocs = (C.uint32_t)(x.BindCount), cgoAllocsUnknown
	allocsfb1b3d56.Borrow(cbindCount_allocs)

	var cpBinds_allocs *cgoAllocMap
	reffb1b3d56.pBinds, cpBinds_allocs = unpackSSparseMemoryBind(x.PBinds)
	allocsfb1b3d56.Borrow(cpBinds_allocs)

	x.reffb1b3d56 = reffb1b3d56
	x.allocsfb1b3d56 = allocsfb1b3d56
	return reffb1b3d56, allocsfb1b3d56

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageOpaqueMemoryBindInfo) PassValue() (C.VkSparseImageOpaqueMemoryBindInfo, *cgoAllocMap) {
	if x.reffb1b3d56 != nil {
		return *x.reffb1b3d56, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageOpaqueMemoryBindInfo) Deref() {
	if x.reffb1b3d56 == nil {
		return
	}
	x.Image = *(*Image)(unsafe.Pointer(&x.reffb1b3d56.image))
	x.BindCount = (uint32)(x.reffb1b3d56.bindCount)
	packSSparseMemoryBind(x.PBinds, x.reffb1b3d56.pBinds)
}

// allocImageSubresourceMemory allocates memory for type C.VkImageSubresource in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSubresourceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSubresourceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageSubresourceValue = unsafe.Sizeof([1]C.VkImageSubresource{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSubresource) Ref() *C.VkImageSubresource {
	if x == nil {
		return nil
	}
	return x.reffeaa0d8a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSubresource) Free() {
	if x != nil && x.allocsfeaa0d8a != nil {
		x.allocsfeaa0d8a.(*cgoAllocMap).Free()
		x.reffeaa0d8a = nil
	}
}

// NewImageSubresourceRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSubresourceRef(ref unsafe.Pointer) *ImageSubresource {
	if ref == nil {
		return nil
	}
	obj := new(ImageSubresource)
	obj.reffeaa0d8a = (*C.VkImageSubresource)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSubresource) PassRef() (*C.VkImageSubresource, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffeaa0d8a != nil {
		return x.reffeaa0d8a, nil
	}
	memfeaa0d8a := allocImageSubresourceMemory(1)
	reffeaa0d8a := (*C.VkImageSubresource)(memfeaa0d8a)
	allocsfeaa0d8a := new(cgoAllocMap)
	allocsfeaa0d8a.Add(memfeaa0d8a)

	var caspectMask_allocs *cgoAllocMap
	reffeaa0d8a.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocsfeaa0d8a.Borrow(caspectMask_allocs)

	var cmipLevel_allocs *cgoAllocMap
	reffeaa0d8a.mipLevel, cmipLevel_allocs = (C.uint32_t)(x.MipLevel), cgoAllocsUnknown
	allocsfeaa0d8a.Borrow(cmipLevel_allocs)

	var carrayLayer_allocs *cgoAllocMap
	reffeaa0d8a.arrayLayer, carrayLayer_allocs = (C.uint32_t)(x.ArrayLayer), cgoAllocsUnknown
	allocsfeaa0d8a.Borrow(carrayLayer_allocs)

	x.reffeaa0d8a = reffeaa0d8a
	x.allocsfeaa0d8a = allocsfeaa0d8a
	return reffeaa0d8a, allocsfeaa0d8a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSubresource) PassValue() (C.VkImageSubresource, *cgoAllocMap) {
	if x.reffeaa0d8a != nil {
		return *x.reffeaa0d8a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSubresource) Deref() {
	if x.reffeaa0d8a == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.reffeaa0d8a.aspectMask)
	x.MipLevel = (uint32)(x.reffeaa0d8a.mipLevel)
	x.ArrayLayer = (uint32)(x.reffeaa0d8a.arrayLayer)
}

// allocOffset3DMemory allocates memory for type C.VkOffset3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOffset3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOffset3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfOffset3DValue = unsafe.Sizeof([1]C.VkOffset3D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Offset3D) Ref() *C.VkOffset3D {
	if x == nil {
		return nil
	}
	return x.ref2b6879c2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Offset3D) Free() {
	if x != nil && x.allocs2b6879c2 != nil {
		x.allocs2b6879c2.(*cgoAllocMap).Free()
		x.ref2b6879c2 = nil
	}
}

// NewOffset3DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOffset3DRef(ref unsafe.Pointer) *Offset3D {
	if ref == nil {
		return nil
	}
	obj := new(Offset3D)
	obj.ref2b6879c2 = (*C.VkOffset3D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Offset3D) PassRef() (*C.VkOffset3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2b6879c2 != nil {
		return x.ref2b6879c2, nil
	}
	mem2b6879c2 := allocOffset3DMemory(1)
	ref2b6879c2 := (*C.VkOffset3D)(mem2b6879c2)
	allocs2b6879c2 := new(cgoAllocMap)
	allocs2b6879c2.Add(mem2b6879c2)

	var cx_allocs *cgoAllocMap
	ref2b6879c2.x, cx_allocs = (C.int32_t)(x.X), cgoAllocsUnknown
	allocs2b6879c2.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref2b6879c2.y, cy_allocs = (C.int32_t)(x.Y), cgoAllocsUnknown
	allocs2b6879c2.Borrow(cy_allocs)

	var cz_allocs *cgoAllocMap
	ref2b6879c2.z, cz_allocs = (C.int32_t)(x.Z), cgoAllocsUnknown
	allocs2b6879c2.Borrow(cz_allocs)

	x.ref2b6879c2 = ref2b6879c2
	x.allocs2b6879c2 = allocs2b6879c2
	return ref2b6879c2, allocs2b6879c2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Offset3D) PassValue() (C.VkOffset3D, *cgoAllocMap) {
	if x.ref2b6879c2 != nil {
		return *x.ref2b6879c2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Offset3D) Deref() {
	if x.ref2b6879c2 == nil {
		return
	}
	x.X = (int32)(x.ref2b6879c2.x)
	x.Y = (int32)(x.ref2b6879c2.y)
	x.Z = (int32)(x.ref2b6879c2.z)
}

// allocSparseImageMemoryBindMemory allocates memory for type C.VkSparseImageMemoryBind in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryBindMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryBindValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageMemoryBindValue = unsafe.Sizeof([1]C.VkSparseImageMemoryBind{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageMemoryBind) Ref() *C.VkSparseImageMemoryBind {
	if x == nil {
		return nil
	}
	return x.ref41b516d7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageMemoryBind) Free() {
	if x != nil && x.allocs41b516d7 != nil {
		x.allocs41b516d7.(*cgoAllocMap).Free()
		x.ref41b516d7 = nil
	}
}

// NewSparseImageMemoryBindRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageMemoryBindRef(ref unsafe.Pointer) *SparseImageMemoryBind {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryBind)
	obj.ref41b516d7 = (*C.VkSparseImageMemoryBind)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageMemoryBind) PassRef() (*C.VkSparseImageMemoryBind, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref41b516d7 != nil {
		return x.ref41b516d7, nil
	}
	mem41b516d7 := allocSparseImageMemoryBindMemory(1)
	ref41b516d7 := (*C.VkSparseImageMemoryBind)(mem41b516d7)
	allocs41b516d7 := new(cgoAllocMap)
	allocs41b516d7.Add(mem41b516d7)

	var csubresource_allocs *cgoAllocMap
	ref41b516d7.subresource, csubresource_allocs = x.Subresource.PassValue()
	allocs41b516d7.Borrow(csubresource_allocs)

	var coffset_allocs *cgoAllocMap
	ref41b516d7.offset, coffset_allocs = x.Offset.PassValue()
	allocs41b516d7.Borrow(coffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref41b516d7.extent, cextent_allocs = x.Extent.PassValue()
	allocs41b516d7.Borrow(cextent_allocs)

	var cmemory_allocs *cgoAllocMap
	ref41b516d7.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs41b516d7.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	ref41b516d7.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocs41b516d7.Borrow(cmemoryOffset_allocs)

	var cflags_allocs *cgoAllocMap
	ref41b516d7.flags, cflags_allocs = (C.VkSparseMemoryBindFlags)(x.Flags), cgoAllocsUnknown
	allocs41b516d7.Borrow(cflags_allocs)

	x.ref41b516d7 = ref41b516d7
	x.allocs41b516d7 = allocs41b516d7
	return ref41b516d7, allocs41b516d7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageMemoryBind) PassValue() (C.VkSparseImageMemoryBind, *cgoAllocMap) {
	if x.ref41b516d7 != nil {
		return *x.ref41b516d7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageMemoryBind) Deref() {
	if x.ref41b516d7 == nil {
		return
	}
	x.Subresource = *NewImageSubresourceRef(unsafe.Pointer(&x.ref41b516d7.subresource))
	x.Offset = *NewOffset3DRef(unsafe.Pointer(&x.ref41b516d7.offset))
	x.Extent = *NewExtent3DRef(unsafe.Pointer(&x.ref41b516d7.extent))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref41b516d7.memory))
	x.MemoryOffset = (DeviceSize)(x.ref41b516d7.memoryOffset)
	x.Flags = (SparseMemoryBindFlags)(x.ref41b516d7.flags)
}

// allocSparseImageMemoryBindInfoMemory allocates memory for type C.VkSparseImageMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryBindInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseImageMemoryBindInfo{})

// unpackSSparseImageMemoryBind transforms a sliced Go data structure into plain C format.
func unpackSSparseImageMemoryBind(x []SparseImageMemoryBind) (unpacked *C.VkSparseImageMemoryBind, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageMemoryBind) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageMemoryBindMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageMemoryBind)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageMemoryBind)(h.Data)
	return
}

// packSSparseImageMemoryBind reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryBind(v []SparseImageMemoryBind, ptr0 *C.VkSparseImageMemoryBind) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryBindValue]C.VkSparseImageMemoryBind)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryBindRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageMemoryBindInfo) Ref() *C.VkSparseImageMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.ref50faeb70
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageMemoryBindInfo) Free() {
	if x != nil && x.allocs50faeb70 != nil {
		x.allocs50faeb70.(*cgoAllocMap).Free()
		x.ref50faeb70 = nil
	}
}

// NewSparseImageMemoryBindInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageMemoryBindInfoRef(ref unsafe.Pointer) *SparseImageMemoryBindInfo {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryBindInfo)
	obj.ref50faeb70 = (*C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageMemoryBindInfo) PassRef() (*C.VkSparseImageMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref50faeb70 != nil {
		return x.ref50faeb70, nil
	}
	mem50faeb70 := allocSparseImageMemoryBindInfoMemory(1)
	ref50faeb70 := (*C.VkSparseImageMemoryBindInfo)(mem50faeb70)
	allocs50faeb70 := new(cgoAllocMap)
	allocs50faeb70.Add(mem50faeb70)

	var cimage_allocs *cgoAllocMap
	ref50faeb70.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs50faeb70.Borrow(cimage_allocs)

	var cbindCount_allocs *cgoAllocMap
	ref50faeb70.bindCount, cbindCount_allocs = (C.uint32_t)(x.BindCount), cgoAllocsUnknown
	allocs50faeb70.Borrow(cbindCount_allocs)

	var cpBinds_allocs *cgoAllocMap
	ref50faeb70.pBinds, cpBinds_allocs = unpackSSparseImageMemoryBind(x.PBinds)
	allocs50faeb70.Borrow(cpBinds_allocs)

	x.ref50faeb70 = ref50faeb70
	x.allocs50faeb70 = allocs50faeb70
	return ref50faeb70, allocs50faeb70

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageMemoryBindInfo) PassValue() (C.VkSparseImageMemoryBindInfo, *cgoAllocMap) {
	if x.ref50faeb70 != nil {
		return *x.ref50faeb70, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageMemoryBindInfo) Deref() {
	if x.ref50faeb70 == nil {
		return
	}
	x.Image = *(*Image)(unsafe.Pointer(&x.ref50faeb70.image))
	x.BindCount = (uint32)(x.ref50faeb70.bindCount)
	packSSparseImageMemoryBind(x.PBinds, x.ref50faeb70.pBinds)
}

// allocBindSparseInfoMemory allocates memory for type C.VkBindSparseInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindSparseInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindSparseInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindSparseInfoValue = unsafe.Sizeof([1]C.VkBindSparseInfo{})

// unpackSSparseBufferMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseBufferMemoryBindInfo(x []SparseBufferMemoryBindInfo) (unpacked *C.VkSparseBufferMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseBufferMemoryBindInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseBufferMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseBufferMemoryBindInfo)(h.Data)
	return
}

// unpackSSparseImageOpaqueMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseImageOpaqueMemoryBindInfo(x []SparseImageOpaqueMemoryBindInfo) (unpacked *C.VkSparseImageOpaqueMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageOpaqueMemoryBindInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageOpaqueMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageOpaqueMemoryBindInfo)(h.Data)
	return
}

// unpackSSparseImageMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseImageMemoryBindInfo(x []SparseImageMemoryBindInfo) (unpacked *C.VkSparseImageMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageMemoryBindInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageMemoryBindInfo)(h.Data)
	return
}

// packSSparseBufferMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseBufferMemoryBindInfo(v []SparseBufferMemoryBindInfo, ptr0 *C.VkSparseBufferMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseBufferMemoryBindInfoValue]C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseBufferMemoryBindInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSSparseImageOpaqueMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseImageOpaqueMemoryBindInfo(v []SparseImageOpaqueMemoryBindInfo, ptr0 *C.VkSparseImageOpaqueMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageOpaqueMemoryBindInfoValue]C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageOpaqueMemoryBindInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSSparseImageMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryBindInfo(v []SparseImageMemoryBindInfo, ptr0 *C.VkSparseImageMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryBindInfoValue]C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryBindInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindSparseInfo) Ref() *C.VkBindSparseInfo {
	if x == nil {
		return nil
	}
	return x.refb0cbe910
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindSparseInfo) Free() {
	if x != nil && x.allocsb0cbe910 != nil {
		x.allocsb0cbe910.(*cgoAllocMap).Free()
		x.refb0cbe910 = nil
	}
}

// NewBindSparseInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindSparseInfoRef(ref unsafe.Pointer) *BindSparseInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindSparseInfo)
	obj.refb0cbe910 = (*C.VkBindSparseInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindSparseInfo) PassRef() (*C.VkBindSparseInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb0cbe910 != nil {
		return x.refb0cbe910, nil
	}
	memb0cbe910 := allocBindSparseInfoMemory(1)
	refb0cbe910 := (*C.VkBindSparseInfo)(memb0cbe910)
	allocsb0cbe910 := new(cgoAllocMap)
	allocsb0cbe910.Add(memb0cbe910)

	var csType_allocs *cgoAllocMap
	refb0cbe910.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb0cbe910.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb0cbe910.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	refb0cbe910.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphores_allocs *cgoAllocMap
	refb0cbe910.pWaitSemaphores, cpWaitSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)).Data)), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cpWaitSemaphores_allocs)

	var cbufferBindCount_allocs *cgoAllocMap
	refb0cbe910.bufferBindCount, cbufferBindCount_allocs = (C.uint32_t)(x.BufferBindCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cbufferBindCount_allocs)

	var cpBufferBinds_allocs *cgoAllocMap
	refb0cbe910.pBufferBinds, cpBufferBinds_allocs = unpackSSparseBufferMemoryBindInfo(x.PBufferBinds)
	allocsb0cbe910.Borrow(cpBufferBinds_allocs)

	var cimageOpaqueBindCount_allocs *cgoAllocMap
	refb0cbe910.imageOpaqueBindCount, cimageOpaqueBindCount_allocs = (C.uint32_t)(x.ImageOpaqueBindCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cimageOpaqueBindCount_allocs)

	var cpImageOpaqueBinds_allocs *cgoAllocMap
	refb0cbe910.pImageOpaqueBinds, cpImageOpaqueBinds_allocs = unpackSSparseImageOpaqueMemoryBindInfo(x.PImageOpaqueBinds)
	allocsb0cbe910.Borrow(cpImageOpaqueBinds_allocs)

	var cimageBindCount_allocs *cgoAllocMap
	refb0cbe910.imageBindCount, cimageBindCount_allocs = (C.uint32_t)(x.ImageBindCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cimageBindCount_allocs)

	var cpImageBinds_allocs *cgoAllocMap
	refb0cbe910.pImageBinds, cpImageBinds_allocs = unpackSSparseImageMemoryBindInfo(x.PImageBinds)
	allocsb0cbe910.Borrow(cpImageBinds_allocs)

	var csignalSemaphoreCount_allocs *cgoAllocMap
	refb0cbe910.signalSemaphoreCount, csignalSemaphoreCount_allocs = (C.uint32_t)(x.SignalSemaphoreCount), cgoAllocsUnknown
	allocsb0cbe910.Borrow(csignalSemaphoreCount_allocs)

	var cpSignalSemaphores_allocs *cgoAllocMap
	refb0cbe910.pSignalSemaphores, cpSignalSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores)).Data)), cgoAllocsUnknown
	allocsb0cbe910.Borrow(cpSignalSemaphores_allocs)

	x.refb0cbe910 = refb0cbe910
	x.allocsb0cbe910 = allocsb0cbe910
	return refb0cbe910, allocsb0cbe910

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindSparseInfo) PassValue() (C.VkBindSparseInfo, *cgoAllocMap) {
	if x.refb0cbe910 != nil {
		return *x.refb0cbe910, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindSparseInfo) Deref() {
	if x.refb0cbe910 == nil {
		return
	}
	x.SType = (StructureType)(x.refb0cbe910.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb0cbe910.pNext))
	x.WaitSemaphoreCount = (uint32)(x.refb0cbe910.waitSemaphoreCount)
	hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxfa3f05c.Data = unsafe.Pointer(x.refb0cbe910.pWaitSemaphores)
	hxfa3f05c.Cap = 0x7fffffff
	// hxfa3f05c.Len = ?

	x.BufferBindCount = (uint32)(x.refb0cbe910.bufferBindCount)
	packSSparseBufferMemoryBindInfo(x.PBufferBinds, x.refb0cbe910.pBufferBinds)
	x.ImageOpaqueBindCount = (uint32)(x.refb0cbe910.imageOpaqueBindCount)
	packSSparseImageOpaqueMemoryBindInfo(x.PImageOpaqueBinds, x.refb0cbe910.pImageOpaqueBinds)
	x.ImageBindCount = (uint32)(x.refb0cbe910.imageBindCount)
	packSSparseImageMemoryBindInfo(x.PImageBinds, x.refb0cbe910.pImageBinds)
	x.SignalSemaphoreCount = (uint32)(x.refb0cbe910.signalSemaphoreCount)
	hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores))
	hxf0d18b7.Data = unsafe.Pointer(x.refb0cbe910.pSignalSemaphores)
	hxf0d18b7.Cap = 0x7fffffff
	// hxf0d18b7.Len = ?

}

// allocFenceCreateInfoMemory allocates memory for type C.VkFenceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFenceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFenceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFenceCreateInfoValue = unsafe.Sizeof([1]C.VkFenceCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FenceCreateInfo) Ref() *C.VkFenceCreateInfo {
	if x == nil {
		return nil
	}
	return x.refb8ff4840
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FenceCreateInfo) Free() {
	if x != nil && x.allocsb8ff4840 != nil {
		x.allocsb8ff4840.(*cgoAllocMap).Free()
		x.refb8ff4840 = nil
	}
}

// NewFenceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFenceCreateInfoRef(ref unsafe.Pointer) *FenceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(FenceCreateInfo)
	obj.refb8ff4840 = (*C.VkFenceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FenceCreateInfo) PassRef() (*C.VkFenceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8ff4840 != nil {
		return x.refb8ff4840, nil
	}
	memb8ff4840 := allocFenceCreateInfoMemory(1)
	refb8ff4840 := (*C.VkFenceCreateInfo)(memb8ff4840)
	allocsb8ff4840 := new(cgoAllocMap)
	allocsb8ff4840.Add(memb8ff4840)

	var csType_allocs *cgoAllocMap
	refb8ff4840.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb8ff4840.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb8ff4840.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb8ff4840.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refb8ff4840.flags, cflags_allocs = (C.VkFenceCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsb8ff4840.Borrow(cflags_allocs)

	x.refb8ff4840 = refb8ff4840
	x.allocsb8ff4840 = allocsb8ff4840
	return refb8ff4840, allocsb8ff4840

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FenceCreateInfo) PassValue() (C.VkFenceCreateInfo, *cgoAllocMap) {
	if x.refb8ff4840 != nil {
		return *x.refb8ff4840, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FenceCreateInfo) Deref() {
	if x.refb8ff4840 == nil {
		return
	}
	x.SType = (StructureType)(x.refb8ff4840.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb8ff4840.pNext))
	x.Flags = (FenceCreateFlags)(x.refb8ff4840.flags)
}

// allocSemaphoreCreateInfoMemory allocates memory for type C.VkSemaphoreCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSemaphoreCreateInfoValue = unsafe.Sizeof([1]C.VkSemaphoreCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SemaphoreCreateInfo) Ref() *C.VkSemaphoreCreateInfo {
	if x == nil {
		return nil
	}
	return x.reff130cd2b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SemaphoreCreateInfo) Free() {
	if x != nil && x.allocsf130cd2b != nil {
		x.allocsf130cd2b.(*cgoAllocMap).Free()
		x.reff130cd2b = nil
	}
}

// NewSemaphoreCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSemaphoreCreateInfoRef(ref unsafe.Pointer) *SemaphoreCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SemaphoreCreateInfo)
	obj.reff130cd2b = (*C.VkSemaphoreCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SemaphoreCreateInfo) PassRef() (*C.VkSemaphoreCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff130cd2b != nil {
		return x.reff130cd2b, nil
	}
	memf130cd2b := allocSemaphoreCreateInfoMemory(1)
	reff130cd2b := (*C.VkSemaphoreCreateInfo)(memf130cd2b)
	allocsf130cd2b := new(cgoAllocMap)
	allocsf130cd2b.Add(memf130cd2b)

	var csType_allocs *cgoAllocMap
	reff130cd2b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf130cd2b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff130cd2b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf130cd2b.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reff130cd2b.flags, cflags_allocs = (C.VkSemaphoreCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsf130cd2b.Borrow(cflags_allocs)

	x.reff130cd2b = reff130cd2b
	x.allocsf130cd2b = allocsf130cd2b
	return reff130cd2b, allocsf130cd2b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SemaphoreCreateInfo) PassValue() (C.VkSemaphoreCreateInfo, *cgoAllocMap) {
	if x.reff130cd2b != nil {
		return *x.reff130cd2b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SemaphoreCreateInfo) Deref() {
	if x.reff130cd2b == nil {
		return
	}
	x.SType = (StructureType)(x.reff130cd2b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff130cd2b.pNext))
	x.Flags = (SemaphoreCreateFlags)(x.reff130cd2b.flags)
}

// allocEventCreateInfoMemory allocates memory for type C.VkEventCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventCreateInfoValue = unsafe.Sizeof([1]C.VkEventCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EventCreateInfo) Ref() *C.VkEventCreateInfo {
	if x == nil {
		return nil
	}
	return x.refa54f9ec8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EventCreateInfo) Free() {
	if x != nil && x.allocsa54f9ec8 != nil {
		x.allocsa54f9ec8.(*cgoAllocMap).Free()
		x.refa54f9ec8 = nil
	}
}

// NewEventCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEventCreateInfoRef(ref unsafe.Pointer) *EventCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(EventCreateInfo)
	obj.refa54f9ec8 = (*C.VkEventCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EventCreateInfo) PassRef() (*C.VkEventCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa54f9ec8 != nil {
		return x.refa54f9ec8, nil
	}
	mema54f9ec8 := allocEventCreateInfoMemory(1)
	refa54f9ec8 := (*C.VkEventCreateInfo)(mema54f9ec8)
	allocsa54f9ec8 := new(cgoAllocMap)
	allocsa54f9ec8.Add(mema54f9ec8)

	var csType_allocs *cgoAllocMap
	refa54f9ec8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa54f9ec8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa54f9ec8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa54f9ec8.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refa54f9ec8.flags, cflags_allocs = (C.VkEventCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsa54f9ec8.Borrow(cflags_allocs)

	x.refa54f9ec8 = refa54f9ec8
	x.allocsa54f9ec8 = allocsa54f9ec8
	return refa54f9ec8, allocsa54f9ec8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EventCreateInfo) PassValue() (C.VkEventCreateInfo, *cgoAllocMap) {
	if x.refa54f9ec8 != nil {
		return *x.refa54f9ec8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EventCreateInfo) Deref() {
	if x.refa54f9ec8 == nil {
		return
	}
	x.SType = (StructureType)(x.refa54f9ec8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa54f9ec8.pNext))
	x.Flags = (EventCreateFlags)(x.refa54f9ec8.flags)
}

// allocQueryPoolCreateInfoMemory allocates memory for type C.VkQueryPoolCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueryPoolCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueryPoolCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfQueryPoolCreateInfoValue = unsafe.Sizeof([1]C.VkQueryPoolCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueryPoolCreateInfo) Ref() *C.VkQueryPoolCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref85dfcd4a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueryPoolCreateInfo) Free() {
	if x != nil && x.allocs85dfcd4a != nil {
		x.allocs85dfcd4a.(*cgoAllocMap).Free()
		x.ref85dfcd4a = nil
	}
}

// NewQueryPoolCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueryPoolCreateInfoRef(ref unsafe.Pointer) *QueryPoolCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(QueryPoolCreateInfo)
	obj.ref85dfcd4a = (*C.VkQueryPoolCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueryPoolCreateInfo) PassRef() (*C.VkQueryPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85dfcd4a != nil {
		return x.ref85dfcd4a, nil
	}
	mem85dfcd4a := allocQueryPoolCreateInfoMemory(1)
	ref85dfcd4a := (*C.VkQueryPoolCreateInfo)(mem85dfcd4a)
	allocs85dfcd4a := new(cgoAllocMap)
	allocs85dfcd4a.Add(mem85dfcd4a)

	var csType_allocs *cgoAllocMap
	ref85dfcd4a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref85dfcd4a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref85dfcd4a.flags, cflags_allocs = (C.VkQueryPoolCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cflags_allocs)

	var cqueryType_allocs *cgoAllocMap
	ref85dfcd4a.queryType, cqueryType_allocs = (C.VkQueryType)(x.QueryType), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cqueryType_allocs)

	var cqueryCount_allocs *cgoAllocMap
	ref85dfcd4a.queryCount, cqueryCount_allocs = (C.uint32_t)(x.QueryCount), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cqueryCount_allocs)

	var cpipelineStatistics_allocs *cgoAllocMap
	ref85dfcd4a.pipelineStatistics, cpipelineStatistics_allocs = (C.VkQueryPipelineStatisticFlags)(x.PipelineStatistics), cgoAllocsUnknown
	allocs85dfcd4a.Borrow(cpipelineStatistics_allocs)

	x.ref85dfcd4a = ref85dfcd4a
	x.allocs85dfcd4a = allocs85dfcd4a
	return ref85dfcd4a, allocs85dfcd4a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueryPoolCreateInfo) PassValue() (C.VkQueryPoolCreateInfo, *cgoAllocMap) {
	if x.ref85dfcd4a != nil {
		return *x.ref85dfcd4a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueryPoolCreateInfo) Deref() {
	if x.ref85dfcd4a == nil {
		return
	}
	x.SType = (StructureType)(x.ref85dfcd4a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref85dfcd4a.pNext))
	x.Flags = (QueryPoolCreateFlags)(x.ref85dfcd4a.flags)
	x.QueryType = (QueryType)(x.ref85dfcd4a.queryType)
	x.QueryCount = (uint32)(x.ref85dfcd4a.queryCount)
	x.PipelineStatistics = (QueryPipelineStatisticFlags)(x.ref85dfcd4a.pipelineStatistics)
}

// allocBufferCreateInfoMemory allocates memory for type C.VkBufferCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferCreateInfoValue = unsafe.Sizeof([1]C.VkBufferCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferCreateInfo) Ref() *C.VkBufferCreateInfo {
	if x == nil {
		return nil
	}
	return x.reffe19d2cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferCreateInfo) Free() {
	if x != nil && x.allocsfe19d2cd != nil {
		x.allocsfe19d2cd.(*cgoAllocMap).Free()
		x.reffe19d2cd = nil
	}
}

// NewBufferCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferCreateInfoRef(ref unsafe.Pointer) *BufferCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(BufferCreateInfo)
	obj.reffe19d2cd = (*C.VkBufferCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferCreateInfo) PassRef() (*C.VkBufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe19d2cd != nil {
		return x.reffe19d2cd, nil
	}
	memfe19d2cd := allocBufferCreateInfoMemory(1)
	reffe19d2cd := (*C.VkBufferCreateInfo)(memfe19d2cd)
	allocsfe19d2cd := new(cgoAllocMap)
	allocsfe19d2cd.Add(memfe19d2cd)

	var csType_allocs *cgoAllocMap
	reffe19d2cd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffe19d2cd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reffe19d2cd.flags, cflags_allocs = (C.VkBufferCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cflags_allocs)

	var csize_allocs *cgoAllocMap
	reffe19d2cd.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(csize_allocs)

	var cusage_allocs *cgoAllocMap
	reffe19d2cd.usage, cusage_allocs = (C.VkBufferUsageFlags)(x.Usage), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cusage_allocs)

	var csharingMode_allocs *cgoAllocMap
	reffe19d2cd.sharingMode, csharingMode_allocs = (C.VkSharingMode)(x.SharingMode), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(csharingMode_allocs)

	var cqueueFamilyIndexCount_allocs *cgoAllocMap
	reffe19d2cd.queueFamilyIndexCount, cqueueFamilyIndexCount_allocs = (C.uint32_t)(x.QueueFamilyIndexCount), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cqueueFamilyIndexCount_allocs)

	var cpQueueFamilyIndices_allocs *cgoAllocMap
	reffe19d2cd.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)).Data)), cgoAllocsUnknown
	allocsfe19d2cd.Borrow(cpQueueFamilyIndices_allocs)

	x.reffe19d2cd = reffe19d2cd
	x.allocsfe19d2cd = allocsfe19d2cd
	return reffe19d2cd, allocsfe19d2cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferCreateInfo) PassValue() (C.VkBufferCreateInfo, *cgoAllocMap) {
	if x.reffe19d2cd != nil {
		return *x.reffe19d2cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferCreateInfo) Deref() {
	if x.reffe19d2cd == nil {
		return
	}
	x.SType = (StructureType)(x.reffe19d2cd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe19d2cd.pNext))
	x.Flags = (BufferCreateFlags)(x.reffe19d2cd.flags)
	x.Size = (DeviceSize)(x.reffe19d2cd.size)
	x.Usage = (BufferUsageFlags)(x.reffe19d2cd.usage)
	x.SharingMode = (SharingMode)(x.reffe19d2cd.sharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.reffe19d2cd.queueFamilyIndexCount)
	hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf2fab0d.Data = unsafe.Pointer(x.reffe19d2cd.pQueueFamilyIndices)
	hxf2fab0d.Cap = 0x7fffffff
	// hxf2fab0d.Len = ?

}

// allocBufferViewCreateInfoMemory allocates memory for type C.VkBufferViewCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferViewCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferViewCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferViewCreateInfoValue = unsafe.Sizeof([1]C.VkBufferViewCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferViewCreateInfo) Ref() *C.VkBufferViewCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref49b97027
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferViewCreateInfo) Free() {
	if x != nil && x.allocs49b97027 != nil {
		x.allocs49b97027.(*cgoAllocMap).Free()
		x.ref49b97027 = nil
	}
}

// NewBufferViewCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferViewCreateInfoRef(ref unsafe.Pointer) *BufferViewCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(BufferViewCreateInfo)
	obj.ref49b97027 = (*C.VkBufferViewCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferViewCreateInfo) PassRef() (*C.VkBufferViewCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref49b97027 != nil {
		return x.ref49b97027, nil
	}
	mem49b97027 := allocBufferViewCreateInfoMemory(1)
	ref49b97027 := (*C.VkBufferViewCreateInfo)(mem49b97027)
	allocs49b97027 := new(cgoAllocMap)
	allocs49b97027.Add(mem49b97027)

	var csType_allocs *cgoAllocMap
	ref49b97027.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs49b97027.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref49b97027.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs49b97027.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref49b97027.flags, cflags_allocs = (C.VkBufferViewCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs49b97027.Borrow(cflags_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref49b97027.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs49b97027.Borrow(cbuffer_allocs)

	var cformat_allocs *cgoAllocMap
	ref49b97027.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs49b97027.Borrow(cformat_allocs)

	var coffset_allocs *cgoAllocMap
	ref49b97027.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs49b97027.Borrow(coffset_allocs)

	var c_range_allocs *cgoAllocMap
	ref49b97027._range, c_range_allocs = (C.VkDeviceSize)(x.Range), cgoAllocsUnknown
	allocs49b97027.Borrow(c_range_allocs)

	x.ref49b97027 = ref49b97027
	x.allocs49b97027 = allocs49b97027
	return ref49b97027, allocs49b97027

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferViewCreateInfo) PassValue() (C.VkBufferViewCreateInfo, *cgoAllocMap) {
	if x.ref49b97027 != nil {
		return *x.ref49b97027, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferViewCreateInfo) Deref() {
	if x.ref49b97027 == nil {
		return
	}
	x.SType = (StructureType)(x.ref49b97027.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref49b97027.pNext))
	x.Flags = (BufferViewCreateFlags)(x.ref49b97027.flags)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref49b97027.buffer))
	x.Format = (Format)(x.ref49b97027.format)
	x.Offset = (DeviceSize)(x.ref49b97027.offset)
	x.Range = (DeviceSize)(x.ref49b97027._range)
}

// allocImageCreateInfoMemory allocates memory for type C.VkImageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageCreateInfoValue = unsafe.Sizeof([1]C.VkImageCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageCreateInfo) Ref() *C.VkImageCreateInfo {
	if x == nil {
		return nil
	}
	return x.reffb587ba1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageCreateInfo) Free() {
	if x != nil && x.allocsfb587ba1 != nil {
		x.allocsfb587ba1.(*cgoAllocMap).Free()
		x.reffb587ba1 = nil
	}
}

// NewImageCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageCreateInfoRef(ref unsafe.Pointer) *ImageCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageCreateInfo)
	obj.reffb587ba1 = (*C.VkImageCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageCreateInfo) PassRef() (*C.VkImageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffb587ba1 != nil {
		return x.reffb587ba1, nil
	}
	memfb587ba1 := allocImageCreateInfoMemory(1)
	reffb587ba1 := (*C.VkImageCreateInfo)(memfb587ba1)
	allocsfb587ba1 := new(cgoAllocMap)
	allocsfb587ba1.Add(memfb587ba1)

	var csType_allocs *cgoAllocMap
	reffb587ba1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfb587ba1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffb587ba1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reffb587ba1.flags, cflags_allocs = (C.VkImageCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cflags_allocs)

	var cimageType_allocs *cgoAllocMap
	reffb587ba1.imageType, cimageType_allocs = (C.VkImageType)(x.ImageType), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cimageType_allocs)

	var cformat_allocs *cgoAllocMap
	reffb587ba1.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cformat_allocs)

	var cextent_allocs *cgoAllocMap
	reffb587ba1.extent, cextent_allocs = x.Extent.PassValue()
	allocsfb587ba1.Borrow(cextent_allocs)

	var cmipLevels_allocs *cgoAllocMap
	reffb587ba1.mipLevels, cmipLevels_allocs = (C.uint32_t)(x.MipLevels), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cmipLevels_allocs)

	var carrayLayers_allocs *cgoAllocMap
	reffb587ba1.arrayLayers, carrayLayers_allocs = (C.uint32_t)(x.ArrayLayers), cgoAllocsUnknown
	allocsfb587ba1.Borrow(carrayLayers_allocs)

	var csamples_allocs *cgoAllocMap
	reffb587ba1.samples, csamples_allocs = (C.VkSampleCountFlagBits)(x.Samples), cgoAllocsUnknown
	allocsfb587ba1.Borrow(csamples_allocs)

	var ctiling_allocs *cgoAllocMap
	reffb587ba1.tiling, ctiling_allocs = (C.VkImageTiling)(x.Tiling), cgoAllocsUnknown
	allocsfb587ba1.Borrow(ctiling_allocs)

	var cusage_allocs *cgoAllocMap
	reffb587ba1.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cusage_allocs)

	var csharingMode_allocs *cgoAllocMap
	reffb587ba1.sharingMode, csharingMode_allocs = (C.VkSharingMode)(x.SharingMode), cgoAllocsUnknown
	allocsfb587ba1.Borrow(csharingMode_allocs)

	var cqueueFamilyIndexCount_allocs *cgoAllocMap
	reffb587ba1.queueFamilyIndexCount, cqueueFamilyIndexCount_allocs = (C.uint32_t)(x.QueueFamilyIndexCount), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cqueueFamilyIndexCount_allocs)

	var cpQueueFamilyIndices_allocs *cgoAllocMap
	reffb587ba1.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)).Data)), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cpQueueFamilyIndices_allocs)

	var cinitialLayout_allocs *cgoAllocMap
	reffb587ba1.initialLayout, cinitialLayout_allocs = (C.VkImageLayout)(x.InitialLayout), cgoAllocsUnknown
	allocsfb587ba1.Borrow(cinitialLayout_allocs)

	x.reffb587ba1 = reffb587ba1
	x.allocsfb587ba1 = allocsfb587ba1
	return reffb587ba1, allocsfb587ba1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageCreateInfo) PassValue() (C.VkImageCreateInfo, *cgoAllocMap) {
	if x.reffb587ba1 != nil {
		return *x.reffb587ba1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageCreateInfo) Deref() {
	if x.reffb587ba1 == nil {
		return
	}
	x.SType = (StructureType)(x.reffb587ba1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffb587ba1.pNext))
	x.Flags = (ImageCreateFlags)(x.reffb587ba1.flags)
	x.ImageType = (ImageType)(x.reffb587ba1.imageType)
	x.Format = (Format)(x.reffb587ba1.format)
	x.Extent = *NewExtent3DRef(unsafe.Pointer(&x.reffb587ba1.extent))
	x.MipLevels = (uint32)(x.reffb587ba1.mipLevels)
	x.ArrayLayers = (uint32)(x.reffb587ba1.arrayLayers)
	x.Samples = (SampleCountFlagBits)(x.reffb587ba1.samples)
	x.Tiling = (ImageTiling)(x.reffb587ba1.tiling)
	x.Usage = (ImageUsageFlags)(x.reffb587ba1.usage)
	x.SharingMode = (SharingMode)(x.reffb587ba1.sharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.reffb587ba1.queueFamilyIndexCount)
	hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf69fe70.Data = unsafe.Pointer(x.reffb587ba1.pQueueFamilyIndices)
	hxf69fe70.Cap = 0x7fffffff
	// hxf69fe70.Len = ?

	x.InitialLayout = (ImageLayout)(x.reffb587ba1.initialLayout)
}

// allocSubresourceLayoutMemory allocates memory for type C.VkSubresourceLayout in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubresourceLayoutMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubresourceLayoutValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubresourceLayoutValue = unsafe.Sizeof([1]C.VkSubresourceLayout{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubresourceLayout) Ref() *C.VkSubresourceLayout {
	if x == nil {
		return nil
	}
	return x.ref182612ad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubresourceLayout) Free() {
	if x != nil && x.allocs182612ad != nil {
		x.allocs182612ad.(*cgoAllocMap).Free()
		x.ref182612ad = nil
	}
}

// NewSubresourceLayoutRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubresourceLayoutRef(ref unsafe.Pointer) *SubresourceLayout {
	if ref == nil {
		return nil
	}
	obj := new(SubresourceLayout)
	obj.ref182612ad = (*C.VkSubresourceLayout)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubresourceLayout) PassRef() (*C.VkSubresourceLayout, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref182612ad != nil {
		return x.ref182612ad, nil
	}
	mem182612ad := allocSubresourceLayoutMemory(1)
	ref182612ad := (*C.VkSubresourceLayout)(mem182612ad)
	allocs182612ad := new(cgoAllocMap)
	allocs182612ad.Add(mem182612ad)

	var coffset_allocs *cgoAllocMap
	ref182612ad.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs182612ad.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref182612ad.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs182612ad.Borrow(csize_allocs)

	var crowPitch_allocs *cgoAllocMap
	ref182612ad.rowPitch, crowPitch_allocs = (C.VkDeviceSize)(x.RowPitch), cgoAllocsUnknown
	allocs182612ad.Borrow(crowPitch_allocs)

	var carrayPitch_allocs *cgoAllocMap
	ref182612ad.arrayPitch, carrayPitch_allocs = (C.VkDeviceSize)(x.ArrayPitch), cgoAllocsUnknown
	allocs182612ad.Borrow(carrayPitch_allocs)

	var cdepthPitch_allocs *cgoAllocMap
	ref182612ad.depthPitch, cdepthPitch_allocs = (C.VkDeviceSize)(x.DepthPitch), cgoAllocsUnknown
	allocs182612ad.Borrow(cdepthPitch_allocs)

	x.ref182612ad = ref182612ad
	x.allocs182612ad = allocs182612ad
	return ref182612ad, allocs182612ad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubresourceLayout) PassValue() (C.VkSubresourceLayout, *cgoAllocMap) {
	if x.ref182612ad != nil {
		return *x.ref182612ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubresourceLayout) Deref() {
	if x.ref182612ad == nil {
		return
	}
	x.Offset = (DeviceSize)(x.ref182612ad.offset)
	x.Size = (DeviceSize)(x.ref182612ad.size)
	x.RowPitch = (DeviceSize)(x.ref182612ad.rowPitch)
	x.ArrayPitch = (DeviceSize)(x.ref182612ad.arrayPitch)
	x.DepthPitch = (DeviceSize)(x.ref182612ad.depthPitch)
}

// allocComponentMappingMemory allocates memory for type C.VkComponentMapping in C.
// The caller is responsible for freeing the this memory via C.free.
func allocComponentMappingMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfComponentMappingValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfComponentMappingValue = unsafe.Sizeof([1]C.VkComponentMapping{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ComponentMapping) Ref() *C.VkComponentMapping {
	if x == nil {
		return nil
	}
	return x.ref63d3d563
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ComponentMapping) Free() {
	if x != nil && x.allocs63d3d563 != nil {
		x.allocs63d3d563.(*cgoAllocMap).Free()
		x.ref63d3d563 = nil
	}
}

// NewComponentMappingRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewComponentMappingRef(ref unsafe.Pointer) *ComponentMapping {
	if ref == nil {
		return nil
	}
	obj := new(ComponentMapping)
	obj.ref63d3d563 = (*C.VkComponentMapping)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ComponentMapping) PassRef() (*C.VkComponentMapping, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref63d3d563 != nil {
		return x.ref63d3d563, nil
	}
	mem63d3d563 := allocComponentMappingMemory(1)
	ref63d3d563 := (*C.VkComponentMapping)(mem63d3d563)
	allocs63d3d563 := new(cgoAllocMap)
	allocs63d3d563.Add(mem63d3d563)

	var cr_allocs *cgoAllocMap
	ref63d3d563.r, cr_allocs = (C.VkComponentSwizzle)(x.R), cgoAllocsUnknown
	allocs63d3d563.Borrow(cr_allocs)

	var cg_allocs *cgoAllocMap
	ref63d3d563.g, cg_allocs = (C.VkComponentSwizzle)(x.G), cgoAllocsUnknown
	allocs63d3d563.Borrow(cg_allocs)

	var cb_allocs *cgoAllocMap
	ref63d3d563.b, cb_allocs = (C.VkComponentSwizzle)(x.B), cgoAllocsUnknown
	allocs63d3d563.Borrow(cb_allocs)

	var ca_allocs *cgoAllocMap
	ref63d3d563.a, ca_allocs = (C.VkComponentSwizzle)(x.A), cgoAllocsUnknown
	allocs63d3d563.Borrow(ca_allocs)

	x.ref63d3d563 = ref63d3d563
	x.allocs63d3d563 = allocs63d3d563
	return ref63d3d563, allocs63d3d563

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ComponentMapping) PassValue() (C.VkComponentMapping, *cgoAllocMap) {
	if x.ref63d3d563 != nil {
		return *x.ref63d3d563, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ComponentMapping) Deref() {
	if x.ref63d3d563 == nil {
		return
	}
	x.R = (ComponentSwizzle)(x.ref63d3d563.r)
	x.G = (ComponentSwizzle)(x.ref63d3d563.g)
	x.B = (ComponentSwizzle)(x.ref63d3d563.b)
	x.A = (ComponentSwizzle)(x.ref63d3d563.a)
}

// allocImageSubresourceRangeMemory allocates memory for type C.VkImageSubresourceRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSubresourceRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSubresourceRangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageSubresourceRangeValue = unsafe.Sizeof([1]C.VkImageSubresourceRange{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSubresourceRange) Ref() *C.VkImageSubresourceRange {
	if x == nil {
		return nil
	}
	return x.ref5aa1126
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSubresourceRange) Free() {
	if x != nil && x.allocs5aa1126 != nil {
		x.allocs5aa1126.(*cgoAllocMap).Free()
		x.ref5aa1126 = nil
	}
}

// NewImageSubresourceRangeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSubresourceRangeRef(ref unsafe.Pointer) *ImageSubresourceRange {
	if ref == nil {
		return nil
	}
	obj := new(ImageSubresourceRange)
	obj.ref5aa1126 = (*C.VkImageSubresourceRange)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSubresourceRange) PassRef() (*C.VkImageSubresourceRange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5aa1126 != nil {
		return x.ref5aa1126, nil
	}
	mem5aa1126 := allocImageSubresourceRangeMemory(1)
	ref5aa1126 := (*C.VkImageSubresourceRange)(mem5aa1126)
	allocs5aa1126 := new(cgoAllocMap)
	allocs5aa1126.Add(mem5aa1126)

	var caspectMask_allocs *cgoAllocMap
	ref5aa1126.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs5aa1126.Borrow(caspectMask_allocs)

	var cbaseMipLevel_allocs *cgoAllocMap
	ref5aa1126.baseMipLevel, cbaseMipLevel_allocs = (C.uint32_t)(x.BaseMipLevel), cgoAllocsUnknown
	allocs5aa1126.Borrow(cbaseMipLevel_allocs)

	var clevelCount_allocs *cgoAllocMap
	ref5aa1126.levelCount, clevelCount_allocs = (C.uint32_t)(x.LevelCount), cgoAllocsUnknown
	allocs5aa1126.Borrow(clevelCount_allocs)

	var cbaseArrayLayer_allocs *cgoAllocMap
	ref5aa1126.baseArrayLayer, cbaseArrayLayer_allocs = (C.uint32_t)(x.BaseArrayLayer), cgoAllocsUnknown
	allocs5aa1126.Borrow(cbaseArrayLayer_allocs)

	var clayerCount_allocs *cgoAllocMap
	ref5aa1126.layerCount, clayerCount_allocs = (C.uint32_t)(x.LayerCount), cgoAllocsUnknown
	allocs5aa1126.Borrow(clayerCount_allocs)

	x.ref5aa1126 = ref5aa1126
	x.allocs5aa1126 = allocs5aa1126
	return ref5aa1126, allocs5aa1126

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSubresourceRange) PassValue() (C.VkImageSubresourceRange, *cgoAllocMap) {
	if x.ref5aa1126 != nil {
		return *x.ref5aa1126, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSubresourceRange) Deref() {
	if x.ref5aa1126 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.ref5aa1126.aspectMask)
	x.BaseMipLevel = (uint32)(x.ref5aa1126.baseMipLevel)
	x.LevelCount = (uint32)(x.ref5aa1126.levelCount)
	x.BaseArrayLayer = (uint32)(x.ref5aa1126.baseArrayLayer)
	x.LayerCount = (uint32)(x.ref5aa1126.layerCount)
}

// allocImageViewCreateInfoMemory allocates memory for type C.VkImageViewCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageViewCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageViewCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageViewCreateInfoValue = unsafe.Sizeof([1]C.VkImageViewCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageViewCreateInfo) Ref() *C.VkImageViewCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref77e8d4b8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageViewCreateInfo) Free() {
	if x != nil && x.allocs77e8d4b8 != nil {
		x.allocs77e8d4b8.(*cgoAllocMap).Free()
		x.ref77e8d4b8 = nil
	}
}

// NewImageViewCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageViewCreateInfoRef(ref unsafe.Pointer) *ImageViewCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageViewCreateInfo)
	obj.ref77e8d4b8 = (*C.VkImageViewCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageViewCreateInfo) PassRef() (*C.VkImageViewCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref77e8d4b8 != nil {
		return x.ref77e8d4b8, nil
	}
	mem77e8d4b8 := allocImageViewCreateInfoMemory(1)
	ref77e8d4b8 := (*C.VkImageViewCreateInfo)(mem77e8d4b8)
	allocs77e8d4b8 := new(cgoAllocMap)
	allocs77e8d4b8.Add(mem77e8d4b8)

	var csType_allocs *cgoAllocMap
	ref77e8d4b8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref77e8d4b8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref77e8d4b8.flags, cflags_allocs = (C.VkImageViewCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cflags_allocs)

	var cimage_allocs *cgoAllocMap
	ref77e8d4b8.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cimage_allocs)

	var cviewType_allocs *cgoAllocMap
	ref77e8d4b8.viewType, cviewType_allocs = (C.VkImageViewType)(x.ViewType), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cviewType_allocs)

	var cformat_allocs *cgoAllocMap
	ref77e8d4b8.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs77e8d4b8.Borrow(cformat_allocs)

	var ccomponents_allocs *cgoAllocMap
	ref77e8d4b8.components, ccomponents_allocs = x.Components.PassValue()
	allocs77e8d4b8.Borrow(ccomponents_allocs)

	var csubresourceRange_allocs *cgoAllocMap
	ref77e8d4b8.subresourceRange, csubresourceRange_allocs = x.SubresourceRange.PassValue()
	allocs77e8d4b8.Borrow(csubresourceRange_allocs)

	x.ref77e8d4b8 = ref77e8d4b8
	x.allocs77e8d4b8 = allocs77e8d4b8
	return ref77e8d4b8, allocs77e8d4b8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageViewCreateInfo) PassValue() (C.VkImageViewCreateInfo, *cgoAllocMap) {
	if x.ref77e8d4b8 != nil {
		return *x.ref77e8d4b8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageViewCreateInfo) Deref() {
	if x.ref77e8d4b8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref77e8d4b8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref77e8d4b8.pNext))
	x.Flags = (ImageViewCreateFlags)(x.ref77e8d4b8.flags)
	x.Image = *(*Image)(unsafe.Pointer(&x.ref77e8d4b8.image))
	x.ViewType = (ImageViewType)(x.ref77e8d4b8.viewType)
	x.Format = (Format)(x.ref77e8d4b8.format)
	x.Components = *NewComponentMappingRef(unsafe.Pointer(&x.ref77e8d4b8.components))
	x.SubresourceRange = *NewImageSubresourceRangeRef(unsafe.Pointer(&x.ref77e8d4b8.subresourceRange))
}

// allocShaderModuleCreateInfoMemory allocates memory for type C.VkShaderModuleCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderModuleCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderModuleCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaderModuleCreateInfoValue = unsafe.Sizeof([1]C.VkShaderModuleCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShaderModuleCreateInfo) Ref() *C.VkShaderModuleCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc663d23e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShaderModuleCreateInfo) Free() {
	if x != nil && x.allocsc663d23e != nil {
		x.allocsc663d23e.(*cgoAllocMap).Free()
		x.refc663d23e = nil
	}
}

// NewShaderModuleCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderModuleCreateInfoRef(ref unsafe.Pointer) *ShaderModuleCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ShaderModuleCreateInfo)
	obj.refc663d23e = (*C.VkShaderModuleCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShaderModuleCreateInfo) PassRef() (*C.VkShaderModuleCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc663d23e != nil {
		return x.refc663d23e, nil
	}
	memc663d23e := allocShaderModuleCreateInfoMemory(1)
	refc663d23e := (*C.VkShaderModuleCreateInfo)(memc663d23e)
	allocsc663d23e := new(cgoAllocMap)
	allocsc663d23e.Add(memc663d23e)

	var csType_allocs *cgoAllocMap
	refc663d23e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc663d23e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc663d23e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc663d23e.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc663d23e.flags, cflags_allocs = (C.VkShaderModuleCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsc663d23e.Borrow(cflags_allocs)

	var ccodeSize_allocs *cgoAllocMap
	refc663d23e.codeSize, ccodeSize_allocs = (C.size_t)(x.CodeSize), cgoAllocsUnknown
	allocsc663d23e.Borrow(ccodeSize_allocs)

	var cpCode_allocs *cgoAllocMap
	refc663d23e.pCode, cpCode_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCode)).Data)), cgoAllocsUnknown
	allocsc663d23e.Borrow(cpCode_allocs)

	x.refc663d23e = refc663d23e
	x.allocsc663d23e = allocsc663d23e
	return refc663d23e, allocsc663d23e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShaderModuleCreateInfo) PassValue() (C.VkShaderModuleCreateInfo, *cgoAllocMap) {
	if x.refc663d23e != nil {
		return *x.refc663d23e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShaderModuleCreateInfo) Deref() {
	if x.refc663d23e == nil {
		return
	}
	x.SType = (StructureType)(x.refc663d23e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc663d23e.pNext))
	x.Flags = (ShaderModuleCreateFlags)(x.refc663d23e.flags)
	x.CodeSize = (uint64)(x.refc663d23e.codeSize)
	hxf65bf54 := (*sliceHeader)(unsafe.Pointer(&x.PCode))
	hxf65bf54.Data = unsafe.Pointer(x.refc663d23e.pCode)
	hxf65bf54.Cap = 0x7fffffff
	// hxf65bf54.Len = ?

}

// allocPipelineCacheCreateInfoMemory allocates memory for type C.VkPipelineCacheCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCacheCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCacheCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineCacheCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineCacheCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineCacheCreateInfo) Ref() *C.VkPipelineCacheCreateInfo {
	if x == nil {
		return nil
	}
	return x.reff11e7dd1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineCacheCreateInfo) Free() {
	if x != nil && x.allocsf11e7dd1 != nil {
		x.allocsf11e7dd1.(*cgoAllocMap).Free()
		x.reff11e7dd1 = nil
	}
}

// NewPipelineCacheCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineCacheCreateInfoRef(ref unsafe.Pointer) *PipelineCacheCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineCacheCreateInfo)
	obj.reff11e7dd1 = (*C.VkPipelineCacheCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineCacheCreateInfo) PassRef() (*C.VkPipelineCacheCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff11e7dd1 != nil {
		return x.reff11e7dd1, nil
	}
	memf11e7dd1 := allocPipelineCacheCreateInfoMemory(1)
	reff11e7dd1 := (*C.VkPipelineCacheCreateInfo)(memf11e7dd1)
	allocsf11e7dd1 := new(cgoAllocMap)
	allocsf11e7dd1.Add(memf11e7dd1)

	var csType_allocs *cgoAllocMap
	reff11e7dd1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff11e7dd1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	reff11e7dd1.flags, cflags_allocs = (C.VkPipelineCacheCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cflags_allocs)

	var cinitialDataSize_allocs *cgoAllocMap
	reff11e7dd1.initialDataSize, cinitialDataSize_allocs = (C.size_t)(x.InitialDataSize), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cinitialDataSize_allocs)

	var cpInitialData_allocs *cgoAllocMap
	reff11e7dd1.pInitialData, cpInitialData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PInitialData)), cgoAllocsUnknown
	allocsf11e7dd1.Borrow(cpInitialData_allocs)

	x.reff11e7dd1 = reff11e7dd1
	x.allocsf11e7dd1 = allocsf11e7dd1
	return reff11e7dd1, allocsf11e7dd1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineCacheCreateInfo) PassValue() (C.VkPipelineCacheCreateInfo, *cgoAllocMap) {
	if x.reff11e7dd1 != nil {
		return *x.reff11e7dd1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineCacheCreateInfo) Deref() {
	if x.reff11e7dd1 == nil {
		return
	}
	x.SType = (StructureType)(x.reff11e7dd1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff11e7dd1.pNext))
	x.Flags = (PipelineCacheCreateFlags)(x.reff11e7dd1.flags)
	x.InitialDataSize = (uint64)(x.reff11e7dd1.initialDataSize)
	x.PInitialData = (unsafe.Pointer)(unsafe.Pointer(x.reff11e7dd1.pInitialData))
}

// allocSpecializationMapEntryMemory allocates memory for type C.VkSpecializationMapEntry in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSpecializationMapEntryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSpecializationMapEntryValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSpecializationMapEntryValue = unsafe.Sizeof([1]C.VkSpecializationMapEntry{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SpecializationMapEntry) Ref() *C.VkSpecializationMapEntry {
	if x == nil {
		return nil
	}
	return x.ref2fd815d1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SpecializationMapEntry) Free() {
	if x != nil && x.allocs2fd815d1 != nil {
		x.allocs2fd815d1.(*cgoAllocMap).Free()
		x.ref2fd815d1 = nil
	}
}

// NewSpecializationMapEntryRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSpecializationMapEntryRef(ref unsafe.Pointer) *SpecializationMapEntry {
	if ref == nil {
		return nil
	}
	obj := new(SpecializationMapEntry)
	obj.ref2fd815d1 = (*C.VkSpecializationMapEntry)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SpecializationMapEntry) PassRef() (*C.VkSpecializationMapEntry, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2fd815d1 != nil {
		return x.ref2fd815d1, nil
	}
	mem2fd815d1 := allocSpecializationMapEntryMemory(1)
	ref2fd815d1 := (*C.VkSpecializationMapEntry)(mem2fd815d1)
	allocs2fd815d1 := new(cgoAllocMap)
	allocs2fd815d1.Add(mem2fd815d1)

	var cconstantID_allocs *cgoAllocMap
	ref2fd815d1.constantID, cconstantID_allocs = (C.uint32_t)(x.ConstantID), cgoAllocsUnknown
	allocs2fd815d1.Borrow(cconstantID_allocs)

	var coffset_allocs *cgoAllocMap
	ref2fd815d1.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocs2fd815d1.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref2fd815d1.size, csize_allocs = (C.size_t)(x.Size), cgoAllocsUnknown
	allocs2fd815d1.Borrow(csize_allocs)

	x.ref2fd815d1 = ref2fd815d1
	x.allocs2fd815d1 = allocs2fd815d1
	return ref2fd815d1, allocs2fd815d1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SpecializationMapEntry) PassValue() (C.VkSpecializationMapEntry, *cgoAllocMap) {
	if x.ref2fd815d1 != nil {
		return *x.ref2fd815d1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SpecializationMapEntry) Deref() {
	if x.ref2fd815d1 == nil {
		return
	}
	x.ConstantID = (uint32)(x.ref2fd815d1.constantID)
	x.Offset = (uint32)(x.ref2fd815d1.offset)
	x.Size = (uint64)(x.ref2fd815d1.size)
}

// allocSpecializationInfoMemory allocates memory for type C.VkSpecializationInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSpecializationInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSpecializationInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSpecializationInfoValue = unsafe.Sizeof([1]C.VkSpecializationInfo{})

// unpackSSpecializationMapEntry transforms a sliced Go data structure into plain C format.
func unpackSSpecializationMapEntry(x []SpecializationMapEntry) (unpacked *C.VkSpecializationMapEntry, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSpecializationMapEntry) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSpecializationMapEntryMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSpecializationMapEntry)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSpecializationMapEntry)(h.Data)
	return
}

// packSSpecializationMapEntry reads sliced Go data structure out from plain C format.
func packSSpecializationMapEntry(v []SpecializationMapEntry, ptr0 *C.VkSpecializationMapEntry) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSpecializationMapEntryValue]C.VkSpecializationMapEntry)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSpecializationMapEntryRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SpecializationInfo) Ref() *C.VkSpecializationInfo {
	if x == nil {
		return nil
	}
	return x.ref6bc395a3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SpecializationInfo) Free() {
	if x != nil && x.allocs6bc395a3 != nil {
		x.allocs6bc395a3.(*cgoAllocMap).Free()
		x.ref6bc395a3 = nil
	}
}

// NewSpecializationInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSpecializationInfoRef(ref unsafe.Pointer) *SpecializationInfo {
	if ref == nil {
		return nil
	}
	obj := new(SpecializationInfo)
	obj.ref6bc395a3 = (*C.VkSpecializationInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SpecializationInfo) PassRef() (*C.VkSpecializationInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6bc395a3 != nil {
		return x.ref6bc395a3, nil
	}
	mem6bc395a3 := allocSpecializationInfoMemory(1)
	ref6bc395a3 := (*C.VkSpecializationInfo)(mem6bc395a3)
	allocs6bc395a3 := new(cgoAllocMap)
	allocs6bc395a3.Add(mem6bc395a3)

	var cmapEntryCount_allocs *cgoAllocMap
	ref6bc395a3.mapEntryCount, cmapEntryCount_allocs = (C.uint32_t)(x.MapEntryCount), cgoAllocsUnknown
	allocs6bc395a3.Borrow(cmapEntryCount_allocs)

	var cpMapEntries_allocs *cgoAllocMap
	ref6bc395a3.pMapEntries, cpMapEntries_allocs = unpackSSpecializationMapEntry(x.PMapEntries)
	allocs6bc395a3.Borrow(cpMapEntries_allocs)

	var cdataSize_allocs *cgoAllocMap
	ref6bc395a3.dataSize, cdataSize_allocs = (C.size_t)(x.DataSize), cgoAllocsUnknown
	allocs6bc395a3.Borrow(cdataSize_allocs)

	var cpData_allocs *cgoAllocMap
	ref6bc395a3.pData, cpData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PData)), cgoAllocsUnknown
	allocs6bc395a3.Borrow(cpData_allocs)

	x.ref6bc395a3 = ref6bc395a3
	x.allocs6bc395a3 = allocs6bc395a3
	return ref6bc395a3, allocs6bc395a3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SpecializationInfo) PassValue() (C.VkSpecializationInfo, *cgoAllocMap) {
	if x.ref6bc395a3 != nil {
		return *x.ref6bc395a3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SpecializationInfo) Deref() {
	if x.ref6bc395a3 == nil {
		return
	}
	x.MapEntryCount = (uint32)(x.ref6bc395a3.mapEntryCount)
	packSSpecializationMapEntry(x.PMapEntries, x.ref6bc395a3.pMapEntries)
	x.DataSize = (uint64)(x.ref6bc395a3.dataSize)
	x.PData = (unsafe.Pointer)(unsafe.Pointer(x.ref6bc395a3.pData))
}

// allocPipelineShaderStageCreateInfoMemory allocates memory for type C.VkPipelineShaderStageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineShaderStageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineShaderStageCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineShaderStageCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineShaderStageCreateInfo{})

// unpackSSpecializationInfo transforms a sliced Go data structure into plain C format.
func unpackSSpecializationInfo(x []SpecializationInfo) (unpacked *C.VkSpecializationInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSpecializationInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSpecializationInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSpecializationInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSpecializationInfo)(h.Data)
	return
}

// packSSpecializationInfo reads sliced Go data structure out from plain C format.
func packSSpecializationInfo(v []SpecializationInfo, ptr0 *C.VkSpecializationInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSpecializationInfoValue]C.VkSpecializationInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSpecializationInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineShaderStageCreateInfo) Ref() *C.VkPipelineShaderStageCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref50ba8b60
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineShaderStageCreateInfo) Free() {
	if x != nil && x.allocs50ba8b60 != nil {
		x.allocs50ba8b60.(*cgoAllocMap).Free()
		x.ref50ba8b60 = nil
	}
}

// NewPipelineShaderStageCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineShaderStageCreateInfoRef(ref unsafe.Pointer) *PipelineShaderStageCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineShaderStageCreateInfo)
	obj.ref50ba8b60 = (*C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineShaderStageCreateInfo) PassRef() (*C.VkPipelineShaderStageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref50ba8b60 != nil {
		return x.ref50ba8b60, nil
	}
	mem50ba8b60 := allocPipelineShaderStageCreateInfoMemory(1)
	ref50ba8b60 := (*C.VkPipelineShaderStageCreateInfo)(mem50ba8b60)
	allocs50ba8b60 := new(cgoAllocMap)
	allocs50ba8b60.Add(mem50ba8b60)

	var csType_allocs *cgoAllocMap
	ref50ba8b60.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs50ba8b60.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref50ba8b60.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref50ba8b60.flags, cflags_allocs = (C.VkPipelineShaderStageCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cflags_allocs)

	var cstage_allocs *cgoAllocMap
	ref50ba8b60.stage, cstage_allocs = (C.VkShaderStageFlagBits)(x.Stage), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cstage_allocs)

	var cmodule_allocs *cgoAllocMap
	ref50ba8b60.module, cmodule_allocs = *(*C.VkShaderModule)(unsafe.Pointer(&x.Module)), cgoAllocsUnknown
	allocs50ba8b60.Borrow(cmodule_allocs)

	var cpName_allocs *cgoAllocMap
	ref50ba8b60.pName, cpName_allocs = unpackPCharString(x.PName)
	allocs50ba8b60.Borrow(cpName_allocs)

	var cpSpecializationInfo_allocs *cgoAllocMap
	ref50ba8b60.pSpecializationInfo, cpSpecializationInfo_allocs = unpackSSpecializationInfo(x.PSpecializationInfo)
	allocs50ba8b60.Borrow(cpSpecializationInfo_allocs)

	x.ref50ba8b60 = ref50ba8b60
	x.allocs50ba8b60 = allocs50ba8b60
	return ref50ba8b60, allocs50ba8b60

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineShaderStageCreateInfo) PassValue() (C.VkPipelineShaderStageCreateInfo, *cgoAllocMap) {
	if x.ref50ba8b60 != nil {
		return *x.ref50ba8b60, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineShaderStageCreateInfo) Deref() {
	if x.ref50ba8b60 == nil {
		return
	}
	x.SType = (StructureType)(x.ref50ba8b60.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref50ba8b60.pNext))
	x.Flags = (PipelineShaderStageCreateFlags)(x.ref50ba8b60.flags)
	x.Stage = (ShaderStageFlagBits)(x.ref50ba8b60.stage)
	x.Module = *(*ShaderModule)(unsafe.Pointer(&x.ref50ba8b60.module))
	x.PName = packPCharString(x.ref50ba8b60.pName)
	packSSpecializationInfo(x.PSpecializationInfo, x.ref50ba8b60.pSpecializationInfo)
}

// allocVertexInputBindingDescriptionMemory allocates memory for type C.VkVertexInputBindingDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputBindingDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputBindingDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVertexInputBindingDescriptionValue = unsafe.Sizeof([1]C.VkVertexInputBindingDescription{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VertexInputBindingDescription) Ref() *C.VkVertexInputBindingDescription {
	if x == nil {
		return nil
	}
	return x.ref5c9d8c23
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VertexInputBindingDescription) Free() {
	if x != nil && x.allocs5c9d8c23 != nil {
		x.allocs5c9d8c23.(*cgoAllocMap).Free()
		x.ref5c9d8c23 = nil
	}
}

// NewVertexInputBindingDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVertexInputBindingDescriptionRef(ref unsafe.Pointer) *VertexInputBindingDescription {
	if ref == nil {
		return nil
	}
	obj := new(VertexInputBindingDescription)
	obj.ref5c9d8c23 = (*C.VkVertexInputBindingDescription)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VertexInputBindingDescription) PassRef() (*C.VkVertexInputBindingDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5c9d8c23 != nil {
		return x.ref5c9d8c23, nil
	}
	mem5c9d8c23 := allocVertexInputBindingDescriptionMemory(1)
	ref5c9d8c23 := (*C.VkVertexInputBindingDescription)(mem5c9d8c23)
	allocs5c9d8c23 := new(cgoAllocMap)
	allocs5c9d8c23.Add(mem5c9d8c23)

	var cbinding_allocs *cgoAllocMap
	ref5c9d8c23.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocs5c9d8c23.Borrow(cbinding_allocs)

	var cstride_allocs *cgoAllocMap
	ref5c9d8c23.stride, cstride_allocs = (C.uint32_t)(x.Stride), cgoAllocsUnknown
	allocs5c9d8c23.Borrow(cstride_allocs)

	var cinputRate_allocs *cgoAllocMap
	ref5c9d8c23.inputRate, cinputRate_allocs = (C.VkVertexInputRate)(x.InputRate), cgoAllocsUnknown
	allocs5c9d8c23.Borrow(cinputRate_allocs)

	x.ref5c9d8c23 = ref5c9d8c23
	x.allocs5c9d8c23 = allocs5c9d8c23
	return ref5c9d8c23, allocs5c9d8c23

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VertexInputBindingDescription) PassValue() (C.VkVertexInputBindingDescription, *cgoAllocMap) {
	if x.ref5c9d8c23 != nil {
		return *x.ref5c9d8c23, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VertexInputBindingDescription) Deref() {
	if x.ref5c9d8c23 == nil {
		return
	}
	x.Binding = (uint32)(x.ref5c9d8c23.binding)
	x.Stride = (uint32)(x.ref5c9d8c23.stride)
	x.InputRate = (VertexInputRate)(x.ref5c9d8c23.inputRate)
}

// allocVertexInputAttributeDescriptionMemory allocates memory for type C.VkVertexInputAttributeDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputAttributeDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputAttributeDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVertexInputAttributeDescriptionValue = unsafe.Sizeof([1]C.VkVertexInputAttributeDescription{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VertexInputAttributeDescription) Ref() *C.VkVertexInputAttributeDescription {
	if x == nil {
		return nil
	}
	return x.refdc4635ff
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VertexInputAttributeDescription) Free() {
	if x != nil && x.allocsdc4635ff != nil {
		x.allocsdc4635ff.(*cgoAllocMap).Free()
		x.refdc4635ff = nil
	}
}

// NewVertexInputAttributeDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVertexInputAttributeDescriptionRef(ref unsafe.Pointer) *VertexInputAttributeDescription {
	if ref == nil {
		return nil
	}
	obj := new(VertexInputAttributeDescription)
	obj.refdc4635ff = (*C.VkVertexInputAttributeDescription)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VertexInputAttributeDescription) PassRef() (*C.VkVertexInputAttributeDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdc4635ff != nil {
		return x.refdc4635ff, nil
	}
	memdc4635ff := allocVertexInputAttributeDescriptionMemory(1)
	refdc4635ff := (*C.VkVertexInputAttributeDescription)(memdc4635ff)
	allocsdc4635ff := new(cgoAllocMap)
	allocsdc4635ff.Add(memdc4635ff)

	var clocation_allocs *cgoAllocMap
	refdc4635ff.location, clocation_allocs = (C.uint32_t)(x.Location), cgoAllocsUnknown
	allocsdc4635ff.Borrow(clocation_allocs)

	var cbinding_allocs *cgoAllocMap
	refdc4635ff.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocsdc4635ff.Borrow(cbinding_allocs)

	var cformat_allocs *cgoAllocMap
	refdc4635ff.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsdc4635ff.Borrow(cformat_allocs)

	var coffset_allocs *cgoAllocMap
	refdc4635ff.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocsdc4635ff.Borrow(coffset_allocs)

	x.refdc4635ff = refdc4635ff
	x.allocsdc4635ff = allocsdc4635ff
	return refdc4635ff, allocsdc4635ff

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VertexInputAttributeDescription) PassValue() (C.VkVertexInputAttributeDescription, *cgoAllocMap) {
	if x.refdc4635ff != nil {
		return *x.refdc4635ff, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VertexInputAttributeDescription) Deref() {
	if x.refdc4635ff == nil {
		return
	}
	x.Location = (uint32)(x.refdc4635ff.location)
	x.Binding = (uint32)(x.refdc4635ff.binding)
	x.Format = (Format)(x.refdc4635ff.format)
	x.Offset = (uint32)(x.refdc4635ff.offset)
}

// allocPipelineVertexInputStateCreateInfoMemory allocates memory for type C.VkPipelineVertexInputStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineVertexInputStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineVertexInputStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineVertexInputStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineVertexInputStateCreateInfo{})

// unpackSVertexInputBindingDescription transforms a sliced Go data structure into plain C format.
func unpackSVertexInputBindingDescription(x []VertexInputBindingDescription) (unpacked *C.VkVertexInputBindingDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkVertexInputBindingDescription) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVertexInputBindingDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkVertexInputBindingDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkVertexInputBindingDescription)(h.Data)
	return
}

// unpackSVertexInputAttributeDescription transforms a sliced Go data structure into plain C format.
func unpackSVertexInputAttributeDescription(x []VertexInputAttributeDescription) (unpacked *C.VkVertexInputAttributeDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkVertexInputAttributeDescription) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVertexInputAttributeDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkVertexInputAttributeDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkVertexInputAttributeDescription)(h.Data)
	return
}

// packSVertexInputBindingDescription reads sliced Go data structure out from plain C format.
func packSVertexInputBindingDescription(v []VertexInputBindingDescription, ptr0 *C.VkVertexInputBindingDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVertexInputBindingDescriptionValue]C.VkVertexInputBindingDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVertexInputBindingDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// packSVertexInputAttributeDescription reads sliced Go data structure out from plain C format.
func packSVertexInputAttributeDescription(v []VertexInputAttributeDescription, ptr0 *C.VkVertexInputAttributeDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVertexInputAttributeDescriptionValue]C.VkVertexInputAttributeDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVertexInputAttributeDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineVertexInputStateCreateInfo) Ref() *C.VkPipelineVertexInputStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref5fe4aa50
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineVertexInputStateCreateInfo) Free() {
	if x != nil && x.allocs5fe4aa50 != nil {
		x.allocs5fe4aa50.(*cgoAllocMap).Free()
		x.ref5fe4aa50 = nil
	}
}

// NewPipelineVertexInputStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineVertexInputStateCreateInfoRef(ref unsafe.Pointer) *PipelineVertexInputStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineVertexInputStateCreateInfo)
	obj.ref5fe4aa50 = (*C.VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineVertexInputStateCreateInfo) PassRef() (*C.VkPipelineVertexInputStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5fe4aa50 != nil {
		return x.ref5fe4aa50, nil
	}
	mem5fe4aa50 := allocPipelineVertexInputStateCreateInfoMemory(1)
	ref5fe4aa50 := (*C.VkPipelineVertexInputStateCreateInfo)(mem5fe4aa50)
	allocs5fe4aa50 := new(cgoAllocMap)
	allocs5fe4aa50.Add(mem5fe4aa50)

	var csType_allocs *cgoAllocMap
	ref5fe4aa50.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5fe4aa50.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref5fe4aa50.flags, cflags_allocs = (C.VkPipelineVertexInputStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cflags_allocs)

	var cvertexBindingDescriptionCount_allocs *cgoAllocMap
	ref5fe4aa50.vertexBindingDescriptionCount, cvertexBindingDescriptionCount_allocs = (C.uint32_t)(x.VertexBindingDescriptionCount), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cvertexBindingDescriptionCount_allocs)

	var cpVertexBindingDescriptions_allocs *cgoAllocMap
	ref5fe4aa50.pVertexBindingDescriptions, cpVertexBindingDescriptions_allocs = unpackSVertexInputBindingDescription(x.PVertexBindingDescriptions)
	allocs5fe4aa50.Borrow(cpVertexBindingDescriptions_allocs)

	var cvertexAttributeDescriptionCount_allocs *cgoAllocMap
	ref5fe4aa50.vertexAttributeDescriptionCount, cvertexAttributeDescriptionCount_allocs = (C.uint32_t)(x.VertexAttributeDescriptionCount), cgoAllocsUnknown
	allocs5fe4aa50.Borrow(cvertexAttributeDescriptionCount_allocs)

	var cpVertexAttributeDescriptions_allocs *cgoAllocMap
	ref5fe4aa50.pVertexAttributeDescriptions, cpVertexAttributeDescriptions_allocs = unpackSVertexInputAttributeDescription(x.PVertexAttributeDescriptions)
	allocs5fe4aa50.Borrow(cpVertexAttributeDescriptions_allocs)

	x.ref5fe4aa50 = ref5fe4aa50
	x.allocs5fe4aa50 = allocs5fe4aa50
	return ref5fe4aa50, allocs5fe4aa50

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineVertexInputStateCreateInfo) PassValue() (C.VkPipelineVertexInputStateCreateInfo, *cgoAllocMap) {
	if x.ref5fe4aa50 != nil {
		return *x.ref5fe4aa50, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineVertexInputStateCreateInfo) Deref() {
	if x.ref5fe4aa50 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5fe4aa50.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5fe4aa50.pNext))
	x.Flags = (PipelineVertexInputStateCreateFlags)(x.ref5fe4aa50.flags)
	x.VertexBindingDescriptionCount = (uint32)(x.ref5fe4aa50.vertexBindingDescriptionCount)
	packSVertexInputBindingDescription(x.PVertexBindingDescriptions, x.ref5fe4aa50.pVertexBindingDescriptions)
	x.VertexAttributeDescriptionCount = (uint32)(x.ref5fe4aa50.vertexAttributeDescriptionCount)
	packSVertexInputAttributeDescription(x.PVertexAttributeDescriptions, x.ref5fe4aa50.pVertexAttributeDescriptions)
}

// allocPipelineInputAssemblyStateCreateInfoMemory allocates memory for type C.VkPipelineInputAssemblyStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineInputAssemblyStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineInputAssemblyStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineInputAssemblyStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineInputAssemblyStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineInputAssemblyStateCreateInfo) Ref() *C.VkPipelineInputAssemblyStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref22e1691d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineInputAssemblyStateCreateInfo) Free() {
	if x != nil && x.allocs22e1691d != nil {
		x.allocs22e1691d.(*cgoAllocMap).Free()
		x.ref22e1691d = nil
	}
}

// NewPipelineInputAssemblyStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineInputAssemblyStateCreateInfoRef(ref unsafe.Pointer) *PipelineInputAssemblyStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineInputAssemblyStateCreateInfo)
	obj.ref22e1691d = (*C.VkPipelineInputAssemblyStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineInputAssemblyStateCreateInfo) PassRef() (*C.VkPipelineInputAssemblyStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref22e1691d != nil {
		return x.ref22e1691d, nil
	}
	mem22e1691d := allocPipelineInputAssemblyStateCreateInfoMemory(1)
	ref22e1691d := (*C.VkPipelineInputAssemblyStateCreateInfo)(mem22e1691d)
	allocs22e1691d := new(cgoAllocMap)
	allocs22e1691d.Add(mem22e1691d)

	var csType_allocs *cgoAllocMap
	ref22e1691d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs22e1691d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref22e1691d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs22e1691d.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref22e1691d.flags, cflags_allocs = (C.VkPipelineInputAssemblyStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs22e1691d.Borrow(cflags_allocs)

	var ctopology_allocs *cgoAllocMap
	ref22e1691d.topology, ctopology_allocs = (C.VkPrimitiveTopology)(x.Topology), cgoAllocsUnknown
	allocs22e1691d.Borrow(ctopology_allocs)

	var cprimitiveRestartEnable_allocs *cgoAllocMap
	ref22e1691d.primitiveRestartEnable, cprimitiveRestartEnable_allocs = (C.VkBool32)(x.PrimitiveRestartEnable), cgoAllocsUnknown
	allocs22e1691d.Borrow(cprimitiveRestartEnable_allocs)

	x.ref22e1691d = ref22e1691d
	x.allocs22e1691d = allocs22e1691d
	return ref22e1691d, allocs22e1691d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineInputAssemblyStateCreateInfo) PassValue() (C.VkPipelineInputAssemblyStateCreateInfo, *cgoAllocMap) {
	if x.ref22e1691d != nil {
		return *x.ref22e1691d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineInputAssemblyStateCreateInfo) Deref() {
	if x.ref22e1691d == nil {
		return
	}
	x.SType = (StructureType)(x.ref22e1691d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref22e1691d.pNext))
	x.Flags = (PipelineInputAssemblyStateCreateFlags)(x.ref22e1691d.flags)
	x.Topology = (PrimitiveTopology)(x.ref22e1691d.topology)
	x.PrimitiveRestartEnable = (Bool32)(x.ref22e1691d.primitiveRestartEnable)
}

// allocPipelineTessellationStateCreateInfoMemory allocates memory for type C.VkPipelineTessellationStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineTessellationStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineTessellationStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineTessellationStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineTessellationStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineTessellationStateCreateInfo) Ref() *C.VkPipelineTessellationStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref4ef3997a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineTessellationStateCreateInfo) Free() {
	if x != nil && x.allocs4ef3997a != nil {
		x.allocs4ef3997a.(*cgoAllocMap).Free()
		x.ref4ef3997a = nil
	}
}

// NewPipelineTessellationStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineTessellationStateCreateInfoRef(ref unsafe.Pointer) *PipelineTessellationStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineTessellationStateCreateInfo)
	obj.ref4ef3997a = (*C.VkPipelineTessellationStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineTessellationStateCreateInfo) PassRef() (*C.VkPipelineTessellationStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4ef3997a != nil {
		return x.ref4ef3997a, nil
	}
	mem4ef3997a := allocPipelineTessellationStateCreateInfoMemory(1)
	ref4ef3997a := (*C.VkPipelineTessellationStateCreateInfo)(mem4ef3997a)
	allocs4ef3997a := new(cgoAllocMap)
	allocs4ef3997a.Add(mem4ef3997a)

	var csType_allocs *cgoAllocMap
	ref4ef3997a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4ef3997a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4ef3997a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4ef3997a.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref4ef3997a.flags, cflags_allocs = (C.VkPipelineTessellationStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs4ef3997a.Borrow(cflags_allocs)

	var cpatchControlPoints_allocs *cgoAllocMap
	ref4ef3997a.patchControlPoints, cpatchControlPoints_allocs = (C.uint32_t)(x.PatchControlPoints), cgoAllocsUnknown
	allocs4ef3997a.Borrow(cpatchControlPoints_allocs)

	x.ref4ef3997a = ref4ef3997a
	x.allocs4ef3997a = allocs4ef3997a
	return ref4ef3997a, allocs4ef3997a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineTessellationStateCreateInfo) PassValue() (C.VkPipelineTessellationStateCreateInfo, *cgoAllocMap) {
	if x.ref4ef3997a != nil {
		return *x.ref4ef3997a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineTessellationStateCreateInfo) Deref() {
	if x.ref4ef3997a == nil {
		return
	}
	x.SType = (StructureType)(x.ref4ef3997a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4ef3997a.pNext))
	x.Flags = (PipelineTessellationStateCreateFlags)(x.ref4ef3997a.flags)
	x.PatchControlPoints = (uint32)(x.ref4ef3997a.patchControlPoints)
}

// allocViewportMemory allocates memory for type C.VkViewport in C.
// The caller is responsible for freeing the this memory via C.free.
func allocViewportMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfViewportValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfViewportValue = unsafe.Sizeof([1]C.VkViewport{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Viewport) Ref() *C.VkViewport {
	if x == nil {
		return nil
	}
	return x.ref75cf5291
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Viewport) Free() {
	if x != nil && x.allocs75cf5291 != nil {
		x.allocs75cf5291.(*cgoAllocMap).Free()
		x.ref75cf5291 = nil
	}
}

// NewViewportRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewViewportRef(ref unsafe.Pointer) *Viewport {
	if ref == nil {
		return nil
	}
	obj := new(Viewport)
	obj.ref75cf5291 = (*C.VkViewport)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Viewport) PassRef() (*C.VkViewport, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref75cf5291 != nil {
		return x.ref75cf5291, nil
	}
	mem75cf5291 := allocViewportMemory(1)
	ref75cf5291 := (*C.VkViewport)(mem75cf5291)
	allocs75cf5291 := new(cgoAllocMap)
	allocs75cf5291.Add(mem75cf5291)

	var cx_allocs *cgoAllocMap
	ref75cf5291.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs75cf5291.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref75cf5291.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs75cf5291.Borrow(cy_allocs)

	var cwidth_allocs *cgoAllocMap
	ref75cf5291.width, cwidth_allocs = (C.float)(x.Width), cgoAllocsUnknown
	allocs75cf5291.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref75cf5291.height, cheight_allocs = (C.float)(x.Height), cgoAllocsUnknown
	allocs75cf5291.Borrow(cheight_allocs)

	var cminDepth_allocs *cgoAllocMap
	ref75cf5291.minDepth, cminDepth_allocs = (C.float)(x.MinDepth), cgoAllocsUnknown
	allocs75cf5291.Borrow(cminDepth_allocs)

	var cmaxDepth_allocs *cgoAllocMap
	ref75cf5291.maxDepth, cmaxDepth_allocs = (C.float)(x.MaxDepth), cgoAllocsUnknown
	allocs75cf5291.Borrow(cmaxDepth_allocs)

	x.ref75cf5291 = ref75cf5291
	x.allocs75cf5291 = allocs75cf5291
	return ref75cf5291, allocs75cf5291

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Viewport) PassValue() (C.VkViewport, *cgoAllocMap) {
	if x.ref75cf5291 != nil {
		return *x.ref75cf5291, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Viewport) Deref() {
	if x.ref75cf5291 == nil {
		return
	}
	x.X = (float32)(x.ref75cf5291.x)
	x.Y = (float32)(x.ref75cf5291.y)
	x.Width = (float32)(x.ref75cf5291.width)
	x.Height = (float32)(x.ref75cf5291.height)
	x.MinDepth = (float32)(x.ref75cf5291.minDepth)
	x.MaxDepth = (float32)(x.ref75cf5291.maxDepth)
}

// allocOffset2DMemory allocates memory for type C.VkOffset2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOffset2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOffset2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfOffset2DValue = unsafe.Sizeof([1]C.VkOffset2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Offset2D) Ref() *C.VkOffset2D {
	if x == nil {
		return nil
	}
	return x.ref32734883
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Offset2D) Free() {
	if x != nil && x.allocs32734883 != nil {
		x.allocs32734883.(*cgoAllocMap).Free()
		x.ref32734883 = nil
	}
}

// NewOffset2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOffset2DRef(ref unsafe.Pointer) *Offset2D {
	if ref == nil {
		return nil
	}
	obj := new(Offset2D)
	obj.ref32734883 = (*C.VkOffset2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Offset2D) PassRef() (*C.VkOffset2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref32734883 != nil {
		return x.ref32734883, nil
	}
	mem32734883 := allocOffset2DMemory(1)
	ref32734883 := (*C.VkOffset2D)(mem32734883)
	allocs32734883 := new(cgoAllocMap)
	allocs32734883.Add(mem32734883)

	var cx_allocs *cgoAllocMap
	ref32734883.x, cx_allocs = (C.int32_t)(x.X), cgoAllocsUnknown
	allocs32734883.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref32734883.y, cy_allocs = (C.int32_t)(x.Y), cgoAllocsUnknown
	allocs32734883.Borrow(cy_allocs)

	x.ref32734883 = ref32734883
	x.allocs32734883 = allocs32734883
	return ref32734883, allocs32734883

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Offset2D) PassValue() (C.VkOffset2D, *cgoAllocMap) {
	if x.ref32734883 != nil {
		return *x.ref32734883, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Offset2D) Deref() {
	if x.ref32734883 == nil {
		return
	}
	x.X = (int32)(x.ref32734883.x)
	x.Y = (int32)(x.ref32734883.y)
}

// allocExtent2DMemory allocates memory for type C.VkExtent2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExtent2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExtent2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExtent2DValue = unsafe.Sizeof([1]C.VkExtent2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Extent2D) Ref() *C.VkExtent2D {
	if x == nil {
		return nil
	}
	return x.refe2edf56b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Extent2D) Free() {
	if x != nil && x.allocse2edf56b != nil {
		x.allocse2edf56b.(*cgoAllocMap).Free()
		x.refe2edf56b = nil
	}
}

// NewExtent2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExtent2DRef(ref unsafe.Pointer) *Extent2D {
	if ref == nil {
		return nil
	}
	obj := new(Extent2D)
	obj.refe2edf56b = (*C.VkExtent2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Extent2D) PassRef() (*C.VkExtent2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe2edf56b != nil {
		return x.refe2edf56b, nil
	}
	meme2edf56b := allocExtent2DMemory(1)
	refe2edf56b := (*C.VkExtent2D)(meme2edf56b)
	allocse2edf56b := new(cgoAllocMap)
	allocse2edf56b.Add(meme2edf56b)

	var cwidth_allocs *cgoAllocMap
	refe2edf56b.width, cwidth_allocs = (C.uint32_t)(x.Width), cgoAllocsUnknown
	allocse2edf56b.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refe2edf56b.height, cheight_allocs = (C.uint32_t)(x.Height), cgoAllocsUnknown
	allocse2edf56b.Borrow(cheight_allocs)

	x.refe2edf56b = refe2edf56b
	x.allocse2edf56b = allocse2edf56b
	return refe2edf56b, allocse2edf56b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Extent2D) PassValue() (C.VkExtent2D, *cgoAllocMap) {
	if x.refe2edf56b != nil {
		return *x.refe2edf56b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Extent2D) Deref() {
	if x.refe2edf56b == nil {
		return
	}
	x.Width = (uint32)(x.refe2edf56b.width)
	x.Height = (uint32)(x.refe2edf56b.height)
}

// allocRect2DMemory allocates memory for type C.VkRect2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRect2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRect2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRect2DValue = unsafe.Sizeof([1]C.VkRect2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Rect2D) Ref() *C.VkRect2D {
	if x == nil {
		return nil
	}
	return x.ref89e4256f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Rect2D) Free() {
	if x != nil && x.allocs89e4256f != nil {
		x.allocs89e4256f.(*cgoAllocMap).Free()
		x.ref89e4256f = nil
	}
}

// NewRect2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRect2DRef(ref unsafe.Pointer) *Rect2D {
	if ref == nil {
		return nil
	}
	obj := new(Rect2D)
	obj.ref89e4256f = (*C.VkRect2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Rect2D) PassRef() (*C.VkRect2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref89e4256f != nil {
		return x.ref89e4256f, nil
	}
	mem89e4256f := allocRect2DMemory(1)
	ref89e4256f := (*C.VkRect2D)(mem89e4256f)
	allocs89e4256f := new(cgoAllocMap)
	allocs89e4256f.Add(mem89e4256f)

	var coffset_allocs *cgoAllocMap
	ref89e4256f.offset, coffset_allocs = x.Offset.PassValue()
	allocs89e4256f.Borrow(coffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref89e4256f.extent, cextent_allocs = x.Extent.PassValue()
	allocs89e4256f.Borrow(cextent_allocs)

	x.ref89e4256f = ref89e4256f
	x.allocs89e4256f = allocs89e4256f
	return ref89e4256f, allocs89e4256f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Rect2D) PassValue() (C.VkRect2D, *cgoAllocMap) {
	if x.ref89e4256f != nil {
		return *x.ref89e4256f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Rect2D) Deref() {
	if x.ref89e4256f == nil {
		return
	}
	x.Offset = *NewOffset2DRef(unsafe.Pointer(&x.ref89e4256f.offset))
	x.Extent = *NewExtent2DRef(unsafe.Pointer(&x.ref89e4256f.extent))
}

// allocPipelineViewportStateCreateInfoMemory allocates memory for type C.VkPipelineViewportStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineViewportStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineViewportStateCreateInfo{})

// unpackSViewport transforms a sliced Go data structure into plain C format.
func unpackSViewport(x []Viewport) (unpacked *C.VkViewport, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkViewport) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocViewportMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkViewport)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkViewport)(h.Data)
	return
}

// unpackSRect2D transforms a sliced Go data structure into plain C format.
func unpackSRect2D(x []Rect2D) (unpacked *C.VkRect2D, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkRect2D) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRect2DMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRect2D)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRect2D)(h.Data)
	return
}

// packSViewport reads sliced Go data structure out from plain C format.
func packSViewport(v []Viewport, ptr0 *C.VkViewport) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfViewportValue]C.VkViewport)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewViewportRef(unsafe.Pointer(&ptr1))
	}
}

// packSRect2D reads sliced Go data structure out from plain C format.
func packSRect2D(v []Rect2D, ptr0 *C.VkRect2D) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRect2DValue]C.VkRect2D)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRect2DRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportStateCreateInfo) Ref() *C.VkPipelineViewportStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc4705791
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportStateCreateInfo) Free() {
	if x != nil && x.allocsc4705791 != nil {
		x.allocsc4705791.(*cgoAllocMap).Free()
		x.refc4705791 = nil
	}
}

// NewPipelineViewportStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportStateCreateInfoRef(ref unsafe.Pointer) *PipelineViewportStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportStateCreateInfo)
	obj.refc4705791 = (*C.VkPipelineViewportStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportStateCreateInfo) PassRef() (*C.VkPipelineViewportStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc4705791 != nil {
		return x.refc4705791, nil
	}
	memc4705791 := allocPipelineViewportStateCreateInfoMemory(1)
	refc4705791 := (*C.VkPipelineViewportStateCreateInfo)(memc4705791)
	allocsc4705791 := new(cgoAllocMap)
	allocsc4705791.Add(memc4705791)

	var csType_allocs *cgoAllocMap
	refc4705791.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc4705791.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc4705791.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc4705791.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc4705791.flags, cflags_allocs = (C.VkPipelineViewportStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsc4705791.Borrow(cflags_allocs)

	var cviewportCount_allocs *cgoAllocMap
	refc4705791.viewportCount, cviewportCount_allocs = (C.uint32_t)(x.ViewportCount), cgoAllocsUnknown
	allocsc4705791.Borrow(cviewportCount_allocs)

	var cpViewports_allocs *cgoAllocMap
	refc4705791.pViewports, cpViewports_allocs = unpackSViewport(x.PViewports)
	allocsc4705791.Borrow(cpViewports_allocs)

	var cscissorCount_allocs *cgoAllocMap
	refc4705791.scissorCount, cscissorCount_allocs = (C.uint32_t)(x.ScissorCount), cgoAllocsUnknown
	allocsc4705791.Borrow(cscissorCount_allocs)

	var cpScissors_allocs *cgoAllocMap
	refc4705791.pScissors, cpScissors_allocs = unpackSRect2D(x.PScissors)
	allocsc4705791.Borrow(cpScissors_allocs)

	x.refc4705791 = refc4705791
	x.allocsc4705791 = allocsc4705791
	return refc4705791, allocsc4705791

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportStateCreateInfo) PassValue() (C.VkPipelineViewportStateCreateInfo, *cgoAllocMap) {
	if x.refc4705791 != nil {
		return *x.refc4705791, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportStateCreateInfo) Deref() {
	if x.refc4705791 == nil {
		return
	}
	x.SType = (StructureType)(x.refc4705791.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc4705791.pNext))
	x.Flags = (PipelineViewportStateCreateFlags)(x.refc4705791.flags)
	x.ViewportCount = (uint32)(x.refc4705791.viewportCount)
	packSViewport(x.PViewports, x.refc4705791.pViewports)
	x.ScissorCount = (uint32)(x.refc4705791.scissorCount)
	packSRect2D(x.PScissors, x.refc4705791.pScissors)
}

// allocPipelineRasterizationStateCreateInfoMemory allocates memory for type C.VkPipelineRasterizationStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineRasterizationStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineRasterizationStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineRasterizationStateCreateInfo) Ref() *C.VkPipelineRasterizationStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref48cb9fad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineRasterizationStateCreateInfo) Free() {
	if x != nil && x.allocs48cb9fad != nil {
		x.allocs48cb9fad.(*cgoAllocMap).Free()
		x.ref48cb9fad = nil
	}
}

// NewPipelineRasterizationStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineRasterizationStateCreateInfoRef(ref unsafe.Pointer) *PipelineRasterizationStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRasterizationStateCreateInfo)
	obj.ref48cb9fad = (*C.VkPipelineRasterizationStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineRasterizationStateCreateInfo) PassRef() (*C.VkPipelineRasterizationStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref48cb9fad != nil {
		return x.ref48cb9fad, nil
	}
	mem48cb9fad := allocPipelineRasterizationStateCreateInfoMemory(1)
	ref48cb9fad := (*C.VkPipelineRasterizationStateCreateInfo)(mem48cb9fad)
	allocs48cb9fad := new(cgoAllocMap)
	allocs48cb9fad.Add(mem48cb9fad)

	var csType_allocs *cgoAllocMap
	ref48cb9fad.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs48cb9fad.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref48cb9fad.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref48cb9fad.flags, cflags_allocs = (C.VkPipelineRasterizationStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cflags_allocs)

	var cdepthClampEnable_allocs *cgoAllocMap
	ref48cb9fad.depthClampEnable, cdepthClampEnable_allocs = (C.VkBool32)(x.DepthClampEnable), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthClampEnable_allocs)

	var crasterizerDiscardEnable_allocs *cgoAllocMap
	ref48cb9fad.rasterizerDiscardEnable, crasterizerDiscardEnable_allocs = (C.VkBool32)(x.RasterizerDiscardEnable), cgoAllocsUnknown
	allocs48cb9fad.Borrow(crasterizerDiscardEnable_allocs)

	var cpolygonMode_allocs *cgoAllocMap
	ref48cb9fad.polygonMode, cpolygonMode_allocs = (C.VkPolygonMode)(x.PolygonMode), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cpolygonMode_allocs)

	var ccullMode_allocs *cgoAllocMap
	ref48cb9fad.cullMode, ccullMode_allocs = (C.VkCullModeFlags)(x.CullMode), cgoAllocsUnknown
	allocs48cb9fad.Borrow(ccullMode_allocs)

	var cfrontFace_allocs *cgoAllocMap
	ref48cb9fad.frontFace, cfrontFace_allocs = (C.VkFrontFace)(x.FrontFace), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cfrontFace_allocs)

	var cdepthBiasEnable_allocs *cgoAllocMap
	ref48cb9fad.depthBiasEnable, cdepthBiasEnable_allocs = (C.VkBool32)(x.DepthBiasEnable), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasEnable_allocs)

	var cdepthBiasConstantFactor_allocs *cgoAllocMap
	ref48cb9fad.depthBiasConstantFactor, cdepthBiasConstantFactor_allocs = (C.float)(x.DepthBiasConstantFactor), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasConstantFactor_allocs)

	var cdepthBiasClamp_allocs *cgoAllocMap
	ref48cb9fad.depthBiasClamp, cdepthBiasClamp_allocs = (C.float)(x.DepthBiasClamp), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasClamp_allocs)

	var cdepthBiasSlopeFactor_allocs *cgoAllocMap
	ref48cb9fad.depthBiasSlopeFactor, cdepthBiasSlopeFactor_allocs = (C.float)(x.DepthBiasSlopeFactor), cgoAllocsUnknown
	allocs48cb9fad.Borrow(cdepthBiasSlopeFactor_allocs)

	var clineWidth_allocs *cgoAllocMap
	ref48cb9fad.lineWidth, clineWidth_allocs = (C.float)(x.LineWidth), cgoAllocsUnknown
	allocs48cb9fad.Borrow(clineWidth_allocs)

	x.ref48cb9fad = ref48cb9fad
	x.allocs48cb9fad = allocs48cb9fad
	return ref48cb9fad, allocs48cb9fad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineRasterizationStateCreateInfo) PassValue() (C.VkPipelineRasterizationStateCreateInfo, *cgoAllocMap) {
	if x.ref48cb9fad != nil {
		return *x.ref48cb9fad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineRasterizationStateCreateInfo) Deref() {
	if x.ref48cb9fad == nil {
		return
	}
	x.SType = (StructureType)(x.ref48cb9fad.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref48cb9fad.pNext))
	x.Flags = (PipelineRasterizationStateCreateFlags)(x.ref48cb9fad.flags)
	x.DepthClampEnable = (Bool32)(x.ref48cb9fad.depthClampEnable)
	x.RasterizerDiscardEnable = (Bool32)(x.ref48cb9fad.rasterizerDiscardEnable)
	x.PolygonMode = (PolygonMode)(x.ref48cb9fad.polygonMode)
	x.CullMode = (CullModeFlags)(x.ref48cb9fad.cullMode)
	x.FrontFace = (FrontFace)(x.ref48cb9fad.frontFace)
	x.DepthBiasEnable = (Bool32)(x.ref48cb9fad.depthBiasEnable)
	x.DepthBiasConstantFactor = (float32)(x.ref48cb9fad.depthBiasConstantFactor)
	x.DepthBiasClamp = (float32)(x.ref48cb9fad.depthBiasClamp)
	x.DepthBiasSlopeFactor = (float32)(x.ref48cb9fad.depthBiasSlopeFactor)
	x.LineWidth = (float32)(x.ref48cb9fad.lineWidth)
}

// allocPipelineMultisampleStateCreateInfoMemory allocates memory for type C.VkPipelineMultisampleStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineMultisampleStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineMultisampleStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineMultisampleStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineMultisampleStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineMultisampleStateCreateInfo) Ref() *C.VkPipelineMultisampleStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.refb6538bfb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineMultisampleStateCreateInfo) Free() {
	if x != nil && x.allocsb6538bfb != nil {
		x.allocsb6538bfb.(*cgoAllocMap).Free()
		x.refb6538bfb = nil
	}
}

// NewPipelineMultisampleStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineMultisampleStateCreateInfoRef(ref unsafe.Pointer) *PipelineMultisampleStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineMultisampleStateCreateInfo)
	obj.refb6538bfb = (*C.VkPipelineMultisampleStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineMultisampleStateCreateInfo) PassRef() (*C.VkPipelineMultisampleStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb6538bfb != nil {
		return x.refb6538bfb, nil
	}
	memb6538bfb := allocPipelineMultisampleStateCreateInfoMemory(1)
	refb6538bfb := (*C.VkPipelineMultisampleStateCreateInfo)(memb6538bfb)
	allocsb6538bfb := new(cgoAllocMap)
	allocsb6538bfb.Add(memb6538bfb)

	var csType_allocs *cgoAllocMap
	refb6538bfb.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb6538bfb.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb6538bfb.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refb6538bfb.flags, cflags_allocs = (C.VkPipelineMultisampleStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cflags_allocs)

	var crasterizationSamples_allocs *cgoAllocMap
	refb6538bfb.rasterizationSamples, crasterizationSamples_allocs = (C.VkSampleCountFlagBits)(x.RasterizationSamples), cgoAllocsUnknown
	allocsb6538bfb.Borrow(crasterizationSamples_allocs)

	var csampleShadingEnable_allocs *cgoAllocMap
	refb6538bfb.sampleShadingEnable, csampleShadingEnable_allocs = (C.VkBool32)(x.SampleShadingEnable), cgoAllocsUnknown
	allocsb6538bfb.Borrow(csampleShadingEnable_allocs)

	var cminSampleShading_allocs *cgoAllocMap
	refb6538bfb.minSampleShading, cminSampleShading_allocs = (C.float)(x.MinSampleShading), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cminSampleShading_allocs)

	var cpSampleMask_allocs *cgoAllocMap
	refb6538bfb.pSampleMask, cpSampleMask_allocs = (*C.VkSampleMask)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSampleMask)).Data)), cgoAllocsUnknown
	allocsb6538bfb.Borrow(cpSampleMask_allocs)

	var calphaToCoverageEnable_allocs *cgoAllocMap
	refb6538bfb.alphaToCoverageEnable, calphaToCoverageEnable_allocs = (C.VkBool32)(x.AlphaToCoverageEnable), cgoAllocsUnknown
	allocsb6538bfb.Borrow(calphaToCoverageEnable_allocs)

	var calphaToOneEnable_allocs *cgoAllocMap
	refb6538bfb.alphaToOneEnable, calphaToOneEnable_allocs = (C.VkBool32)(x.AlphaToOneEnable), cgoAllocsUnknown
	allocsb6538bfb.Borrow(calphaToOneEnable_allocs)

	x.refb6538bfb = refb6538bfb
	x.allocsb6538bfb = allocsb6538bfb
	return refb6538bfb, allocsb6538bfb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineMultisampleStateCreateInfo) PassValue() (C.VkPipelineMultisampleStateCreateInfo, *cgoAllocMap) {
	if x.refb6538bfb != nil {
		return *x.refb6538bfb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineMultisampleStateCreateInfo) Deref() {
	if x.refb6538bfb == nil {
		return
	}
	x.SType = (StructureType)(x.refb6538bfb.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb6538bfb.pNext))
	x.Flags = (PipelineMultisampleStateCreateFlags)(x.refb6538bfb.flags)
	x.RasterizationSamples = (SampleCountFlagBits)(x.refb6538bfb.rasterizationSamples)
	x.SampleShadingEnable = (Bool32)(x.refb6538bfb.sampleShadingEnable)
	x.MinSampleShading = (float32)(x.refb6538bfb.minSampleShading)
	hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&x.PSampleMask))
	hxf3b8dbd.Data = unsafe.Pointer(x.refb6538bfb.pSampleMask)
	hxf3b8dbd.Cap = 0x7fffffff
	// hxf3b8dbd.Len = ?

	x.AlphaToCoverageEnable = (Bool32)(x.refb6538bfb.alphaToCoverageEnable)
	x.AlphaToOneEnable = (Bool32)(x.refb6538bfb.alphaToOneEnable)
}

// allocStencilOpStateMemory allocates memory for type C.VkStencilOpState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStencilOpStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStencilOpStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStencilOpStateValue = unsafe.Sizeof([1]C.VkStencilOpState{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StencilOpState) Ref() *C.VkStencilOpState {
	if x == nil {
		return nil
	}
	return x.ref28886871
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StencilOpState) Free() {
	if x != nil && x.allocs28886871 != nil {
		x.allocs28886871.(*cgoAllocMap).Free()
		x.ref28886871 = nil
	}
}

// NewStencilOpStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStencilOpStateRef(ref unsafe.Pointer) *StencilOpState {
	if ref == nil {
		return nil
	}
	obj := new(StencilOpState)
	obj.ref28886871 = (*C.VkStencilOpState)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StencilOpState) PassRef() (*C.VkStencilOpState, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref28886871 != nil {
		return x.ref28886871, nil
	}
	mem28886871 := allocStencilOpStateMemory(1)
	ref28886871 := (*C.VkStencilOpState)(mem28886871)
	allocs28886871 := new(cgoAllocMap)
	allocs28886871.Add(mem28886871)

	var cfailOp_allocs *cgoAllocMap
	ref28886871.failOp, cfailOp_allocs = (C.VkStencilOp)(x.FailOp), cgoAllocsUnknown
	allocs28886871.Borrow(cfailOp_allocs)

	var cpassOp_allocs *cgoAllocMap
	ref28886871.passOp, cpassOp_allocs = (C.VkStencilOp)(x.PassOp), cgoAllocsUnknown
	allocs28886871.Borrow(cpassOp_allocs)

	var cdepthFailOp_allocs *cgoAllocMap
	ref28886871.depthFailOp, cdepthFailOp_allocs = (C.VkStencilOp)(x.DepthFailOp), cgoAllocsUnknown
	allocs28886871.Borrow(cdepthFailOp_allocs)

	var ccompareOp_allocs *cgoAllocMap
	ref28886871.compareOp, ccompareOp_allocs = (C.VkCompareOp)(x.CompareOp), cgoAllocsUnknown
	allocs28886871.Borrow(ccompareOp_allocs)

	var ccompareMask_allocs *cgoAllocMap
	ref28886871.compareMask, ccompareMask_allocs = (C.uint32_t)(x.CompareMask), cgoAllocsUnknown
	allocs28886871.Borrow(ccompareMask_allocs)

	var cwriteMask_allocs *cgoAllocMap
	ref28886871.writeMask, cwriteMask_allocs = (C.uint32_t)(x.WriteMask), cgoAllocsUnknown
	allocs28886871.Borrow(cwriteMask_allocs)

	var creference_allocs *cgoAllocMap
	ref28886871.reference, creference_allocs = (C.uint32_t)(x.Reference), cgoAllocsUnknown
	allocs28886871.Borrow(creference_allocs)

	x.ref28886871 = ref28886871
	x.allocs28886871 = allocs28886871
	return ref28886871, allocs28886871

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StencilOpState) PassValue() (C.VkStencilOpState, *cgoAllocMap) {
	if x.ref28886871 != nil {
		return *x.ref28886871, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StencilOpState) Deref() {
	if x.ref28886871 == nil {
		return
	}
	x.FailOp = (StencilOp)(x.ref28886871.failOp)
	x.PassOp = (StencilOp)(x.ref28886871.passOp)
	x.DepthFailOp = (StencilOp)(x.ref28886871.depthFailOp)
	x.CompareOp = (CompareOp)(x.ref28886871.compareOp)
	x.CompareMask = (uint32)(x.ref28886871.compareMask)
	x.WriteMask = (uint32)(x.ref28886871.writeMask)
	x.Reference = (uint32)(x.ref28886871.reference)
}

// allocPipelineDepthStencilStateCreateInfoMemory allocates memory for type C.VkPipelineDepthStencilStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineDepthStencilStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineDepthStencilStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineDepthStencilStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineDepthStencilStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineDepthStencilStateCreateInfo) Ref() *C.VkPipelineDepthStencilStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.refeabfcf1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineDepthStencilStateCreateInfo) Free() {
	if x != nil && x.allocseabfcf1 != nil {
		x.allocseabfcf1.(*cgoAllocMap).Free()
		x.refeabfcf1 = nil
	}
}

// NewPipelineDepthStencilStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineDepthStencilStateCreateInfoRef(ref unsafe.Pointer) *PipelineDepthStencilStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineDepthStencilStateCreateInfo)
	obj.refeabfcf1 = (*C.VkPipelineDepthStencilStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineDepthStencilStateCreateInfo) PassRef() (*C.VkPipelineDepthStencilStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeabfcf1 != nil {
		return x.refeabfcf1, nil
	}
	memeabfcf1 := allocPipelineDepthStencilStateCreateInfoMemory(1)
	refeabfcf1 := (*C.VkPipelineDepthStencilStateCreateInfo)(memeabfcf1)
	allocseabfcf1 := new(cgoAllocMap)
	allocseabfcf1.Add(memeabfcf1)

	var csType_allocs *cgoAllocMap
	refeabfcf1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseabfcf1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeabfcf1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseabfcf1.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refeabfcf1.flags, cflags_allocs = (C.VkPipelineDepthStencilStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocseabfcf1.Borrow(cflags_allocs)

	var cdepthTestEnable_allocs *cgoAllocMap
	refeabfcf1.depthTestEnable, cdepthTestEnable_allocs = (C.VkBool32)(x.DepthTestEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthTestEnable_allocs)

	var cdepthWriteEnable_allocs *cgoAllocMap
	refeabfcf1.depthWriteEnable, cdepthWriteEnable_allocs = (C.VkBool32)(x.DepthWriteEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthWriteEnable_allocs)

	var cdepthCompareOp_allocs *cgoAllocMap
	refeabfcf1.depthCompareOp, cdepthCompareOp_allocs = (C.VkCompareOp)(x.DepthCompareOp), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthCompareOp_allocs)

	var cdepthBoundsTestEnable_allocs *cgoAllocMap
	refeabfcf1.depthBoundsTestEnable, cdepthBoundsTestEnable_allocs = (C.VkBool32)(x.DepthBoundsTestEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cdepthBoundsTestEnable_allocs)

	var cstencilTestEnable_allocs *cgoAllocMap
	refeabfcf1.stencilTestEnable, cstencilTestEnable_allocs = (C.VkBool32)(x.StencilTestEnable), cgoAllocsUnknown
	allocseabfcf1.Borrow(cstencilTestEnable_allocs)

	var cfront_allocs *cgoAllocMap
	refeabfcf1.front, cfront_allocs = x.Front.PassValue()
	allocseabfcf1.Borrow(cfront_allocs)

	var cback_allocs *cgoAllocMap
	refeabfcf1.back, cback_allocs = x.Back.PassValue()
	allocseabfcf1.Borrow(cback_allocs)

	var cminDepthBounds_allocs *cgoAllocMap
	refeabfcf1.minDepthBounds, cminDepthBounds_allocs = (C.float)(x.MinDepthBounds), cgoAllocsUnknown
	allocseabfcf1.Borrow(cminDepthBounds_allocs)

	var cmaxDepthBounds_allocs *cgoAllocMap
	refeabfcf1.maxDepthBounds, cmaxDepthBounds_allocs = (C.float)(x.MaxDepthBounds), cgoAllocsUnknown
	allocseabfcf1.Borrow(cmaxDepthBounds_allocs)

	x.refeabfcf1 = refeabfcf1
	x.allocseabfcf1 = allocseabfcf1
	return refeabfcf1, allocseabfcf1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineDepthStencilStateCreateInfo) PassValue() (C.VkPipelineDepthStencilStateCreateInfo, *cgoAllocMap) {
	if x.refeabfcf1 != nil {
		return *x.refeabfcf1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineDepthStencilStateCreateInfo) Deref() {
	if x.refeabfcf1 == nil {
		return
	}
	x.SType = (StructureType)(x.refeabfcf1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeabfcf1.pNext))
	x.Flags = (PipelineDepthStencilStateCreateFlags)(x.refeabfcf1.flags)
	x.DepthTestEnable = (Bool32)(x.refeabfcf1.depthTestEnable)
	x.DepthWriteEnable = (Bool32)(x.refeabfcf1.depthWriteEnable)
	x.DepthCompareOp = (CompareOp)(x.refeabfcf1.depthCompareOp)
	x.DepthBoundsTestEnable = (Bool32)(x.refeabfcf1.depthBoundsTestEnable)
	x.StencilTestEnable = (Bool32)(x.refeabfcf1.stencilTestEnable)
	x.Front = *NewStencilOpStateRef(unsafe.Pointer(&x.refeabfcf1.front))
	x.Back = *NewStencilOpStateRef(unsafe.Pointer(&x.refeabfcf1.back))
	x.MinDepthBounds = (float32)(x.refeabfcf1.minDepthBounds)
	x.MaxDepthBounds = (float32)(x.refeabfcf1.maxDepthBounds)
}

// allocPipelineColorBlendAttachmentStateMemory allocates memory for type C.VkPipelineColorBlendAttachmentState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineColorBlendAttachmentStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineColorBlendAttachmentStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineColorBlendAttachmentStateValue = unsafe.Sizeof([1]C.VkPipelineColorBlendAttachmentState{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineColorBlendAttachmentState) Ref() *C.VkPipelineColorBlendAttachmentState {
	if x == nil {
		return nil
	}
	return x.ref9e889477
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineColorBlendAttachmentState) Free() {
	if x != nil && x.allocs9e889477 != nil {
		x.allocs9e889477.(*cgoAllocMap).Free()
		x.ref9e889477 = nil
	}
}

// NewPipelineColorBlendAttachmentStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineColorBlendAttachmentStateRef(ref unsafe.Pointer) *PipelineColorBlendAttachmentState {
	if ref == nil {
		return nil
	}
	obj := new(PipelineColorBlendAttachmentState)
	obj.ref9e889477 = (*C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineColorBlendAttachmentState) PassRef() (*C.VkPipelineColorBlendAttachmentState, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9e889477 != nil {
		return x.ref9e889477, nil
	}
	mem9e889477 := allocPipelineColorBlendAttachmentStateMemory(1)
	ref9e889477 := (*C.VkPipelineColorBlendAttachmentState)(mem9e889477)
	allocs9e889477 := new(cgoAllocMap)
	allocs9e889477.Add(mem9e889477)

	var cblendEnable_allocs *cgoAllocMap
	ref9e889477.blendEnable, cblendEnable_allocs = (C.VkBool32)(x.BlendEnable), cgoAllocsUnknown
	allocs9e889477.Borrow(cblendEnable_allocs)

	var csrcColorBlendFactor_allocs *cgoAllocMap
	ref9e889477.srcColorBlendFactor, csrcColorBlendFactor_allocs = (C.VkBlendFactor)(x.SrcColorBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(csrcColorBlendFactor_allocs)

	var cdstColorBlendFactor_allocs *cgoAllocMap
	ref9e889477.dstColorBlendFactor, cdstColorBlendFactor_allocs = (C.VkBlendFactor)(x.DstColorBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(cdstColorBlendFactor_allocs)

	var ccolorBlendOp_allocs *cgoAllocMap
	ref9e889477.colorBlendOp, ccolorBlendOp_allocs = (C.VkBlendOp)(x.ColorBlendOp), cgoAllocsUnknown
	allocs9e889477.Borrow(ccolorBlendOp_allocs)

	var csrcAlphaBlendFactor_allocs *cgoAllocMap
	ref9e889477.srcAlphaBlendFactor, csrcAlphaBlendFactor_allocs = (C.VkBlendFactor)(x.SrcAlphaBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(csrcAlphaBlendFactor_allocs)

	var cdstAlphaBlendFactor_allocs *cgoAllocMap
	ref9e889477.dstAlphaBlendFactor, cdstAlphaBlendFactor_allocs = (C.VkBlendFactor)(x.DstAlphaBlendFactor), cgoAllocsUnknown
	allocs9e889477.Borrow(cdstAlphaBlendFactor_allocs)

	var calphaBlendOp_allocs *cgoAllocMap
	ref9e889477.alphaBlendOp, calphaBlendOp_allocs = (C.VkBlendOp)(x.AlphaBlendOp), cgoAllocsUnknown
	allocs9e889477.Borrow(calphaBlendOp_allocs)

	var ccolorWriteMask_allocs *cgoAllocMap
	ref9e889477.colorWriteMask, ccolorWriteMask_allocs = (C.VkColorComponentFlags)(x.ColorWriteMask), cgoAllocsUnknown
	allocs9e889477.Borrow(ccolorWriteMask_allocs)

	x.ref9e889477 = ref9e889477
	x.allocs9e889477 = allocs9e889477
	return ref9e889477, allocs9e889477

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineColorBlendAttachmentState) PassValue() (C.VkPipelineColorBlendAttachmentState, *cgoAllocMap) {
	if x.ref9e889477 != nil {
		return *x.ref9e889477, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineColorBlendAttachmentState) Deref() {
	if x.ref9e889477 == nil {
		return
	}
	x.BlendEnable = (Bool32)(x.ref9e889477.blendEnable)
	x.SrcColorBlendFactor = (BlendFactor)(x.ref9e889477.srcColorBlendFactor)
	x.DstColorBlendFactor = (BlendFactor)(x.ref9e889477.dstColorBlendFactor)
	x.ColorBlendOp = (BlendOp)(x.ref9e889477.colorBlendOp)
	x.SrcAlphaBlendFactor = (BlendFactor)(x.ref9e889477.srcAlphaBlendFactor)
	x.DstAlphaBlendFactor = (BlendFactor)(x.ref9e889477.dstAlphaBlendFactor)
	x.AlphaBlendOp = (BlendOp)(x.ref9e889477.alphaBlendOp)
	x.ColorWriteMask = (ColorComponentFlags)(x.ref9e889477.colorWriteMask)
}

// allocPipelineColorBlendStateCreateInfoMemory allocates memory for type C.VkPipelineColorBlendStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineColorBlendStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineColorBlendStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineColorBlendStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineColorBlendStateCreateInfo{})

// unpackSPipelineColorBlendAttachmentState transforms a sliced Go data structure into plain C format.
func unpackSPipelineColorBlendAttachmentState(x []PipelineColorBlendAttachmentState) (unpacked *C.VkPipelineColorBlendAttachmentState, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineColorBlendAttachmentState) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineColorBlendAttachmentStateMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineColorBlendAttachmentState)(h.Data)
	return
}

// packSPipelineColorBlendAttachmentState reads sliced Go data structure out from plain C format.
func packSPipelineColorBlendAttachmentState(v []PipelineColorBlendAttachmentState, ptr0 *C.VkPipelineColorBlendAttachmentState) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineColorBlendAttachmentStateValue]C.VkPipelineColorBlendAttachmentState)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineColorBlendAttachmentStateRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineColorBlendStateCreateInfo) Ref() *C.VkPipelineColorBlendStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref2a9b490b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineColorBlendStateCreateInfo) Free() {
	if x != nil && x.allocs2a9b490b != nil {
		x.allocs2a9b490b.(*cgoAllocMap).Free()
		x.ref2a9b490b = nil
	}
}

// NewPipelineColorBlendStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineColorBlendStateCreateInfoRef(ref unsafe.Pointer) *PipelineColorBlendStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineColorBlendStateCreateInfo)
	obj.ref2a9b490b = (*C.VkPipelineColorBlendStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineColorBlendStateCreateInfo) PassRef() (*C.VkPipelineColorBlendStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2a9b490b != nil {
		return x.ref2a9b490b, nil
	}
	mem2a9b490b := allocPipelineColorBlendStateCreateInfoMemory(1)
	ref2a9b490b := (*C.VkPipelineColorBlendStateCreateInfo)(mem2a9b490b)
	allocs2a9b490b := new(cgoAllocMap)
	allocs2a9b490b.Add(mem2a9b490b)

	var csType_allocs *cgoAllocMap
	ref2a9b490b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2a9b490b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2a9b490b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref2a9b490b.flags, cflags_allocs = (C.VkPipelineColorBlendStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cflags_allocs)

	var clogicOpEnable_allocs *cgoAllocMap
	ref2a9b490b.logicOpEnable, clogicOpEnable_allocs = (C.VkBool32)(x.LogicOpEnable), cgoAllocsUnknown
	allocs2a9b490b.Borrow(clogicOpEnable_allocs)

	var clogicOp_allocs *cgoAllocMap
	ref2a9b490b.logicOp, clogicOp_allocs = (C.VkLogicOp)(x.LogicOp), cgoAllocsUnknown
	allocs2a9b490b.Borrow(clogicOp_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	ref2a9b490b.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	ref2a9b490b.pAttachments, cpAttachments_allocs = unpackSPipelineColorBlendAttachmentState(x.PAttachments)
	allocs2a9b490b.Borrow(cpAttachments_allocs)

	var cblendConstants_allocs *cgoAllocMap
	ref2a9b490b.blendConstants, cblendConstants_allocs = *(*[4]C.float)(unsafe.Pointer(&x.BlendConstants)), cgoAllocsUnknown
	allocs2a9b490b.Borrow(cblendConstants_allocs)

	x.ref2a9b490b = ref2a9b490b
	x.allocs2a9b490b = allocs2a9b490b
	return ref2a9b490b, allocs2a9b490b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineColorBlendStateCreateInfo) PassValue() (C.VkPipelineColorBlendStateCreateInfo, *cgoAllocMap) {
	if x.ref2a9b490b != nil {
		return *x.ref2a9b490b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineColorBlendStateCreateInfo) Deref() {
	if x.ref2a9b490b == nil {
		return
	}
	x.SType = (StructureType)(x.ref2a9b490b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2a9b490b.pNext))
	x.Flags = (PipelineColorBlendStateCreateFlags)(x.ref2a9b490b.flags)
	x.LogicOpEnable = (Bool32)(x.ref2a9b490b.logicOpEnable)
	x.LogicOp = (LogicOp)(x.ref2a9b490b.logicOp)
	x.AttachmentCount = (uint32)(x.ref2a9b490b.attachmentCount)
	packSPipelineColorBlendAttachmentState(x.PAttachments, x.ref2a9b490b.pAttachments)
	x.BlendConstants = *(*[4]float32)(unsafe.Pointer(&x.ref2a9b490b.blendConstants))
}

// allocPipelineDynamicStateCreateInfoMemory allocates memory for type C.VkPipelineDynamicStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineDynamicStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineDynamicStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineDynamicStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineDynamicStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineDynamicStateCreateInfo) Ref() *C.VkPipelineDynamicStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref246d7bc8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineDynamicStateCreateInfo) Free() {
	if x != nil && x.allocs246d7bc8 != nil {
		x.allocs246d7bc8.(*cgoAllocMap).Free()
		x.ref246d7bc8 = nil
	}
}

// NewPipelineDynamicStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineDynamicStateCreateInfoRef(ref unsafe.Pointer) *PipelineDynamicStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineDynamicStateCreateInfo)
	obj.ref246d7bc8 = (*C.VkPipelineDynamicStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineDynamicStateCreateInfo) PassRef() (*C.VkPipelineDynamicStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref246d7bc8 != nil {
		return x.ref246d7bc8, nil
	}
	mem246d7bc8 := allocPipelineDynamicStateCreateInfoMemory(1)
	ref246d7bc8 := (*C.VkPipelineDynamicStateCreateInfo)(mem246d7bc8)
	allocs246d7bc8 := new(cgoAllocMap)
	allocs246d7bc8.Add(mem246d7bc8)

	var csType_allocs *cgoAllocMap
	ref246d7bc8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs246d7bc8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref246d7bc8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref246d7bc8.flags, cflags_allocs = (C.VkPipelineDynamicStateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cflags_allocs)

	var cdynamicStateCount_allocs *cgoAllocMap
	ref246d7bc8.dynamicStateCount, cdynamicStateCount_allocs = (C.uint32_t)(x.DynamicStateCount), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cdynamicStateCount_allocs)

	var cpDynamicStates_allocs *cgoAllocMap
	ref246d7bc8.pDynamicStates, cpDynamicStates_allocs = (*C.VkDynamicState)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDynamicStates)).Data)), cgoAllocsUnknown
	allocs246d7bc8.Borrow(cpDynamicStates_allocs)

	x.ref246d7bc8 = ref246d7bc8
	x.allocs246d7bc8 = allocs246d7bc8
	return ref246d7bc8, allocs246d7bc8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineDynamicStateCreateInfo) PassValue() (C.VkPipelineDynamicStateCreateInfo, *cgoAllocMap) {
	if x.ref246d7bc8 != nil {
		return *x.ref246d7bc8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineDynamicStateCreateInfo) Deref() {
	if x.ref246d7bc8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref246d7bc8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref246d7bc8.pNext))
	x.Flags = (PipelineDynamicStateCreateFlags)(x.ref246d7bc8.flags)
	x.DynamicStateCount = (uint32)(x.ref246d7bc8.dynamicStateCount)
	hxf7a6dff := (*sliceHeader)(unsafe.Pointer(&x.PDynamicStates))
	hxf7a6dff.Data = unsafe.Pointer(x.ref246d7bc8.pDynamicStates)
	hxf7a6dff.Cap = 0x7fffffff
	// hxf7a6dff.Len = ?

}

// allocGraphicsPipelineCreateInfoMemory allocates memory for type C.VkGraphicsPipelineCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGraphicsPipelineCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGraphicsPipelineCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGraphicsPipelineCreateInfoValue = unsafe.Sizeof([1]C.VkGraphicsPipelineCreateInfo{})

// unpackSPipelineShaderStageCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineShaderStageCreateInfo(x []PipelineShaderStageCreateInfo) (unpacked *C.VkPipelineShaderStageCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPipelineShaderStageCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineShaderStageCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineShaderStageCreateInfo)(h.Data)
	return
}

// packSPipelineShaderStageCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineShaderStageCreateInfo(v []PipelineShaderStageCreateInfo, ptr0 *C.VkPipelineShaderStageCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineShaderStageCreateInfoValue]C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineShaderStageCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GraphicsPipelineCreateInfo) Ref() *C.VkGraphicsPipelineCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref178f88b6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GraphicsPipelineCreateInfo) Free() {
	if x != nil && x.allocs178f88b6 != nil {
		x.allocs178f88b6.(*cgoAllocMap).Free()
		x.ref178f88b6 = nil
	}
}

// NewGraphicsPipelineCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGraphicsPipelineCreateInfoRef(ref unsafe.Pointer) *GraphicsPipelineCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(GraphicsPipelineCreateInfo)
	obj.ref178f88b6 = (*C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GraphicsPipelineCreateInfo) PassRef() (*C.VkGraphicsPipelineCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref178f88b6 != nil {
		return x.ref178f88b6, nil
	}
	mem178f88b6 := allocGraphicsPipelineCreateInfoMemory(1)
	ref178f88b6 := (*C.VkGraphicsPipelineCreateInfo)(mem178f88b6)
	allocs178f88b6 := new(cgoAllocMap)
	allocs178f88b6.Add(mem178f88b6)

	var csType_allocs *cgoAllocMap
	ref178f88b6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs178f88b6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref178f88b6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs178f88b6.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref178f88b6.flags, cflags_allocs = (C.VkPipelineCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs178f88b6.Borrow(cflags_allocs)

	var cstageCount_allocs *cgoAllocMap
	ref178f88b6.stageCount, cstageCount_allocs = (C.uint32_t)(x.StageCount), cgoAllocsUnknown
	allocs178f88b6.Borrow(cstageCount_allocs)

	var cpStages_allocs *cgoAllocMap
	ref178f88b6.pStages, cpStages_allocs = unpackSPipelineShaderStageCreateInfo(x.PStages)
	allocs178f88b6.Borrow(cpStages_allocs)

	var cpVertexInputState_allocs *cgoAllocMap
	ref178f88b6.pVertexInputState, cpVertexInputState_allocs = x.PVertexInputState.PassRef()
	allocs178f88b6.Borrow(cpVertexInputState_allocs)

	var cpInputAssemblyState_allocs *cgoAllocMap
	ref178f88b6.pInputAssemblyState, cpInputAssemblyState_allocs = x.PInputAssemblyState.PassRef()
	allocs178f88b6.Borrow(cpInputAssemblyState_allocs)

	var cpTessellationState_allocs *cgoAllocMap
	ref178f88b6.pTessellationState, cpTessellationState_allocs = x.PTessellationState.PassRef()
	allocs178f88b6.Borrow(cpTessellationState_allocs)

	var cpViewportState_allocs *cgoAllocMap
	ref178f88b6.pViewportState, cpViewportState_allocs = x.PViewportState.PassRef()
	allocs178f88b6.Borrow(cpViewportState_allocs)

	var cpRasterizationState_allocs *cgoAllocMap
	ref178f88b6.pRasterizationState, cpRasterizationState_allocs = x.PRasterizationState.PassRef()
	allocs178f88b6.Borrow(cpRasterizationState_allocs)

	var cpMultisampleState_allocs *cgoAllocMap
	ref178f88b6.pMultisampleState, cpMultisampleState_allocs = x.PMultisampleState.PassRef()
	allocs178f88b6.Borrow(cpMultisampleState_allocs)

	var cpDepthStencilState_allocs *cgoAllocMap
	ref178f88b6.pDepthStencilState, cpDepthStencilState_allocs = x.PDepthStencilState.PassRef()
	allocs178f88b6.Borrow(cpDepthStencilState_allocs)

	var cpColorBlendState_allocs *cgoAllocMap
	ref178f88b6.pColorBlendState, cpColorBlendState_allocs = x.PColorBlendState.PassRef()
	allocs178f88b6.Borrow(cpColorBlendState_allocs)

	var cpDynamicState_allocs *cgoAllocMap
	ref178f88b6.pDynamicState, cpDynamicState_allocs = x.PDynamicState.PassRef()
	allocs178f88b6.Borrow(cpDynamicState_allocs)

	var clayout_allocs *cgoAllocMap
	ref178f88b6.layout, clayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.Layout)), cgoAllocsUnknown
	allocs178f88b6.Borrow(clayout_allocs)

	var crenderPass_allocs *cgoAllocMap
	ref178f88b6.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocs178f88b6.Borrow(crenderPass_allocs)

	var csubpass_allocs *cgoAllocMap
	ref178f88b6.subpass, csubpass_allocs = (C.uint32_t)(x.Subpass), cgoAllocsUnknown
	allocs178f88b6.Borrow(csubpass_allocs)

	var cbasePipelineHandle_allocs *cgoAllocMap
	ref178f88b6.basePipelineHandle, cbasePipelineHandle_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.BasePipelineHandle)), cgoAllocsUnknown
	allocs178f88b6.Borrow(cbasePipelineHandle_allocs)

	var cbasePipelineIndex_allocs *cgoAllocMap
	ref178f88b6.basePipelineIndex, cbasePipelineIndex_allocs = (C.int32_t)(x.BasePipelineIndex), cgoAllocsUnknown
	allocs178f88b6.Borrow(cbasePipelineIndex_allocs)

	x.ref178f88b6 = ref178f88b6
	x.allocs178f88b6 = allocs178f88b6
	return ref178f88b6, allocs178f88b6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GraphicsPipelineCreateInfo) PassValue() (C.VkGraphicsPipelineCreateInfo, *cgoAllocMap) {
	if x.ref178f88b6 != nil {
		return *x.ref178f88b6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GraphicsPipelineCreateInfo) Deref() {
	if x.ref178f88b6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref178f88b6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref178f88b6.pNext))
	x.Flags = (PipelineCreateFlags)(x.ref178f88b6.flags)
	x.StageCount = (uint32)(x.ref178f88b6.stageCount)
	packSPipelineShaderStageCreateInfo(x.PStages, x.ref178f88b6.pStages)
	x.PVertexInputState = NewPipelineVertexInputStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pVertexInputState))
	x.PInputAssemblyState = NewPipelineInputAssemblyStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pInputAssemblyState))
	x.PTessellationState = NewPipelineTessellationStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pTessellationState))
	x.PViewportState = NewPipelineViewportStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pViewportState))
	x.PRasterizationState = NewPipelineRasterizationStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pRasterizationState))
	x.PMultisampleState = NewPipelineMultisampleStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pMultisampleState))
	x.PDepthStencilState = NewPipelineDepthStencilStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pDepthStencilState))
	x.PColorBlendState = NewPipelineColorBlendStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pColorBlendState))
	x.PDynamicState = NewPipelineDynamicStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pDynamicState))
	x.Layout = *(*PipelineLayout)(unsafe.Pointer(&x.ref178f88b6.layout))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref178f88b6.renderPass))
	x.Subpass = (uint32)(x.ref178f88b6.subpass)
	x.BasePipelineHandle = *(*Pipeline)(unsafe.Pointer(&x.ref178f88b6.basePipelineHandle))
	x.BasePipelineIndex = (int32)(x.ref178f88b6.basePipelineIndex)
}

// allocComputePipelineCreateInfoMemory allocates memory for type C.VkComputePipelineCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocComputePipelineCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfComputePipelineCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfComputePipelineCreateInfoValue = unsafe.Sizeof([1]C.VkComputePipelineCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ComputePipelineCreateInfo) Ref() *C.VkComputePipelineCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref77823220
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ComputePipelineCreateInfo) Free() {
	if x != nil && x.allocs77823220 != nil {
		x.allocs77823220.(*cgoAllocMap).Free()
		x.ref77823220 = nil
	}
}

// NewComputePipelineCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewComputePipelineCreateInfoRef(ref unsafe.Pointer) *ComputePipelineCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ComputePipelineCreateInfo)
	obj.ref77823220 = (*C.VkComputePipelineCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ComputePipelineCreateInfo) PassRef() (*C.VkComputePipelineCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref77823220 != nil {
		return x.ref77823220, nil
	}
	mem77823220 := allocComputePipelineCreateInfoMemory(1)
	ref77823220 := (*C.VkComputePipelineCreateInfo)(mem77823220)
	allocs77823220 := new(cgoAllocMap)
	allocs77823220.Add(mem77823220)

	var csType_allocs *cgoAllocMap
	ref77823220.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs77823220.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref77823220.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs77823220.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref77823220.flags, cflags_allocs = (C.VkPipelineCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs77823220.Borrow(cflags_allocs)

	var cstage_allocs *cgoAllocMap
	ref77823220.stage, cstage_allocs = x.Stage.PassValue()
	allocs77823220.Borrow(cstage_allocs)

	var clayout_allocs *cgoAllocMap
	ref77823220.layout, clayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.Layout)), cgoAllocsUnknown
	allocs77823220.Borrow(clayout_allocs)

	var cbasePipelineHandle_allocs *cgoAllocMap
	ref77823220.basePipelineHandle, cbasePipelineHandle_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.BasePipelineHandle)), cgoAllocsUnknown
	allocs77823220.Borrow(cbasePipelineHandle_allocs)

	var cbasePipelineIndex_allocs *cgoAllocMap
	ref77823220.basePipelineIndex, cbasePipelineIndex_allocs = (C.int32_t)(x.BasePipelineIndex), cgoAllocsUnknown
	allocs77823220.Borrow(cbasePipelineIndex_allocs)

	x.ref77823220 = ref77823220
	x.allocs77823220 = allocs77823220
	return ref77823220, allocs77823220

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ComputePipelineCreateInfo) PassValue() (C.VkComputePipelineCreateInfo, *cgoAllocMap) {
	if x.ref77823220 != nil {
		return *x.ref77823220, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ComputePipelineCreateInfo) Deref() {
	if x.ref77823220 == nil {
		return
	}
	x.SType = (StructureType)(x.ref77823220.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref77823220.pNext))
	x.Flags = (PipelineCreateFlags)(x.ref77823220.flags)
	x.Stage = *NewPipelineShaderStageCreateInfoRef(unsafe.Pointer(&x.ref77823220.stage))
	x.Layout = *(*PipelineLayout)(unsafe.Pointer(&x.ref77823220.layout))
	x.BasePipelineHandle = *(*Pipeline)(unsafe.Pointer(&x.ref77823220.basePipelineHandle))
	x.BasePipelineIndex = (int32)(x.ref77823220.basePipelineIndex)
}

// allocPushConstantRangeMemory allocates memory for type C.VkPushConstantRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPushConstantRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPushConstantRangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPushConstantRangeValue = unsafe.Sizeof([1]C.VkPushConstantRange{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PushConstantRange) Ref() *C.VkPushConstantRange {
	if x == nil {
		return nil
	}
	return x.ref6f025856
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PushConstantRange) Free() {
	if x != nil && x.allocs6f025856 != nil {
		x.allocs6f025856.(*cgoAllocMap).Free()
		x.ref6f025856 = nil
	}
}

// NewPushConstantRangeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPushConstantRangeRef(ref unsafe.Pointer) *PushConstantRange {
	if ref == nil {
		return nil
	}
	obj := new(PushConstantRange)
	obj.ref6f025856 = (*C.VkPushConstantRange)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PushConstantRange) PassRef() (*C.VkPushConstantRange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6f025856 != nil {
		return x.ref6f025856, nil
	}
	mem6f025856 := allocPushConstantRangeMemory(1)
	ref6f025856 := (*C.VkPushConstantRange)(mem6f025856)
	allocs6f025856 := new(cgoAllocMap)
	allocs6f025856.Add(mem6f025856)

	var cstageFlags_allocs *cgoAllocMap
	ref6f025856.stageFlags, cstageFlags_allocs = (C.VkShaderStageFlags)(x.StageFlags), cgoAllocsUnknown
	allocs6f025856.Borrow(cstageFlags_allocs)

	var coffset_allocs *cgoAllocMap
	ref6f025856.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocs6f025856.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	ref6f025856.size, csize_allocs = (C.uint32_t)(x.Size), cgoAllocsUnknown
	allocs6f025856.Borrow(csize_allocs)

	x.ref6f025856 = ref6f025856
	x.allocs6f025856 = allocs6f025856
	return ref6f025856, allocs6f025856

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PushConstantRange) PassValue() (C.VkPushConstantRange, *cgoAllocMap) {
	if x.ref6f025856 != nil {
		return *x.ref6f025856, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PushConstantRange) Deref() {
	if x.ref6f025856 == nil {
		return
	}
	x.StageFlags = (ShaderStageFlags)(x.ref6f025856.stageFlags)
	x.Offset = (uint32)(x.ref6f025856.offset)
	x.Size = (uint32)(x.ref6f025856.size)
}

// allocPipelineLayoutCreateInfoMemory allocates memory for type C.VkPipelineLayoutCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineLayoutCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineLayoutCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineLayoutCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineLayoutCreateInfo{})

// unpackSPushConstantRange transforms a sliced Go data structure into plain C format.
func unpackSPushConstantRange(x []PushConstantRange) (unpacked *C.VkPushConstantRange, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPushConstantRange) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPushConstantRangeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPushConstantRange)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPushConstantRange)(h.Data)
	return
}

// packSPushConstantRange reads sliced Go data structure out from plain C format.
func packSPushConstantRange(v []PushConstantRange, ptr0 *C.VkPushConstantRange) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPushConstantRangeValue]C.VkPushConstantRange)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPushConstantRangeRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineLayoutCreateInfo) Ref() *C.VkPipelineLayoutCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref64cc4eed
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineLayoutCreateInfo) Free() {
	if x != nil && x.allocs64cc4eed != nil {
		x.allocs64cc4eed.(*cgoAllocMap).Free()
		x.ref64cc4eed = nil
	}
}

// NewPipelineLayoutCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineLayoutCreateInfoRef(ref unsafe.Pointer) *PipelineLayoutCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineLayoutCreateInfo)
	obj.ref64cc4eed = (*C.VkPipelineLayoutCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineLayoutCreateInfo) PassRef() (*C.VkPipelineLayoutCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref64cc4eed != nil {
		return x.ref64cc4eed, nil
	}
	mem64cc4eed := allocPipelineLayoutCreateInfoMemory(1)
	ref64cc4eed := (*C.VkPipelineLayoutCreateInfo)(mem64cc4eed)
	allocs64cc4eed := new(cgoAllocMap)
	allocs64cc4eed.Add(mem64cc4eed)

	var csType_allocs *cgoAllocMap
	ref64cc4eed.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs64cc4eed.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref64cc4eed.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref64cc4eed.flags, cflags_allocs = (C.VkPipelineLayoutCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cflags_allocs)

	var csetLayoutCount_allocs *cgoAllocMap
	ref64cc4eed.setLayoutCount, csetLayoutCount_allocs = (C.uint32_t)(x.SetLayoutCount), cgoAllocsUnknown
	allocs64cc4eed.Borrow(csetLayoutCount_allocs)

	var cpSetLayouts_allocs *cgoAllocMap
	ref64cc4eed.pSetLayouts, cpSetLayouts_allocs = (*C.VkDescriptorSetLayout)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSetLayouts)).Data)), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cpSetLayouts_allocs)

	var cpushConstantRangeCount_allocs *cgoAllocMap
	ref64cc4eed.pushConstantRangeCount, cpushConstantRangeCount_allocs = (C.uint32_t)(x.PushConstantRangeCount), cgoAllocsUnknown
	allocs64cc4eed.Borrow(cpushConstantRangeCount_allocs)

	var cpPushConstantRanges_allocs *cgoAllocMap
	ref64cc4eed.pPushConstantRanges, cpPushConstantRanges_allocs = unpackSPushConstantRange(x.PPushConstantRanges)
	allocs64cc4eed.Borrow(cpPushConstantRanges_allocs)

	x.ref64cc4eed = ref64cc4eed
	x.allocs64cc4eed = allocs64cc4eed
	return ref64cc4eed, allocs64cc4eed

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineLayoutCreateInfo) PassValue() (C.VkPipelineLayoutCreateInfo, *cgoAllocMap) {
	if x.ref64cc4eed != nil {
		return *x.ref64cc4eed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineLayoutCreateInfo) Deref() {
	if x.ref64cc4eed == nil {
		return
	}
	x.SType = (StructureType)(x.ref64cc4eed.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref64cc4eed.pNext))
	x.Flags = (PipelineLayoutCreateFlags)(x.ref64cc4eed.flags)
	x.SetLayoutCount = (uint32)(x.ref64cc4eed.setLayoutCount)
	hxfe48d67 := (*sliceHeader)(unsafe.Pointer(&x.PSetLayouts))
	hxfe48d67.Data = unsafe.Pointer(x.ref64cc4eed.pSetLayouts)
	hxfe48d67.Cap = 0x7fffffff
	// hxfe48d67.Len = ?

	x.PushConstantRangeCount = (uint32)(x.ref64cc4eed.pushConstantRangeCount)
	packSPushConstantRange(x.PPushConstantRanges, x.ref64cc4eed.pPushConstantRanges)
}

// allocSamplerCreateInfoMemory allocates memory for type C.VkSamplerCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSamplerCreateInfoValue = unsafe.Sizeof([1]C.VkSamplerCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerCreateInfo) Ref() *C.VkSamplerCreateInfo {
	if x == nil {
		return nil
	}
	return x.refce034abf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerCreateInfo) Free() {
	if x != nil && x.allocsce034abf != nil {
		x.allocsce034abf.(*cgoAllocMap).Free()
		x.refce034abf = nil
	}
}

// NewSamplerCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerCreateInfoRef(ref unsafe.Pointer) *SamplerCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SamplerCreateInfo)
	obj.refce034abf = (*C.VkSamplerCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerCreateInfo) PassRef() (*C.VkSamplerCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refce034abf != nil {
		return x.refce034abf, nil
	}
	memce034abf := allocSamplerCreateInfoMemory(1)
	refce034abf := (*C.VkSamplerCreateInfo)(memce034abf)
	allocsce034abf := new(cgoAllocMap)
	allocsce034abf.Add(memce034abf)

	var csType_allocs *cgoAllocMap
	refce034abf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsce034abf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refce034abf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsce034abf.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refce034abf.flags, cflags_allocs = (C.VkSamplerCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsce034abf.Borrow(cflags_allocs)

	var cmagFilter_allocs *cgoAllocMap
	refce034abf.magFilter, cmagFilter_allocs = (C.VkFilter)(x.MagFilter), cgoAllocsUnknown
	allocsce034abf.Borrow(cmagFilter_allocs)

	var cminFilter_allocs *cgoAllocMap
	refce034abf.minFilter, cminFilter_allocs = (C.VkFilter)(x.MinFilter), cgoAllocsUnknown
	allocsce034abf.Borrow(cminFilter_allocs)

	var cmipmapMode_allocs *cgoAllocMap
	refce034abf.mipmapMode, cmipmapMode_allocs = (C.VkSamplerMipmapMode)(x.MipmapMode), cgoAllocsUnknown
	allocsce034abf.Borrow(cmipmapMode_allocs)

	var caddressModeU_allocs *cgoAllocMap
	refce034abf.addressModeU, caddressModeU_allocs = (C.VkSamplerAddressMode)(x.AddressModeU), cgoAllocsUnknown
	allocsce034abf.Borrow(caddressModeU_allocs)

	var caddressModeV_allocs *cgoAllocMap
	refce034abf.addressModeV, caddressModeV_allocs = (C.VkSamplerAddressMode)(x.AddressModeV), cgoAllocsUnknown
	allocsce034abf.Borrow(caddressModeV_allocs)

	var caddressModeW_allocs *cgoAllocMap
	refce034abf.addressModeW, caddressModeW_allocs = (C.VkSamplerAddressMode)(x.AddressModeW), cgoAllocsUnknown
	allocsce034abf.Borrow(caddressModeW_allocs)

	var cmipLodBias_allocs *cgoAllocMap
	refce034abf.mipLodBias, cmipLodBias_allocs = (C.float)(x.MipLodBias), cgoAllocsUnknown
	allocsce034abf.Borrow(cmipLodBias_allocs)

	var canisotropyEnable_allocs *cgoAllocMap
	refce034abf.anisotropyEnable, canisotropyEnable_allocs = (C.VkBool32)(x.AnisotropyEnable), cgoAllocsUnknown
	allocsce034abf.Borrow(canisotropyEnable_allocs)

	var cmaxAnisotropy_allocs *cgoAllocMap
	refce034abf.maxAnisotropy, cmaxAnisotropy_allocs = (C.float)(x.MaxAnisotropy), cgoAllocsUnknown
	allocsce034abf.Borrow(cmaxAnisotropy_allocs)

	var ccompareEnable_allocs *cgoAllocMap
	refce034abf.compareEnable, ccompareEnable_allocs = (C.VkBool32)(x.CompareEnable), cgoAllocsUnknown
	allocsce034abf.Borrow(ccompareEnable_allocs)

	var ccompareOp_allocs *cgoAllocMap
	refce034abf.compareOp, ccompareOp_allocs = (C.VkCompareOp)(x.CompareOp), cgoAllocsUnknown
	allocsce034abf.Borrow(ccompareOp_allocs)

	var cminLod_allocs *cgoAllocMap
	refce034abf.minLod, cminLod_allocs = (C.float)(x.MinLod), cgoAllocsUnknown
	allocsce034abf.Borrow(cminLod_allocs)

	var cmaxLod_allocs *cgoAllocMap
	refce034abf.maxLod, cmaxLod_allocs = (C.float)(x.MaxLod), cgoAllocsUnknown
	allocsce034abf.Borrow(cmaxLod_allocs)

	var cborderColor_allocs *cgoAllocMap
	refce034abf.borderColor, cborderColor_allocs = (C.VkBorderColor)(x.BorderColor), cgoAllocsUnknown
	allocsce034abf.Borrow(cborderColor_allocs)

	var cunnormalizedCoordinates_allocs *cgoAllocMap
	refce034abf.unnormalizedCoordinates, cunnormalizedCoordinates_allocs = (C.VkBool32)(x.UnnormalizedCoordinates), cgoAllocsUnknown
	allocsce034abf.Borrow(cunnormalizedCoordinates_allocs)

	x.refce034abf = refce034abf
	x.allocsce034abf = allocsce034abf
	return refce034abf, allocsce034abf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerCreateInfo) PassValue() (C.VkSamplerCreateInfo, *cgoAllocMap) {
	if x.refce034abf != nil {
		return *x.refce034abf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerCreateInfo) Deref() {
	if x.refce034abf == nil {
		return
	}
	x.SType = (StructureType)(x.refce034abf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refce034abf.pNext))
	x.Flags = (SamplerCreateFlags)(x.refce034abf.flags)
	x.MagFilter = (Filter)(x.refce034abf.magFilter)
	x.MinFilter = (Filter)(x.refce034abf.minFilter)
	x.MipmapMode = (SamplerMipmapMode)(x.refce034abf.mipmapMode)
	x.AddressModeU = (SamplerAddressMode)(x.refce034abf.addressModeU)
	x.AddressModeV = (SamplerAddressMode)(x.refce034abf.addressModeV)
	x.AddressModeW = (SamplerAddressMode)(x.refce034abf.addressModeW)
	x.MipLodBias = (float32)(x.refce034abf.mipLodBias)
	x.AnisotropyEnable = (Bool32)(x.refce034abf.anisotropyEnable)
	x.MaxAnisotropy = (float32)(x.refce034abf.maxAnisotropy)
	x.CompareEnable = (Bool32)(x.refce034abf.compareEnable)
	x.CompareOp = (CompareOp)(x.refce034abf.compareOp)
	x.MinLod = (float32)(x.refce034abf.minLod)
	x.MaxLod = (float32)(x.refce034abf.maxLod)
	x.BorderColor = (BorderColor)(x.refce034abf.borderColor)
	x.UnnormalizedCoordinates = (Bool32)(x.refce034abf.unnormalizedCoordinates)
}

// allocDescriptorSetLayoutBindingMemory allocates memory for type C.VkDescriptorSetLayoutBinding in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutBindingMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutBindingValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetLayoutBindingValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutBinding{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetLayoutBinding) Ref() *C.VkDescriptorSetLayoutBinding {
	if x == nil {
		return nil
	}
	return x.ref8b50b4ec
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetLayoutBinding) Free() {
	if x != nil && x.allocs8b50b4ec != nil {
		x.allocs8b50b4ec.(*cgoAllocMap).Free()
		x.ref8b50b4ec = nil
	}
}

// NewDescriptorSetLayoutBindingRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetLayoutBindingRef(ref unsafe.Pointer) *DescriptorSetLayoutBinding {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutBinding)
	obj.ref8b50b4ec = (*C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetLayoutBinding) PassRef() (*C.VkDescriptorSetLayoutBinding, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8b50b4ec != nil {
		return x.ref8b50b4ec, nil
	}
	mem8b50b4ec := allocDescriptorSetLayoutBindingMemory(1)
	ref8b50b4ec := (*C.VkDescriptorSetLayoutBinding)(mem8b50b4ec)
	allocs8b50b4ec := new(cgoAllocMap)
	allocs8b50b4ec.Add(mem8b50b4ec)

	var cbinding_allocs *cgoAllocMap
	ref8b50b4ec.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cbinding_allocs)

	var cdescriptorType_allocs *cgoAllocMap
	ref8b50b4ec.descriptorType, cdescriptorType_allocs = (C.VkDescriptorType)(x.DescriptorType), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cdescriptorType_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	ref8b50b4ec.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cdescriptorCount_allocs)

	var cstageFlags_allocs *cgoAllocMap
	ref8b50b4ec.stageFlags, cstageFlags_allocs = (C.VkShaderStageFlags)(x.StageFlags), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cstageFlags_allocs)

	var cpImmutableSamplers_allocs *cgoAllocMap
	ref8b50b4ec.pImmutableSamplers, cpImmutableSamplers_allocs = (*C.VkSampler)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PImmutableSamplers)).Data)), cgoAllocsUnknown
	allocs8b50b4ec.Borrow(cpImmutableSamplers_allocs)

	x.ref8b50b4ec = ref8b50b4ec
	x.allocs8b50b4ec = allocs8b50b4ec
	return ref8b50b4ec, allocs8b50b4ec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetLayoutBinding) PassValue() (C.VkDescriptorSetLayoutBinding, *cgoAllocMap) {
	if x.ref8b50b4ec != nil {
		return *x.ref8b50b4ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetLayoutBinding) Deref() {
	if x.ref8b50b4ec == nil {
		return
	}
	x.Binding = (uint32)(x.ref8b50b4ec.binding)
	x.DescriptorType = (DescriptorType)(x.ref8b50b4ec.descriptorType)
	x.DescriptorCount = (uint32)(x.ref8b50b4ec.descriptorCount)
	x.StageFlags = (ShaderStageFlags)(x.ref8b50b4ec.stageFlags)
	hxf4171bf := (*sliceHeader)(unsafe.Pointer(&x.PImmutableSamplers))
	hxf4171bf.Data = unsafe.Pointer(x.ref8b50b4ec.pImmutableSamplers)
	hxf4171bf.Cap = 0x7fffffff
	// hxf4171bf.Len = ?

}

// allocDescriptorSetLayoutCreateInfoMemory allocates memory for type C.VkDescriptorSetLayoutCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetLayoutCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutCreateInfo{})

// unpackSDescriptorSetLayoutBinding transforms a sliced Go data structure into plain C format.
func unpackSDescriptorSetLayoutBinding(x []DescriptorSetLayoutBinding) (unpacked *C.VkDescriptorSetLayoutBinding, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorSetLayoutBinding) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorSetLayoutBindingMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorSetLayoutBinding)(h.Data)
	return
}

// packSDescriptorSetLayoutBinding reads sliced Go data structure out from plain C format.
func packSDescriptorSetLayoutBinding(v []DescriptorSetLayoutBinding, ptr0 *C.VkDescriptorSetLayoutBinding) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorSetLayoutBindingValue]C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorSetLayoutBindingRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetLayoutCreateInfo) Ref() *C.VkDescriptorSetLayoutCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref5ee8e0ed
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetLayoutCreateInfo) Free() {
	if x != nil && x.allocs5ee8e0ed != nil {
		x.allocs5ee8e0ed.(*cgoAllocMap).Free()
		x.ref5ee8e0ed = nil
	}
}

// NewDescriptorSetLayoutCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetLayoutCreateInfoRef(ref unsafe.Pointer) *DescriptorSetLayoutCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutCreateInfo)
	obj.ref5ee8e0ed = (*C.VkDescriptorSetLayoutCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetLayoutCreateInfo) PassRef() (*C.VkDescriptorSetLayoutCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ee8e0ed != nil {
		return x.ref5ee8e0ed, nil
	}
	mem5ee8e0ed := allocDescriptorSetLayoutCreateInfoMemory(1)
	ref5ee8e0ed := (*C.VkDescriptorSetLayoutCreateInfo)(mem5ee8e0ed)
	allocs5ee8e0ed := new(cgoAllocMap)
	allocs5ee8e0ed.Add(mem5ee8e0ed)

	var csType_allocs *cgoAllocMap
	ref5ee8e0ed.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5ee8e0ed.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref5ee8e0ed.flags, cflags_allocs = (C.VkDescriptorSetLayoutCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(cflags_allocs)

	var cbindingCount_allocs *cgoAllocMap
	ref5ee8e0ed.bindingCount, cbindingCount_allocs = (C.uint32_t)(x.BindingCount), cgoAllocsUnknown
	allocs5ee8e0ed.Borrow(cbindingCount_allocs)

	var cpBindings_allocs *cgoAllocMap
	ref5ee8e0ed.pBindings, cpBindings_allocs = unpackSDescriptorSetLayoutBinding(x.PBindings)
	allocs5ee8e0ed.Borrow(cpBindings_allocs)

	x.ref5ee8e0ed = ref5ee8e0ed
	x.allocs5ee8e0ed = allocs5ee8e0ed
	return ref5ee8e0ed, allocs5ee8e0ed

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetLayoutCreateInfo) PassValue() (C.VkDescriptorSetLayoutCreateInfo, *cgoAllocMap) {
	if x.ref5ee8e0ed != nil {
		return *x.ref5ee8e0ed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetLayoutCreateInfo) Deref() {
	if x.ref5ee8e0ed == nil {
		return
	}
	x.SType = (StructureType)(x.ref5ee8e0ed.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5ee8e0ed.pNext))
	x.Flags = (DescriptorSetLayoutCreateFlags)(x.ref5ee8e0ed.flags)
	x.BindingCount = (uint32)(x.ref5ee8e0ed.bindingCount)
	packSDescriptorSetLayoutBinding(x.PBindings, x.ref5ee8e0ed.pBindings)
}

// allocDescriptorPoolSizeMemory allocates memory for type C.VkDescriptorPoolSize in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorPoolSizeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorPoolSizeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorPoolSizeValue = unsafe.Sizeof([1]C.VkDescriptorPoolSize{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorPoolSize) Ref() *C.VkDescriptorPoolSize {
	if x == nil {
		return nil
	}
	return x.refe15137da
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorPoolSize) Free() {
	if x != nil && x.allocse15137da != nil {
		x.allocse15137da.(*cgoAllocMap).Free()
		x.refe15137da = nil
	}
}

// NewDescriptorPoolSizeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorPoolSizeRef(ref unsafe.Pointer) *DescriptorPoolSize {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorPoolSize)
	obj.refe15137da = (*C.VkDescriptorPoolSize)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorPoolSize) PassRef() (*C.VkDescriptorPoolSize, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe15137da != nil {
		return x.refe15137da, nil
	}
	meme15137da := allocDescriptorPoolSizeMemory(1)
	refe15137da := (*C.VkDescriptorPoolSize)(meme15137da)
	allocse15137da := new(cgoAllocMap)
	allocse15137da.Add(meme15137da)

	var c_type_allocs *cgoAllocMap
	refe15137da._type, c_type_allocs = (C.VkDescriptorType)(x.Type), cgoAllocsUnknown
	allocse15137da.Borrow(c_type_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	refe15137da.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocse15137da.Borrow(cdescriptorCount_allocs)

	x.refe15137da = refe15137da
	x.allocse15137da = allocse15137da
	return refe15137da, allocse15137da

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorPoolSize) PassValue() (C.VkDescriptorPoolSize, *cgoAllocMap) {
	if x.refe15137da != nil {
		return *x.refe15137da, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorPoolSize) Deref() {
	if x.refe15137da == nil {
		return
	}
	x.Type = (DescriptorType)(x.refe15137da._type)
	x.DescriptorCount = (uint32)(x.refe15137da.descriptorCount)
}

// allocDescriptorPoolCreateInfoMemory allocates memory for type C.VkDescriptorPoolCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorPoolCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorPoolCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorPoolCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorPoolCreateInfo{})

// unpackSDescriptorPoolSize transforms a sliced Go data structure into plain C format.
func unpackSDescriptorPoolSize(x []DescriptorPoolSize) (unpacked *C.VkDescriptorPoolSize, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorPoolSize) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorPoolSizeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorPoolSize)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorPoolSize)(h.Data)
	return
}

// packSDescriptorPoolSize reads sliced Go data structure out from plain C format.
func packSDescriptorPoolSize(v []DescriptorPoolSize, ptr0 *C.VkDescriptorPoolSize) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorPoolSizeValue]C.VkDescriptorPoolSize)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorPoolSizeRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorPoolCreateInfo) Ref() *C.VkDescriptorPoolCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref19868463
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorPoolCreateInfo) Free() {
	if x != nil && x.allocs19868463 != nil {
		x.allocs19868463.(*cgoAllocMap).Free()
		x.ref19868463 = nil
	}
}

// NewDescriptorPoolCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorPoolCreateInfoRef(ref unsafe.Pointer) *DescriptorPoolCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorPoolCreateInfo)
	obj.ref19868463 = (*C.VkDescriptorPoolCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorPoolCreateInfo) PassRef() (*C.VkDescriptorPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref19868463 != nil {
		return x.ref19868463, nil
	}
	mem19868463 := allocDescriptorPoolCreateInfoMemory(1)
	ref19868463 := (*C.VkDescriptorPoolCreateInfo)(mem19868463)
	allocs19868463 := new(cgoAllocMap)
	allocs19868463.Add(mem19868463)

	var csType_allocs *cgoAllocMap
	ref19868463.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs19868463.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref19868463.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs19868463.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref19868463.flags, cflags_allocs = (C.VkDescriptorPoolCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs19868463.Borrow(cflags_allocs)

	var cmaxSets_allocs *cgoAllocMap
	ref19868463.maxSets, cmaxSets_allocs = (C.uint32_t)(x.MaxSets), cgoAllocsUnknown
	allocs19868463.Borrow(cmaxSets_allocs)

	var cpoolSizeCount_allocs *cgoAllocMap
	ref19868463.poolSizeCount, cpoolSizeCount_allocs = (C.uint32_t)(x.PoolSizeCount), cgoAllocsUnknown
	allocs19868463.Borrow(cpoolSizeCount_allocs)

	var cpPoolSizes_allocs *cgoAllocMap
	ref19868463.pPoolSizes, cpPoolSizes_allocs = unpackSDescriptorPoolSize(x.PPoolSizes)
	allocs19868463.Borrow(cpPoolSizes_allocs)

	x.ref19868463 = ref19868463
	x.allocs19868463 = allocs19868463
	return ref19868463, allocs19868463

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorPoolCreateInfo) PassValue() (C.VkDescriptorPoolCreateInfo, *cgoAllocMap) {
	if x.ref19868463 != nil {
		return *x.ref19868463, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorPoolCreateInfo) Deref() {
	if x.ref19868463 == nil {
		return
	}
	x.SType = (StructureType)(x.ref19868463.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref19868463.pNext))
	x.Flags = (DescriptorPoolCreateFlags)(x.ref19868463.flags)
	x.MaxSets = (uint32)(x.ref19868463.maxSets)
	x.PoolSizeCount = (uint32)(x.ref19868463.poolSizeCount)
	packSDescriptorPoolSize(x.PPoolSizes, x.ref19868463.pPoolSizes)
}

// allocDescriptorSetAllocateInfoMemory allocates memory for type C.VkDescriptorSetAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetAllocateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetAllocateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetAllocateInfo) Ref() *C.VkDescriptorSetAllocateInfo {
	if x == nil {
		return nil
	}
	return x.ref2dd6cc22
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetAllocateInfo) Free() {
	if x != nil && x.allocs2dd6cc22 != nil {
		x.allocs2dd6cc22.(*cgoAllocMap).Free()
		x.ref2dd6cc22 = nil
	}
}

// NewDescriptorSetAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetAllocateInfoRef(ref unsafe.Pointer) *DescriptorSetAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetAllocateInfo)
	obj.ref2dd6cc22 = (*C.VkDescriptorSetAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetAllocateInfo) PassRef() (*C.VkDescriptorSetAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2dd6cc22 != nil {
		return x.ref2dd6cc22, nil
	}
	mem2dd6cc22 := allocDescriptorSetAllocateInfoMemory(1)
	ref2dd6cc22 := (*C.VkDescriptorSetAllocateInfo)(mem2dd6cc22)
	allocs2dd6cc22 := new(cgoAllocMap)
	allocs2dd6cc22.Add(mem2dd6cc22)

	var csType_allocs *cgoAllocMap
	ref2dd6cc22.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2dd6cc22.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cpNext_allocs)

	var cdescriptorPool_allocs *cgoAllocMap
	ref2dd6cc22.descriptorPool, cdescriptorPool_allocs = *(*C.VkDescriptorPool)(unsafe.Pointer(&x.DescriptorPool)), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cdescriptorPool_allocs)

	var cdescriptorSetCount_allocs *cgoAllocMap
	ref2dd6cc22.descriptorSetCount, cdescriptorSetCount_allocs = (C.uint32_t)(x.DescriptorSetCount), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cdescriptorSetCount_allocs)

	var cpSetLayouts_allocs *cgoAllocMap
	ref2dd6cc22.pSetLayouts, cpSetLayouts_allocs = (*C.VkDescriptorSetLayout)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSetLayouts)).Data)), cgoAllocsUnknown
	allocs2dd6cc22.Borrow(cpSetLayouts_allocs)

	x.ref2dd6cc22 = ref2dd6cc22
	x.allocs2dd6cc22 = allocs2dd6cc22
	return ref2dd6cc22, allocs2dd6cc22

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetAllocateInfo) PassValue() (C.VkDescriptorSetAllocateInfo, *cgoAllocMap) {
	if x.ref2dd6cc22 != nil {
		return *x.ref2dd6cc22, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetAllocateInfo) Deref() {
	if x.ref2dd6cc22 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2dd6cc22.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2dd6cc22.pNext))
	x.DescriptorPool = *(*DescriptorPool)(unsafe.Pointer(&x.ref2dd6cc22.descriptorPool))
	x.DescriptorSetCount = (uint32)(x.ref2dd6cc22.descriptorSetCount)
	hxf058b18 := (*sliceHeader)(unsafe.Pointer(&x.PSetLayouts))
	hxf058b18.Data = unsafe.Pointer(x.ref2dd6cc22.pSetLayouts)
	hxf058b18.Cap = 0x7fffffff
	// hxf058b18.Len = ?

}

// allocDescriptorImageInfoMemory allocates memory for type C.VkDescriptorImageInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorImageInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorImageInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorImageInfoValue = unsafe.Sizeof([1]C.VkDescriptorImageInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorImageInfo) Ref() *C.VkDescriptorImageInfo {
	if x == nil {
		return nil
	}
	return x.refaf073b07
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorImageInfo) Free() {
	if x != nil && x.allocsaf073b07 != nil {
		x.allocsaf073b07.(*cgoAllocMap).Free()
		x.refaf073b07 = nil
	}
}

// NewDescriptorImageInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorImageInfoRef(ref unsafe.Pointer) *DescriptorImageInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorImageInfo)
	obj.refaf073b07 = (*C.VkDescriptorImageInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorImageInfo) PassRef() (*C.VkDescriptorImageInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaf073b07 != nil {
		return x.refaf073b07, nil
	}
	memaf073b07 := allocDescriptorImageInfoMemory(1)
	refaf073b07 := (*C.VkDescriptorImageInfo)(memaf073b07)
	allocsaf073b07 := new(cgoAllocMap)
	allocsaf073b07.Add(memaf073b07)

	var csampler_allocs *cgoAllocMap
	refaf073b07.sampler, csampler_allocs = *(*C.VkSampler)(unsafe.Pointer(&x.Sampler)), cgoAllocsUnknown
	allocsaf073b07.Borrow(csampler_allocs)

	var cimageView_allocs *cgoAllocMap
	refaf073b07.imageView, cimageView_allocs = *(*C.VkImageView)(unsafe.Pointer(&x.ImageView)), cgoAllocsUnknown
	allocsaf073b07.Borrow(cimageView_allocs)

	var cimageLayout_allocs *cgoAllocMap
	refaf073b07.imageLayout, cimageLayout_allocs = (C.VkImageLayout)(x.ImageLayout), cgoAllocsUnknown
	allocsaf073b07.Borrow(cimageLayout_allocs)

	x.refaf073b07 = refaf073b07
	x.allocsaf073b07 = allocsaf073b07
	return refaf073b07, allocsaf073b07

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorImageInfo) PassValue() (C.VkDescriptorImageInfo, *cgoAllocMap) {
	if x.refaf073b07 != nil {
		return *x.refaf073b07, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorImageInfo) Deref() {
	if x.refaf073b07 == nil {
		return
	}
	x.Sampler = *(*Sampler)(unsafe.Pointer(&x.refaf073b07.sampler))
	x.ImageView = *(*ImageView)(unsafe.Pointer(&x.refaf073b07.imageView))
	x.ImageLayout = (ImageLayout)(x.refaf073b07.imageLayout)
}

// allocDescriptorBufferInfoMemory allocates memory for type C.VkDescriptorBufferInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorBufferInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorBufferInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorBufferInfoValue = unsafe.Sizeof([1]C.VkDescriptorBufferInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorBufferInfo) Ref() *C.VkDescriptorBufferInfo {
	if x == nil {
		return nil
	}
	return x.refe64bec0e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorBufferInfo) Free() {
	if x != nil && x.allocse64bec0e != nil {
		x.allocse64bec0e.(*cgoAllocMap).Free()
		x.refe64bec0e = nil
	}
}

// NewDescriptorBufferInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorBufferInfoRef(ref unsafe.Pointer) *DescriptorBufferInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorBufferInfo)
	obj.refe64bec0e = (*C.VkDescriptorBufferInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorBufferInfo) PassRef() (*C.VkDescriptorBufferInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe64bec0e != nil {
		return x.refe64bec0e, nil
	}
	meme64bec0e := allocDescriptorBufferInfoMemory(1)
	refe64bec0e := (*C.VkDescriptorBufferInfo)(meme64bec0e)
	allocse64bec0e := new(cgoAllocMap)
	allocse64bec0e.Add(meme64bec0e)

	var cbuffer_allocs *cgoAllocMap
	refe64bec0e.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocse64bec0e.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	refe64bec0e.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocse64bec0e.Borrow(coffset_allocs)

	var c_range_allocs *cgoAllocMap
	refe64bec0e._range, c_range_allocs = (C.VkDeviceSize)(x.Range), cgoAllocsUnknown
	allocse64bec0e.Borrow(c_range_allocs)

	x.refe64bec0e = refe64bec0e
	x.allocse64bec0e = allocse64bec0e
	return refe64bec0e, allocse64bec0e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorBufferInfo) PassValue() (C.VkDescriptorBufferInfo, *cgoAllocMap) {
	if x.refe64bec0e != nil {
		return *x.refe64bec0e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorBufferInfo) Deref() {
	if x.refe64bec0e == nil {
		return
	}
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refe64bec0e.buffer))
	x.Offset = (DeviceSize)(x.refe64bec0e.offset)
	x.Range = (DeviceSize)(x.refe64bec0e._range)
}

// allocWriteDescriptorSetMemory allocates memory for type C.VkWriteDescriptorSet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWriteDescriptorSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWriteDescriptorSetValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfWriteDescriptorSetValue = unsafe.Sizeof([1]C.VkWriteDescriptorSet{})

// unpackSDescriptorImageInfo transforms a sliced Go data structure into plain C format.
func unpackSDescriptorImageInfo(x []DescriptorImageInfo) (unpacked *C.VkDescriptorImageInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorImageInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorImageInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorImageInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorImageInfo)(h.Data)
	return
}

// unpackSDescriptorBufferInfo transforms a sliced Go data structure into plain C format.
func unpackSDescriptorBufferInfo(x []DescriptorBufferInfo) (unpacked *C.VkDescriptorBufferInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorBufferInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorBufferInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorBufferInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorBufferInfo)(h.Data)
	return
}

// packSDescriptorImageInfo reads sliced Go data structure out from plain C format.
func packSDescriptorImageInfo(v []DescriptorImageInfo, ptr0 *C.VkDescriptorImageInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorImageInfoValue]C.VkDescriptorImageInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorImageInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSDescriptorBufferInfo reads sliced Go data structure out from plain C format.
func packSDescriptorBufferInfo(v []DescriptorBufferInfo, ptr0 *C.VkDescriptorBufferInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorBufferInfoValue]C.VkDescriptorBufferInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorBufferInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *WriteDescriptorSet) Ref() *C.VkWriteDescriptorSet {
	if x == nil {
		return nil
	}
	return x.ref3cec3f3f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *WriteDescriptorSet) Free() {
	if x != nil && x.allocs3cec3f3f != nil {
		x.allocs3cec3f3f.(*cgoAllocMap).Free()
		x.ref3cec3f3f = nil
	}
}

// NewWriteDescriptorSetRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWriteDescriptorSetRef(ref unsafe.Pointer) *WriteDescriptorSet {
	if ref == nil {
		return nil
	}
	obj := new(WriteDescriptorSet)
	obj.ref3cec3f3f = (*C.VkWriteDescriptorSet)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *WriteDescriptorSet) PassRef() (*C.VkWriteDescriptorSet, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3cec3f3f != nil {
		return x.ref3cec3f3f, nil
	}
	mem3cec3f3f := allocWriteDescriptorSetMemory(1)
	ref3cec3f3f := (*C.VkWriteDescriptorSet)(mem3cec3f3f)
	allocs3cec3f3f := new(cgoAllocMap)
	allocs3cec3f3f.Add(mem3cec3f3f)

	var csType_allocs *cgoAllocMap
	ref3cec3f3f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3cec3f3f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cpNext_allocs)

	var cdstSet_allocs *cgoAllocMap
	ref3cec3f3f.dstSet, cdstSet_allocs = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.DstSet)), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdstSet_allocs)

	var cdstBinding_allocs *cgoAllocMap
	ref3cec3f3f.dstBinding, cdstBinding_allocs = (C.uint32_t)(x.DstBinding), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdstBinding_allocs)

	var cdstArrayElement_allocs *cgoAllocMap
	ref3cec3f3f.dstArrayElement, cdstArrayElement_allocs = (C.uint32_t)(x.DstArrayElement), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdstArrayElement_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	ref3cec3f3f.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdescriptorCount_allocs)

	var cdescriptorType_allocs *cgoAllocMap
	ref3cec3f3f.descriptorType, cdescriptorType_allocs = (C.VkDescriptorType)(x.DescriptorType), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cdescriptorType_allocs)

	var cpImageInfo_allocs *cgoAllocMap
	ref3cec3f3f.pImageInfo, cpImageInfo_allocs = unpackSDescriptorImageInfo(x.PImageInfo)
	allocs3cec3f3f.Borrow(cpImageInfo_allocs)

	var cpBufferInfo_allocs *cgoAllocMap
	ref3cec3f3f.pBufferInfo, cpBufferInfo_allocs = unpackSDescriptorBufferInfo(x.PBufferInfo)
	allocs3cec3f3f.Borrow(cpBufferInfo_allocs)

	var cpTexelBufferView_allocs *cgoAllocMap
	ref3cec3f3f.pTexelBufferView, cpTexelBufferView_allocs = (*C.VkBufferView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PTexelBufferView)).Data)), cgoAllocsUnknown
	allocs3cec3f3f.Borrow(cpTexelBufferView_allocs)

	x.ref3cec3f3f = ref3cec3f3f
	x.allocs3cec3f3f = allocs3cec3f3f
	return ref3cec3f3f, allocs3cec3f3f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x WriteDescriptorSet) PassValue() (C.VkWriteDescriptorSet, *cgoAllocMap) {
	if x.ref3cec3f3f != nil {
		return *x.ref3cec3f3f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *WriteDescriptorSet) Deref() {
	if x.ref3cec3f3f == nil {
		return
	}
	x.SType = (StructureType)(x.ref3cec3f3f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3cec3f3f.pNext))
	x.DstSet = *(*DescriptorSet)(unsafe.Pointer(&x.ref3cec3f3f.dstSet))
	x.DstBinding = (uint32)(x.ref3cec3f3f.dstBinding)
	x.DstArrayElement = (uint32)(x.ref3cec3f3f.dstArrayElement)
	x.DescriptorCount = (uint32)(x.ref3cec3f3f.descriptorCount)
	x.DescriptorType = (DescriptorType)(x.ref3cec3f3f.descriptorType)
	packSDescriptorImageInfo(x.PImageInfo, x.ref3cec3f3f.pImageInfo)
	packSDescriptorBufferInfo(x.PBufferInfo, x.ref3cec3f3f.pBufferInfo)
	hxff6bc57 := (*sliceHeader)(unsafe.Pointer(&x.PTexelBufferView))
	hxff6bc57.Data = unsafe.Pointer(x.ref3cec3f3f.pTexelBufferView)
	hxff6bc57.Cap = 0x7fffffff
	// hxff6bc57.Len = ?

}

// allocCopyDescriptorSetMemory allocates memory for type C.VkCopyDescriptorSet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyDescriptorSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyDescriptorSetValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCopyDescriptorSetValue = unsafe.Sizeof([1]C.VkCopyDescriptorSet{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CopyDescriptorSet) Ref() *C.VkCopyDescriptorSet {
	if x == nil {
		return nil
	}
	return x.reffe237a3a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CopyDescriptorSet) Free() {
	if x != nil && x.allocsfe237a3a != nil {
		x.allocsfe237a3a.(*cgoAllocMap).Free()
		x.reffe237a3a = nil
	}
}

// NewCopyDescriptorSetRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCopyDescriptorSetRef(ref unsafe.Pointer) *CopyDescriptorSet {
	if ref == nil {
		return nil
	}
	obj := new(CopyDescriptorSet)
	obj.reffe237a3a = (*C.VkCopyDescriptorSet)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CopyDescriptorSet) PassRef() (*C.VkCopyDescriptorSet, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe237a3a != nil {
		return x.reffe237a3a, nil
	}
	memfe237a3a := allocCopyDescriptorSetMemory(1)
	reffe237a3a := (*C.VkCopyDescriptorSet)(memfe237a3a)
	allocsfe237a3a := new(cgoAllocMap)
	allocsfe237a3a.Add(memfe237a3a)

	var csType_allocs *cgoAllocMap
	reffe237a3a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffe237a3a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cpNext_allocs)

	var csrcSet_allocs *cgoAllocMap
	reffe237a3a.srcSet, csrcSet_allocs = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.SrcSet)), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csrcSet_allocs)

	var csrcBinding_allocs *cgoAllocMap
	reffe237a3a.srcBinding, csrcBinding_allocs = (C.uint32_t)(x.SrcBinding), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csrcBinding_allocs)

	var csrcArrayElement_allocs *cgoAllocMap
	reffe237a3a.srcArrayElement, csrcArrayElement_allocs = (C.uint32_t)(x.SrcArrayElement), cgoAllocsUnknown
	allocsfe237a3a.Borrow(csrcArrayElement_allocs)

	var cdstSet_allocs *cgoAllocMap
	reffe237a3a.dstSet, cdstSet_allocs = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.DstSet)), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdstSet_allocs)

	var cdstBinding_allocs *cgoAllocMap
	reffe237a3a.dstBinding, cdstBinding_allocs = (C.uint32_t)(x.DstBinding), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdstBinding_allocs)

	var cdstArrayElement_allocs *cgoAllocMap
	reffe237a3a.dstArrayElement, cdstArrayElement_allocs = (C.uint32_t)(x.DstArrayElement), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdstArrayElement_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	reffe237a3a.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocsfe237a3a.Borrow(cdescriptorCount_allocs)

	x.reffe237a3a = reffe237a3a
	x.allocsfe237a3a = allocsfe237a3a
	return reffe237a3a, allocsfe237a3a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CopyDescriptorSet) PassValue() (C.VkCopyDescriptorSet, *cgoAllocMap) {
	if x.reffe237a3a != nil {
		return *x.reffe237a3a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CopyDescriptorSet) Deref() {
	if x.reffe237a3a == nil {
		return
	}
	x.SType = (StructureType)(x.reffe237a3a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe237a3a.pNext))
	x.SrcSet = *(*DescriptorSet)(unsafe.Pointer(&x.reffe237a3a.srcSet))
	x.SrcBinding = (uint32)(x.reffe237a3a.srcBinding)
	x.SrcArrayElement = (uint32)(x.reffe237a3a.srcArrayElement)
	x.DstSet = *(*DescriptorSet)(unsafe.Pointer(&x.reffe237a3a.dstSet))
	x.DstBinding = (uint32)(x.reffe237a3a.dstBinding)
	x.DstArrayElement = (uint32)(x.reffe237a3a.dstArrayElement)
	x.DescriptorCount = (uint32)(x.reffe237a3a.descriptorCount)
}

// allocFramebufferCreateInfoMemory allocates memory for type C.VkFramebufferCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFramebufferCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFramebufferCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFramebufferCreateInfoValue = unsafe.Sizeof([1]C.VkFramebufferCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FramebufferCreateInfo) Ref() *C.VkFramebufferCreateInfo {
	if x == nil {
		return nil
	}
	return x.refa3ad85cc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FramebufferCreateInfo) Free() {
	if x != nil && x.allocsa3ad85cc != nil {
		x.allocsa3ad85cc.(*cgoAllocMap).Free()
		x.refa3ad85cc = nil
	}
}

// NewFramebufferCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFramebufferCreateInfoRef(ref unsafe.Pointer) *FramebufferCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(FramebufferCreateInfo)
	obj.refa3ad85cc = (*C.VkFramebufferCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FramebufferCreateInfo) PassRef() (*C.VkFramebufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa3ad85cc != nil {
		return x.refa3ad85cc, nil
	}
	mema3ad85cc := allocFramebufferCreateInfoMemory(1)
	refa3ad85cc := (*C.VkFramebufferCreateInfo)(mema3ad85cc)
	allocsa3ad85cc := new(cgoAllocMap)
	allocsa3ad85cc.Add(mema3ad85cc)

	var csType_allocs *cgoAllocMap
	refa3ad85cc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa3ad85cc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refa3ad85cc.flags, cflags_allocs = (C.VkFramebufferCreateFlags)(x.Flags), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cflags_allocs)

	var crenderPass_allocs *cgoAllocMap
	refa3ad85cc.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(crenderPass_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	refa3ad85cc.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	refa3ad85cc.pAttachments, cpAttachments_allocs = (*C.VkImageView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PAttachments)).Data)), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cpAttachments_allocs)

	var cwidth_allocs *cgoAllocMap
	refa3ad85cc.width, cwidth_allocs = (C.uint32_t)(x.Width), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refa3ad85cc.height, cheight_allocs = (C.uint32_t)(x.Height), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(cheight_allocs)

	var clayers_allocs *cgoAllocMap
	refa3ad85cc.layers, clayers_allocs = (C.uint32_t)(x.Layers), cgoAllocsUnknown
	allocsa3ad85cc.Borrow(clayers_allocs)

	x.refa3ad85cc = refa3ad85cc
	x.allocsa3ad85cc = allocsa3ad85cc
	return refa3ad85cc, allocsa3ad85cc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FramebufferCreateInfo) PassValue() (C.VkFramebufferCreateInfo, *cgoAllocMap) {
	if x.refa3ad85cc != nil {
		return *x.refa3ad85cc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FramebufferCreateInfo) Deref() {
	if x.refa3ad85cc == nil {
		return
	}
	x.SType = (StructureType)(x.refa3ad85cc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa3ad85cc.pNext))
	x.Flags = (FramebufferCreateFlags)(x.refa3ad85cc.flags)
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.refa3ad85cc.renderPass))
	x.AttachmentCount = (uint32)(x.refa3ad85cc.attachmentCount)
	hxf5fa529 := (*sliceHeader)(unsafe.Pointer(&x.PAttachments))
	hxf5fa529.Data = unsafe.Pointer(x.refa3ad85cc.pAttachments)
	hxf5fa529.Cap = 0x7fffffff
	// hxf5fa529.Len = ?

	x.Width = (uint32)(x.refa3ad85cc.width)
	x.Height = (uint32)(x.refa3ad85cc.height)
	x.Layers = (uint32)(x.refa3ad85cc.layers)
}

// allocAttachmentDescriptionMemory allocates memory for type C.VkAttachmentDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAttachmentDescriptionValue = unsafe.Sizeof([1]C.VkAttachmentDescription{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentDescription) Ref() *C.VkAttachmentDescription {
	if x == nil {
		return nil
	}
	return x.refa5d685fc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentDescription) Free() {
	if x != nil && x.allocsa5d685fc != nil {
		x.allocsa5d685fc.(*cgoAllocMap).Free()
		x.refa5d685fc = nil
	}
}

// NewAttachmentDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentDescriptionRef(ref unsafe.Pointer) *AttachmentDescription {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentDescription)
	obj.refa5d685fc = (*C.VkAttachmentDescription)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentDescription) PassRef() (*C.VkAttachmentDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa5d685fc != nil {
		return x.refa5d685fc, nil
	}
	mema5d685fc := allocAttachmentDescriptionMemory(1)
	refa5d685fc := (*C.VkAttachmentDescription)(mema5d685fc)
	allocsa5d685fc := new(cgoAllocMap)
	allocsa5d685fc.Add(mema5d685fc)

	var cflags_allocs *cgoAllocMap
	refa5d685fc.flags, cflags_allocs = (C.VkAttachmentDescriptionFlags)(x.Flags), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cflags_allocs)

	var cformat_allocs *cgoAllocMap
	refa5d685fc.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cformat_allocs)

	var csamples_allocs *cgoAllocMap
	refa5d685fc.samples, csamples_allocs = (C.VkSampleCountFlagBits)(x.Samples), cgoAllocsUnknown
	allocsa5d685fc.Borrow(csamples_allocs)

	var cloadOp_allocs *cgoAllocMap
	refa5d685fc.loadOp, cloadOp_allocs = (C.VkAttachmentLoadOp)(x.LoadOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cloadOp_allocs)

	var cstoreOp_allocs *cgoAllocMap
	refa5d685fc.storeOp, cstoreOp_allocs = (C.VkAttachmentStoreOp)(x.StoreOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cstoreOp_allocs)

	var cstencilLoadOp_allocs *cgoAllocMap
	refa5d685fc.stencilLoadOp, cstencilLoadOp_allocs = (C.VkAttachmentLoadOp)(x.StencilLoadOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cstencilLoadOp_allocs)

	var cstencilStoreOp_allocs *cgoAllocMap
	refa5d685fc.stencilStoreOp, cstencilStoreOp_allocs = (C.VkAttachmentStoreOp)(x.StencilStoreOp), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cstencilStoreOp_allocs)

	var cinitialLayout_allocs *cgoAllocMap
	refa5d685fc.initialLayout, cinitialLayout_allocs = (C.VkImageLayout)(x.InitialLayout), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cinitialLayout_allocs)

	var cfinalLayout_allocs *cgoAllocMap
	refa5d685fc.finalLayout, cfinalLayout_allocs = (C.VkImageLayout)(x.FinalLayout), cgoAllocsUnknown
	allocsa5d685fc.Borrow(cfinalLayout_allocs)

	x.refa5d685fc = refa5d685fc
	x.allocsa5d685fc = allocsa5d685fc
	return refa5d685fc, allocsa5d685fc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentDescription) PassValue() (C.VkAttachmentDescription, *cgoAllocMap) {
	if x.refa5d685fc != nil {
		return *x.refa5d685fc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentDescription) Deref() {
	if x.refa5d685fc == nil {
		return
	}
	x.Flags = (AttachmentDescriptionFlags)(x.refa5d685fc.flags)
	x.Format = (Format)(x.refa5d685fc.format)
	x.Samples = (SampleCountFlagBits)(x.refa5d685fc.samples)
	x.LoadOp = (AttachmentLoadOp)(x.refa5d685fc.loadOp)
	x.StoreOp = (AttachmentStoreOp)(x.refa5d685fc.storeOp)
	x.StencilLoadOp = (AttachmentLoadOp)(x.refa5d685fc.stencilLoadOp)
	x.StencilStoreOp = (AttachmentStoreOp)(x.refa5d685fc.stencilStoreOp)
	x.InitialLayout = (ImageLayout)(x.refa5d685fc.initialLayout)
	x.FinalLayout = (ImageLayout)(x.refa5d685fc.finalLayout)
}

// allocAttachmentReferenceMemory allocates memory for type C.VkAttachmentReference in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentReferenceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentReferenceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAttachmentReferenceValue = unsafe.Sizeof([1]C.VkAttachmentReference{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentReference) Ref() *C.VkAttachmentReference {
	if x == nil {
		return nil
	}
	return x.refef4776de
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentReference) Free() {
	if x != nil && x.allocsef4776de != nil {
		x.allocsef4776de.(*cgoAllocMap).Free()
		x.refef4776de = nil
	}
}

// NewAttachmentReferenceRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentReferenceRef(ref unsafe.Pointer) *AttachmentReference {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentReference)
	obj.refef4776de = (*C.VkAttachmentReference)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentReference) PassRef() (*C.VkAttachmentReference, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refef4776de != nil {
		return x.refef4776de, nil
	}
	memef4776de := allocAttachmentReferenceMemory(1)
	refef4776de := (*C.VkAttachmentReference)(memef4776de)
	allocsef4776de := new(cgoAllocMap)
	allocsef4776de.Add(memef4776de)

	var cattachment_allocs *cgoAllocMap
	refef4776de.attachment, cattachment_allocs = (C.uint32_t)(x.Attachment), cgoAllocsUnknown
	allocsef4776de.Borrow(cattachment_allocs)

	var clayout_allocs *cgoAllocMap
	refef4776de.layout, clayout_allocs = (C.VkImageLayout)(x.Layout), cgoAllocsUnknown
	allocsef4776de.Borrow(clayout_allocs)

	x.refef4776de = refef4776de
	x.allocsef4776de = allocsef4776de
	return refef4776de, allocsef4776de

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentReference) PassValue() (C.VkAttachmentReference, *cgoAllocMap) {
	if x.refef4776de != nil {
		return *x.refef4776de, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentReference) Deref() {
	if x.refef4776de == nil {
		return
	}
	x.Attachment = (uint32)(x.refef4776de.attachment)
	x.Layout = (ImageLayout)(x.refef4776de.layout)
}

// allocSubpassDescriptionMemory allocates memory for type C.VkSubpassDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassDescriptionValue = unsafe.Sizeof([1]C.VkSubpassDescription{})

// unpackSAttachmentReference transforms a sliced Go data structure into plain C format.
func unpackSAttachmentReference(x []AttachmentReference) (unpacked *C.VkAttachmentReference, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkAttachmentReference) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentReferenceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentReference)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentReference)(h.Data)
	return
}

// packSAttachmentReference reads sliced Go data structure out from plain C format.
func packSAttachmentReference(v []AttachmentReference, ptr0 *C.VkAttachmentReference) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentReferenceValue]C.VkAttachmentReference)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentReferenceRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassDescription) Ref() *C.VkSubpassDescription {
	if x == nil {
		return nil
	}
	return x.refc7bfeda
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassDescription) Free() {
	if x != nil && x.allocsc7bfeda != nil {
		x.allocsc7bfeda.(*cgoAllocMap).Free()
		x.refc7bfeda = nil
	}
}

// NewSubpassDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassDescriptionRef(ref unsafe.Pointer) *SubpassDescription {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDescription)
	obj.refc7bfeda = (*C.VkSubpassDescription)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassDescription) PassRef() (*C.VkSubpassDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc7bfeda != nil {
		return x.refc7bfeda, nil
	}
	memc7bfeda := allocSubpassDescriptionMemory(1)
	refc7bfeda := (*C.VkSubpassDescription)(memc7bfeda)
	allocsc7bfeda := new(cgoAllocMap)
	allocsc7bfeda.Add(memc7bfeda)

	var cflags_allocs *cgoAllocMap
	refc7bfeda.flags, cflags_allocs = (C.VkSubpassDescriptionFlags)(x.Flags), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cflags_allocs)

	var cpipelineBindPoint_allocs *cgoAllocMap
	refc7bfeda.pipelineBindPoint, cpipelineBindPoint_allocs = (C.VkPipelineBindPoint)(x.PipelineBindPoint), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cpipelineBindPoint_allocs)

	var cinputAttachmentCount_allocs *cgoAllocMap
	refc7bfeda.inputAttachmentCount, cinputAttachmentCount_allocs = (C.uint32_t)(x.InputAttachmentCount), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cinputAttachmentCount_allocs)

	var cpInputAttachments_allocs *cgoAllocMap
	refc7bfeda.pInputAttachments, cpInputAttachments_allocs = unpackSAttachmentReference(x.PInputAttachments)
	allocsc7bfeda.Borrow(cpInputAttachments_allocs)

	var ccolorAttachmentCount_allocs *cgoAllocMap
	refc7bfeda.colorAttachmentCount, ccolorAttachmentCount_allocs = (C.uint32_t)(x.ColorAttachmentCount), cgoAllocsUnknown
	allocsc7bfeda.Borrow(ccolorAttachmentCount_allocs)

	var cpColorAttachments_allocs *cgoAllocMap
	refc7bfeda.pColorAttachments, cpColorAttachments_allocs = unpackSAttachmentReference(x.PColorAttachments)
	allocsc7bfeda.Borrow(cpColorAttachments_allocs)

	var cpResolveAttachments_allocs *cgoAllocMap
	refc7bfeda.pResolveAttachments, cpResolveAttachments_allocs = unpackSAttachmentReference(x.PResolveAttachments)
	allocsc7bfeda.Borrow(cpResolveAttachments_allocs)

	var cpDepthStencilAttachment_allocs *cgoAllocMap
	refc7bfeda.pDepthStencilAttachment, cpDepthStencilAttachment_allocs = x.PDepthStencilAttachment.PassRef()
	allocsc7bfeda.Borrow(cpDepthStencilAttachment_allocs)

	var cpreserveAttachmentCount_allocs *cgoAllocMap
	refc7bfeda.preserveAttachmentCount, cpreserveAttachmentCount_allocs = (C.uint32_t)(x.PreserveAttachmentCount), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cpreserveAttachmentCount_allocs)

	var cpPreserveAttachments_allocs *cgoAllocMap
	refc7bfeda.pPreserveAttachments, cpPreserveAttachments_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments)).Data)), cgoAllocsUnknown
	allocsc7bfeda.Borrow(cpPreserveAttachments_allocs)

	x.refc7bfeda = refc7bfeda
	x.allocsc7bfeda = allocsc7bfeda
	return refc7bfeda, allocsc7bfeda

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassDescription) PassValue() (C.VkSubpassDescription, *cgoAllocMap) {
	if x.refc7bfeda != nil {
		return *x.refc7bfeda, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassDescription) Deref() {
	if x.refc7bfeda == nil {
		return
	}
	x.Flags = (SubpassDescriptionFlags)(x.refc7bfeda.flags)
	x.PipelineBindPoint = (PipelineBindPoint)(x.refc7bfeda.pipelineBindPoint)
	x.InputAttachmentCount = (uint32)(x.refc7bfeda.inputAttachmentCount)
	packSAttachmentReference(x.PInputAttachments, x.refc7bfeda.pInputAttachments)
	x.ColorAttachmentCount = (uint32)(x.refc7bfeda.colorAttachmentCount)
	packSAttachmentReference(x.PColorAttachments, x.refc7bfeda.pColorAttachments)
	packSAttachmentReference(x.PResolveAttachments, x.refc7bfeda.pResolveAttachments)
	x.PDepthStencilAttachment = NewAttachmentReferenceRef(unsafe.Pointer(x.refc7bfeda.pDepthStencilAttachment))
	x.PreserveAttachmentCount = (uint32)(x.refc7bfeda.preserveAttachmentCount)
	hxf21690b := (*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments))
	hxf21690b.Data = unsafe.Pointer(x.refc7bfeda.pPreserveAttachments)
	hxf21690b.Cap = 0x7fffffff
	// hxf21690b.Len = ?

}

// allocSubpassDependencyMemory allocates memory for type C.VkSubpassDependency in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDependencyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDependencyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassDependencyValue = unsafe.Sizeof([1]C.VkSubpassDependency{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassDependency) Ref() *C.VkSubpassDependency {
	if x == nil {
		return nil
	}
	return x.refdb197adb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassDependency) Free() {
	if x != nil && x.allocsdb197adb != nil {
		x.allocsdb197adb.(*cgoAllocMap).Free()
		x.refdb197adb = nil
	}
}

// NewSubpassDependencyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassDependencyRef(ref unsafe.Pointer) *SubpassDependency {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDependency)
	obj.refdb197adb = (*C.VkSubpassDependency)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassDependency) PassRef() (*C.VkSubpassDependency, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdb197adb != nil {
		return x.refdb197adb, nil
	}
	memdb197adb := allocSubpassDependencyMemory(1)
	refdb197adb := (*C.VkSubpassDependency)(memdb197adb)
	allocsdb197adb := new(cgoAllocMap)
	allocsdb197adb.Add(memdb197adb)

	var csrcSubpass_allocs *cgoAllocMap
	refdb197adb.srcSubpass, csrcSubpass_allocs = (C.uint32_t)(x.SrcSubpass), cgoAllocsUnknown
	allocsdb197adb.Borrow(csrcSubpass_allocs)

	var cdstSubpass_allocs *cgoAllocMap
	refdb197adb.dstSubpass, cdstSubpass_allocs = (C.uint32_t)(x.DstSubpass), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdstSubpass_allocs)

	var csrcStageMask_allocs *cgoAllocMap
	refdb197adb.srcStageMask, csrcStageMask_allocs = (C.VkPipelineStageFlags)(x.SrcStageMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(csrcStageMask_allocs)

	var cdstStageMask_allocs *cgoAllocMap
	refdb197adb.dstStageMask, cdstStageMask_allocs = (C.VkPipelineStageFlags)(x.DstStageMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdstStageMask_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	refdb197adb.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	refdb197adb.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdstAccessMask_allocs)

	var cdependencyFlags_allocs *cgoAllocMap
	refdb197adb.dependencyFlags, cdependencyFlags_allocs = (C.VkDependencyFlags)(x.DependencyFlags), cgoAllocsUnknown
	allocsdb197adb.Borrow(cdependencyFlags_allocs)

	x.refdb197adb = refdb197adb
	x.allocsdb197adb = allocsdb197adb
	return refdb197adb, allocsdb197adb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassDependency) PassValue() (C.VkSubpassDependency, *cgoAllocMap) {
	if x.refdb197adb != nil {
		return *x.refdb197adb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassDependency) Deref() {
	if x.refdb197adb == nil {
		return
	}
	x.SrcSubpass = (uint32)(x.refdb197adb.srcSubpass)
	x.DstSubpass = (uint32)(x.refdb197adb.dstSubpass)
	x.SrcStageMask = (PipelineStageFlags)(x.refdb197adb.srcStageMask)
	x.DstStageMask = (PipelineStageFlags)(x.refdb197adb.dstStageMask)
	x.SrcAccessMask = (AccessFlags)(x.refdb197adb.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refdb197adb.dstAccessMask)
	x.DependencyFlags = (DependencyFlags)(x.refdb197adb.dependencyFlags)
}

// allocRenderPassCreateInfoMemory allocates memory for type C.VkRenderPassCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderPassCreateInfoValue = unsafe.Sizeof([1]C.VkRenderPassCreateInfo{})

// unpackSAttachmentDescription transforms a sliced Go data structure into plain C format.
func unpackSAttachmentDescription(x []AttachmentDescription) (unpacked *C.VkAttachmentDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkAttachmentDescription) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentDescription)(h.Data)
	return
}

// unpackSSubpassDescription transforms a sliced Go data structure into plain C format.
func unpackSSubpassDescription(x []SubpassDescription) (unpacked *C.VkSubpassDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubpassDescription) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDescription)(h.Data)
	return
}

// unpackSSubpassDependency transforms a sliced Go data structure into plain C format.
func unpackSSubpassDependency(x []SubpassDependency) (unpacked *C.VkSubpassDependency, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubpassDependency) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDependencyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDependency)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDependency)(h.Data)
	return
}

// packSAttachmentDescription reads sliced Go data structure out from plain C format.
func packSAttachmentDescription(v []AttachmentDescription, ptr0 *C.VkAttachmentDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentDescriptionValue]C.VkAttachmentDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// packSSubpassDescription reads sliced Go data structure out from plain C format.
func packSSubpassDescription(v []SubpassDescription, ptr0 *C.VkSubpassDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDescriptionValue]C.VkSubpassDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// packSSubpassDependency reads sliced Go data structure out from plain C format.
func packSSubpassDependency(v []SubpassDependency, ptr0 *C.VkSubpassDependency) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDependencyValue]C.VkSubpassDependency)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDependencyRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassCreateInfo) Ref() *C.VkRenderPassCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref886d7d86
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassCreateInfo) Free() {
	if x != nil && x.allocs886d7d86 != nil {
		x.allocs886d7d86.(*cgoAllocMap).Free()
		x.ref886d7d86 = nil
	}
}

// NewRenderPassCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassCreateInfoRef(ref unsafe.Pointer) *RenderPassCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassCreateInfo)
	obj.ref886d7d86 = (*C.VkRenderPassCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassCreateInfo) PassRef() (*C.VkRenderPassCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref886d7d86 != nil {
		return x.ref886d7d86, nil
	}
	mem886d7d86 := allocRenderPassCreateInfoMemory(1)
	ref886d7d86 := (*C.VkRenderPassCreateInfo)(mem886d7d86)
	allocs886d7d86 := new(cgoAllocMap)
	allocs886d7d86.Add(mem886d7d86)

	var csType_allocs *cgoAllocMap
	ref886d7d86.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs886d7d86.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref886d7d86.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs886d7d86.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref886d7d86.flags, cflags_allocs = (C.VkRenderPassCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs886d7d86.Borrow(cflags_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	ref886d7d86.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocs886d7d86.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	ref886d7d86.pAttachments, cpAttachments_allocs = unpackSAttachmentDescription(x.PAttachments)
	allocs886d7d86.Borrow(cpAttachments_allocs)

	var csubpassCount_allocs *cgoAllocMap
	ref886d7d86.subpassCount, csubpassCount_allocs = (C.uint32_t)(x.SubpassCount), cgoAllocsUnknown
	allocs886d7d86.Borrow(csubpassCount_allocs)

	var cpSubpasses_allocs *cgoAllocMap
	ref886d7d86.pSubpasses, cpSubpasses_allocs = unpackSSubpassDescription(x.PSubpasses)
	allocs886d7d86.Borrow(cpSubpasses_allocs)

	var cdependencyCount_allocs *cgoAllocMap
	ref886d7d86.dependencyCount, cdependencyCount_allocs = (C.uint32_t)(x.DependencyCount), cgoAllocsUnknown
	allocs886d7d86.Borrow(cdependencyCount_allocs)

	var cpDependencies_allocs *cgoAllocMap
	ref886d7d86.pDependencies, cpDependencies_allocs = unpackSSubpassDependency(x.PDependencies)
	allocs886d7d86.Borrow(cpDependencies_allocs)

	x.ref886d7d86 = ref886d7d86
	x.allocs886d7d86 = allocs886d7d86
	return ref886d7d86, allocs886d7d86

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassCreateInfo) PassValue() (C.VkRenderPassCreateInfo, *cgoAllocMap) {
	if x.ref886d7d86 != nil {
		return *x.ref886d7d86, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassCreateInfo) Deref() {
	if x.ref886d7d86 == nil {
		return
	}
	x.SType = (StructureType)(x.ref886d7d86.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref886d7d86.pNext))
	x.Flags = (RenderPassCreateFlags)(x.ref886d7d86.flags)
	x.AttachmentCount = (uint32)(x.ref886d7d86.attachmentCount)
	packSAttachmentDescription(x.PAttachments, x.ref886d7d86.pAttachments)
	x.SubpassCount = (uint32)(x.ref886d7d86.subpassCount)
	packSSubpassDescription(x.PSubpasses, x.ref886d7d86.pSubpasses)
	x.DependencyCount = (uint32)(x.ref886d7d86.dependencyCount)
	packSSubpassDependency(x.PDependencies, x.ref886d7d86.pDependencies)
}

// allocCommandPoolCreateInfoMemory allocates memory for type C.VkCommandPoolCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandPoolCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandPoolCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandPoolCreateInfoValue = unsafe.Sizeof([1]C.VkCommandPoolCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandPoolCreateInfo) Ref() *C.VkCommandPoolCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref73550de0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandPoolCreateInfo) Free() {
	if x != nil && x.allocs73550de0 != nil {
		x.allocs73550de0.(*cgoAllocMap).Free()
		x.ref73550de0 = nil
	}
}

// NewCommandPoolCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandPoolCreateInfoRef(ref unsafe.Pointer) *CommandPoolCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandPoolCreateInfo)
	obj.ref73550de0 = (*C.VkCommandPoolCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandPoolCreateInfo) PassRef() (*C.VkCommandPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref73550de0 != nil {
		return x.ref73550de0, nil
	}
	mem73550de0 := allocCommandPoolCreateInfoMemory(1)
	ref73550de0 := (*C.VkCommandPoolCreateInfo)(mem73550de0)
	allocs73550de0 := new(cgoAllocMap)
	allocs73550de0.Add(mem73550de0)

	var csType_allocs *cgoAllocMap
	ref73550de0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs73550de0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref73550de0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs73550de0.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref73550de0.flags, cflags_allocs = (C.VkCommandPoolCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs73550de0.Borrow(cflags_allocs)

	var cqueueFamilyIndex_allocs *cgoAllocMap
	ref73550de0.queueFamilyIndex, cqueueFamilyIndex_allocs = (C.uint32_t)(x.QueueFamilyIndex), cgoAllocsUnknown
	allocs73550de0.Borrow(cqueueFamilyIndex_allocs)

	x.ref73550de0 = ref73550de0
	x.allocs73550de0 = allocs73550de0
	return ref73550de0, allocs73550de0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandPoolCreateInfo) PassValue() (C.VkCommandPoolCreateInfo, *cgoAllocMap) {
	if x.ref73550de0 != nil {
		return *x.ref73550de0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandPoolCreateInfo) Deref() {
	if x.ref73550de0 == nil {
		return
	}
	x.SType = (StructureType)(x.ref73550de0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref73550de0.pNext))
	x.Flags = (CommandPoolCreateFlags)(x.ref73550de0.flags)
	x.QueueFamilyIndex = (uint32)(x.ref73550de0.queueFamilyIndex)
}

// allocCommandBufferAllocateInfoMemory allocates memory for type C.VkCommandBufferAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferAllocateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandBufferAllocateInfoValue = unsafe.Sizeof([1]C.VkCommandBufferAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferAllocateInfo) Ref() *C.VkCommandBufferAllocateInfo {
	if x == nil {
		return nil
	}
	return x.refd1a0a7c8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferAllocateInfo) Free() {
	if x != nil && x.allocsd1a0a7c8 != nil {
		x.allocsd1a0a7c8.(*cgoAllocMap).Free()
		x.refd1a0a7c8 = nil
	}
}

// NewCommandBufferAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferAllocateInfoRef(ref unsafe.Pointer) *CommandBufferAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferAllocateInfo)
	obj.refd1a0a7c8 = (*C.VkCommandBufferAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferAllocateInfo) PassRef() (*C.VkCommandBufferAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd1a0a7c8 != nil {
		return x.refd1a0a7c8, nil
	}
	memd1a0a7c8 := allocCommandBufferAllocateInfoMemory(1)
	refd1a0a7c8 := (*C.VkCommandBufferAllocateInfo)(memd1a0a7c8)
	allocsd1a0a7c8 := new(cgoAllocMap)
	allocsd1a0a7c8.Add(memd1a0a7c8)

	var csType_allocs *cgoAllocMap
	refd1a0a7c8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd1a0a7c8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(cpNext_allocs)

	var ccommandPool_allocs *cgoAllocMap
	refd1a0a7c8.commandPool, ccommandPool_allocs = *(*C.VkCommandPool)(unsafe.Pointer(&x.CommandPool)), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(ccommandPool_allocs)

	var clevel_allocs *cgoAllocMap
	refd1a0a7c8.level, clevel_allocs = (C.VkCommandBufferLevel)(x.Level), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(clevel_allocs)

	var ccommandBufferCount_allocs *cgoAllocMap
	refd1a0a7c8.commandBufferCount, ccommandBufferCount_allocs = (C.uint32_t)(x.CommandBufferCount), cgoAllocsUnknown
	allocsd1a0a7c8.Borrow(ccommandBufferCount_allocs)

	x.refd1a0a7c8 = refd1a0a7c8
	x.allocsd1a0a7c8 = allocsd1a0a7c8
	return refd1a0a7c8, allocsd1a0a7c8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferAllocateInfo) PassValue() (C.VkCommandBufferAllocateInfo, *cgoAllocMap) {
	if x.refd1a0a7c8 != nil {
		return *x.refd1a0a7c8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferAllocateInfo) Deref() {
	if x.refd1a0a7c8 == nil {
		return
	}
	x.SType = (StructureType)(x.refd1a0a7c8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd1a0a7c8.pNext))
	x.CommandPool = *(*CommandPool)(unsafe.Pointer(&x.refd1a0a7c8.commandPool))
	x.Level = (CommandBufferLevel)(x.refd1a0a7c8.level)
	x.CommandBufferCount = (uint32)(x.refd1a0a7c8.commandBufferCount)
}

// allocCommandBufferInheritanceInfoMemory allocates memory for type C.VkCommandBufferInheritanceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferInheritanceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferInheritanceInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandBufferInheritanceInfoValue = unsafe.Sizeof([1]C.VkCommandBufferInheritanceInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferInheritanceInfo) Ref() *C.VkCommandBufferInheritanceInfo {
	if x == nil {
		return nil
	}
	return x.ref737f8019
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferInheritanceInfo) Free() {
	if x != nil && x.allocs737f8019 != nil {
		x.allocs737f8019.(*cgoAllocMap).Free()
		x.ref737f8019 = nil
	}
}

// NewCommandBufferInheritanceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferInheritanceInfoRef(ref unsafe.Pointer) *CommandBufferInheritanceInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferInheritanceInfo)
	obj.ref737f8019 = (*C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferInheritanceInfo) PassRef() (*C.VkCommandBufferInheritanceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref737f8019 != nil {
		return x.ref737f8019, nil
	}
	mem737f8019 := allocCommandBufferInheritanceInfoMemory(1)
	ref737f8019 := (*C.VkCommandBufferInheritanceInfo)(mem737f8019)
	allocs737f8019 := new(cgoAllocMap)
	allocs737f8019.Add(mem737f8019)

	var csType_allocs *cgoAllocMap
	ref737f8019.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs737f8019.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref737f8019.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs737f8019.Borrow(cpNext_allocs)

	var crenderPass_allocs *cgoAllocMap
	ref737f8019.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocs737f8019.Borrow(crenderPass_allocs)

	var csubpass_allocs *cgoAllocMap
	ref737f8019.subpass, csubpass_allocs = (C.uint32_t)(x.Subpass), cgoAllocsUnknown
	allocs737f8019.Borrow(csubpass_allocs)

	var cframebuffer_allocs *cgoAllocMap
	ref737f8019.framebuffer, cframebuffer_allocs = *(*C.VkFramebuffer)(unsafe.Pointer(&x.Framebuffer)), cgoAllocsUnknown
	allocs737f8019.Borrow(cframebuffer_allocs)

	var cocclusionQueryEnable_allocs *cgoAllocMap
	ref737f8019.occlusionQueryEnable, cocclusionQueryEnable_allocs = (C.VkBool32)(x.OcclusionQueryEnable), cgoAllocsUnknown
	allocs737f8019.Borrow(cocclusionQueryEnable_allocs)

	var cqueryFlags_allocs *cgoAllocMap
	ref737f8019.queryFlags, cqueryFlags_allocs = (C.VkQueryControlFlags)(x.QueryFlags), cgoAllocsUnknown
	allocs737f8019.Borrow(cqueryFlags_allocs)

	var cpipelineStatistics_allocs *cgoAllocMap
	ref737f8019.pipelineStatistics, cpipelineStatistics_allocs = (C.VkQueryPipelineStatisticFlags)(x.PipelineStatistics), cgoAllocsUnknown
	allocs737f8019.Borrow(cpipelineStatistics_allocs)

	x.ref737f8019 = ref737f8019
	x.allocs737f8019 = allocs737f8019
	return ref737f8019, allocs737f8019

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferInheritanceInfo) PassValue() (C.VkCommandBufferInheritanceInfo, *cgoAllocMap) {
	if x.ref737f8019 != nil {
		return *x.ref737f8019, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferInheritanceInfo) Deref() {
	if x.ref737f8019 == nil {
		return
	}
	x.SType = (StructureType)(x.ref737f8019.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref737f8019.pNext))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref737f8019.renderPass))
	x.Subpass = (uint32)(x.ref737f8019.subpass)
	x.Framebuffer = *(*Framebuffer)(unsafe.Pointer(&x.ref737f8019.framebuffer))
	x.OcclusionQueryEnable = (Bool32)(x.ref737f8019.occlusionQueryEnable)
	x.QueryFlags = (QueryControlFlags)(x.ref737f8019.queryFlags)
	x.PipelineStatistics = (QueryPipelineStatisticFlags)(x.ref737f8019.pipelineStatistics)
}

// allocCommandBufferBeginInfoMemory allocates memory for type C.VkCommandBufferBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferBeginInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandBufferBeginInfoValue = unsafe.Sizeof([1]C.VkCommandBufferBeginInfo{})

// unpackSCommandBufferInheritanceInfo transforms a sliced Go data structure into plain C format.
func unpackSCommandBufferInheritanceInfo(x []CommandBufferInheritanceInfo) (unpacked *C.VkCommandBufferInheritanceInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkCommandBufferInheritanceInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCommandBufferInheritanceInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCommandBufferInheritanceInfo)(h.Data)
	return
}

// packSCommandBufferInheritanceInfo reads sliced Go data structure out from plain C format.
func packSCommandBufferInheritanceInfo(v []CommandBufferInheritanceInfo, ptr0 *C.VkCommandBufferInheritanceInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCommandBufferInheritanceInfoValue]C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCommandBufferInheritanceInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferBeginInfo) Ref() *C.VkCommandBufferBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref266762df
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferBeginInfo) Free() {
	if x != nil && x.allocs266762df != nil {
		x.allocs266762df.(*cgoAllocMap).Free()
		x.ref266762df = nil
	}
}

// NewCommandBufferBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferBeginInfoRef(ref unsafe.Pointer) *CommandBufferBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferBeginInfo)
	obj.ref266762df = (*C.VkCommandBufferBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferBeginInfo) PassRef() (*C.VkCommandBufferBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref266762df != nil {
		return x.ref266762df, nil
	}
	mem266762df := allocCommandBufferBeginInfoMemory(1)
	ref266762df := (*C.VkCommandBufferBeginInfo)(mem266762df)
	allocs266762df := new(cgoAllocMap)
	allocs266762df.Add(mem266762df)

	var csType_allocs *cgoAllocMap
	ref266762df.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs266762df.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref266762df.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs266762df.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref266762df.flags, cflags_allocs = (C.VkCommandBufferUsageFlags)(x.Flags), cgoAllocsUnknown
	allocs266762df.Borrow(cflags_allocs)

	var cpInheritanceInfo_allocs *cgoAllocMap
	ref266762df.pInheritanceInfo, cpInheritanceInfo_allocs = unpackSCommandBufferInheritanceInfo(x.PInheritanceInfo)
	allocs266762df.Borrow(cpInheritanceInfo_allocs)

	x.ref266762df = ref266762df
	x.allocs266762df = allocs266762df
	return ref266762df, allocs266762df

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferBeginInfo) PassValue() (C.VkCommandBufferBeginInfo, *cgoAllocMap) {
	if x.ref266762df != nil {
		return *x.ref266762df, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferBeginInfo) Deref() {
	if x.ref266762df == nil {
		return
	}
	x.SType = (StructureType)(x.ref266762df.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref266762df.pNext))
	x.Flags = (CommandBufferUsageFlags)(x.ref266762df.flags)
	packSCommandBufferInheritanceInfo(x.PInheritanceInfo, x.ref266762df.pInheritanceInfo)
}

// allocBufferCopyMemory allocates memory for type C.VkBufferCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferCopyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferCopyValue = unsafe.Sizeof([1]C.VkBufferCopy{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferCopy) Ref() *C.VkBufferCopy {
	if x == nil {
		return nil
	}
	return x.ref12184ffd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferCopy) Free() {
	if x != nil && x.allocs12184ffd != nil {
		x.allocs12184ffd.(*cgoAllocMap).Free()
		x.ref12184ffd = nil
	}
}

// NewBufferCopyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferCopyRef(ref unsafe.Pointer) *BufferCopy {
	if ref == nil {
		return nil
	}
	obj := new(BufferCopy)
	obj.ref12184ffd = (*C.VkBufferCopy)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferCopy) PassRef() (*C.VkBufferCopy, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref12184ffd != nil {
		return x.ref12184ffd, nil
	}
	mem12184ffd := allocBufferCopyMemory(1)
	ref12184ffd := (*C.VkBufferCopy)(mem12184ffd)
	allocs12184ffd := new(cgoAllocMap)
	allocs12184ffd.Add(mem12184ffd)

	var csrcOffset_allocs *cgoAllocMap
	ref12184ffd.srcOffset, csrcOffset_allocs = (C.VkDeviceSize)(x.SrcOffset), cgoAllocsUnknown
	allocs12184ffd.Borrow(csrcOffset_allocs)

	var cdstOffset_allocs *cgoAllocMap
	ref12184ffd.dstOffset, cdstOffset_allocs = (C.VkDeviceSize)(x.DstOffset), cgoAllocsUnknown
	allocs12184ffd.Borrow(cdstOffset_allocs)

	var csize_allocs *cgoAllocMap
	ref12184ffd.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocs12184ffd.Borrow(csize_allocs)

	x.ref12184ffd = ref12184ffd
	x.allocs12184ffd = allocs12184ffd
	return ref12184ffd, allocs12184ffd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferCopy) PassValue() (C.VkBufferCopy, *cgoAllocMap) {
	if x.ref12184ffd != nil {
		return *x.ref12184ffd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferCopy) Deref() {
	if x.ref12184ffd == nil {
		return
	}
	x.SrcOffset = (DeviceSize)(x.ref12184ffd.srcOffset)
	x.DstOffset = (DeviceSize)(x.ref12184ffd.dstOffset)
	x.Size = (DeviceSize)(x.ref12184ffd.size)
}

// allocImageSubresourceLayersMemory allocates memory for type C.VkImageSubresourceLayers in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSubresourceLayersMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSubresourceLayersValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageSubresourceLayersValue = unsafe.Sizeof([1]C.VkImageSubresourceLayers{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSubresourceLayers) Ref() *C.VkImageSubresourceLayers {
	if x == nil {
		return nil
	}
	return x.ref3b13bcd2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSubresourceLayers) Free() {
	if x != nil && x.allocs3b13bcd2 != nil {
		x.allocs3b13bcd2.(*cgoAllocMap).Free()
		x.ref3b13bcd2 = nil
	}
}

// NewImageSubresourceLayersRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSubresourceLayersRef(ref unsafe.Pointer) *ImageSubresourceLayers {
	if ref == nil {
		return nil
	}
	obj := new(ImageSubresourceLayers)
	obj.ref3b13bcd2 = (*C.VkImageSubresourceLayers)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSubresourceLayers) PassRef() (*C.VkImageSubresourceLayers, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3b13bcd2 != nil {
		return x.ref3b13bcd2, nil
	}
	mem3b13bcd2 := allocImageSubresourceLayersMemory(1)
	ref3b13bcd2 := (*C.VkImageSubresourceLayers)(mem3b13bcd2)
	allocs3b13bcd2 := new(cgoAllocMap)
	allocs3b13bcd2.Add(mem3b13bcd2)

	var caspectMask_allocs *cgoAllocMap
	ref3b13bcd2.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(caspectMask_allocs)

	var cmipLevel_allocs *cgoAllocMap
	ref3b13bcd2.mipLevel, cmipLevel_allocs = (C.uint32_t)(x.MipLevel), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(cmipLevel_allocs)

	var cbaseArrayLayer_allocs *cgoAllocMap
	ref3b13bcd2.baseArrayLayer, cbaseArrayLayer_allocs = (C.uint32_t)(x.BaseArrayLayer), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(cbaseArrayLayer_allocs)

	var clayerCount_allocs *cgoAllocMap
	ref3b13bcd2.layerCount, clayerCount_allocs = (C.uint32_t)(x.LayerCount), cgoAllocsUnknown
	allocs3b13bcd2.Borrow(clayerCount_allocs)

	x.ref3b13bcd2 = ref3b13bcd2
	x.allocs3b13bcd2 = allocs3b13bcd2
	return ref3b13bcd2, allocs3b13bcd2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSubresourceLayers) PassValue() (C.VkImageSubresourceLayers, *cgoAllocMap) {
	if x.ref3b13bcd2 != nil {
		return *x.ref3b13bcd2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSubresourceLayers) Deref() {
	if x.ref3b13bcd2 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.ref3b13bcd2.aspectMask)
	x.MipLevel = (uint32)(x.ref3b13bcd2.mipLevel)
	x.BaseArrayLayer = (uint32)(x.ref3b13bcd2.baseArrayLayer)
	x.LayerCount = (uint32)(x.ref3b13bcd2.layerCount)
}

// allocImageCopyMemory allocates memory for type C.VkImageCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCopyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageCopyValue = unsafe.Sizeof([1]C.VkImageCopy{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageCopy) Ref() *C.VkImageCopy {
	if x == nil {
		return nil
	}
	return x.ref4e7a1214
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageCopy) Free() {
	if x != nil && x.allocs4e7a1214 != nil {
		x.allocs4e7a1214.(*cgoAllocMap).Free()
		x.ref4e7a1214 = nil
	}
}

// NewImageCopyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageCopyRef(ref unsafe.Pointer) *ImageCopy {
	if ref == nil {
		return nil
	}
	obj := new(ImageCopy)
	obj.ref4e7a1214 = (*C.VkImageCopy)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageCopy) PassRef() (*C.VkImageCopy, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4e7a1214 != nil {
		return x.ref4e7a1214, nil
	}
	mem4e7a1214 := allocImageCopyMemory(1)
	ref4e7a1214 := (*C.VkImageCopy)(mem4e7a1214)
	allocs4e7a1214 := new(cgoAllocMap)
	allocs4e7a1214.Add(mem4e7a1214)

	var csrcSubresource_allocs *cgoAllocMap
	ref4e7a1214.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs4e7a1214.Borrow(csrcSubresource_allocs)

	var csrcOffset_allocs *cgoAllocMap
	ref4e7a1214.srcOffset, csrcOffset_allocs = x.SrcOffset.PassValue()
	allocs4e7a1214.Borrow(csrcOffset_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref4e7a1214.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs4e7a1214.Borrow(cdstSubresource_allocs)

	var cdstOffset_allocs *cgoAllocMap
	ref4e7a1214.dstOffset, cdstOffset_allocs = x.DstOffset.PassValue()
	allocs4e7a1214.Borrow(cdstOffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref4e7a1214.extent, cextent_allocs = x.Extent.PassValue()
	allocs4e7a1214.Borrow(cextent_allocs)

	x.ref4e7a1214 = ref4e7a1214
	x.allocs4e7a1214 = allocs4e7a1214
	return ref4e7a1214, allocs4e7a1214

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageCopy) PassValue() (C.VkImageCopy, *cgoAllocMap) {
	if x.ref4e7a1214 != nil {
		return *x.ref4e7a1214, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageCopy) Deref() {
	if x.ref4e7a1214 == nil {
		return
	}
	x.SrcSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref4e7a1214.srcSubresource))
	x.SrcOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref4e7a1214.srcOffset))
	x.DstSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref4e7a1214.dstSubresource))
	x.DstOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref4e7a1214.dstOffset))
	x.Extent = *NewExtent3DRef(unsafe.Pointer(&x.ref4e7a1214.extent))
}

// allocImageBlitMemory allocates memory for type C.VkImageBlit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageBlitMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageBlitValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageBlitValue = unsafe.Sizeof([1]C.VkImageBlit{})

// allocA2Offset3DMemory allocates memory for type [2]C.VkOffset3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA2Offset3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA2Offset3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA2Offset3DValue = unsafe.Sizeof([1][2]C.VkOffset3D{})

// unpackA2Offset3D transforms a sliced Go data structure into plain C format.
func unpackA2Offset3D(x [2]Offset3D) (unpacked [2]C.VkOffset3D, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[2]C.VkOffset3D) {
		go allocs.Free()
	})

	mem0 := allocA2Offset3DMemory(1)
	allocs.Add(mem0)
	v0 := (*[2]C.VkOffset3D)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[2]C.VkOffset3D)(mem0)
	return
}

// packA2Offset3D reads sliced Go data structure out from plain C format.
func packA2Offset3D(v *[2]Offset3D, ptr0 *[2]C.VkOffset3D) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewOffset3DRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageBlit) Ref() *C.VkImageBlit {
	if x == nil {
		return nil
	}
	return x.ref11311e8d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageBlit) Free() {
	if x != nil && x.allocs11311e8d != nil {
		x.allocs11311e8d.(*cgoAllocMap).Free()
		x.ref11311e8d = nil
	}
}

// NewImageBlitRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageBlitRef(ref unsafe.Pointer) *ImageBlit {
	if ref == nil {
		return nil
	}
	obj := new(ImageBlit)
	obj.ref11311e8d = (*C.VkImageBlit)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageBlit) PassRef() (*C.VkImageBlit, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref11311e8d != nil {
		return x.ref11311e8d, nil
	}
	mem11311e8d := allocImageBlitMemory(1)
	ref11311e8d := (*C.VkImageBlit)(mem11311e8d)
	allocs11311e8d := new(cgoAllocMap)
	allocs11311e8d.Add(mem11311e8d)

	var csrcSubresource_allocs *cgoAllocMap
	ref11311e8d.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs11311e8d.Borrow(csrcSubresource_allocs)

	var csrcOffsets_allocs *cgoAllocMap
	ref11311e8d.srcOffsets, csrcOffsets_allocs = unpackA2Offset3D(x.SrcOffsets)
	allocs11311e8d.Borrow(csrcOffsets_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref11311e8d.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs11311e8d.Borrow(cdstSubresource_allocs)

	var cdstOffsets_allocs *cgoAllocMap
	ref11311e8d.dstOffsets, cdstOffsets_allocs = unpackA2Offset3D(x.DstOffsets)
	allocs11311e8d.Borrow(cdstOffsets_allocs)

	x.ref11311e8d = ref11311e8d
	x.allocs11311e8d = allocs11311e8d
	return ref11311e8d, allocs11311e8d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageBlit) PassValue() (C.VkImageBlit, *cgoAllocMap) {
	if x.ref11311e8d != nil {
		return *x.ref11311e8d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageBlit) Deref() {
	if x.ref11311e8d == nil {
		return
	}
	x.SrcSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref11311e8d.srcSubresource))
	packA2Offset3D(&x.SrcOffsets, (*[2]C.VkOffset3D)(unsafe.Pointer(&x.ref11311e8d.srcOffsets)))
	x.DstSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref11311e8d.dstSubresource))
	packA2Offset3D(&x.DstOffsets, (*[2]C.VkOffset3D)(unsafe.Pointer(&x.ref11311e8d.dstOffsets)))
}

// allocBufferImageCopyMemory allocates memory for type C.VkBufferImageCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferImageCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferImageCopyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferImageCopyValue = unsafe.Sizeof([1]C.VkBufferImageCopy{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferImageCopy) Ref() *C.VkBufferImageCopy {
	if x == nil {
		return nil
	}
	return x.ref6d50e36e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferImageCopy) Free() {
	if x != nil && x.allocs6d50e36e != nil {
		x.allocs6d50e36e.(*cgoAllocMap).Free()
		x.ref6d50e36e = nil
	}
}

// NewBufferImageCopyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferImageCopyRef(ref unsafe.Pointer) *BufferImageCopy {
	if ref == nil {
		return nil
	}
	obj := new(BufferImageCopy)
	obj.ref6d50e36e = (*C.VkBufferImageCopy)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferImageCopy) PassRef() (*C.VkBufferImageCopy, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6d50e36e != nil {
		return x.ref6d50e36e, nil
	}
	mem6d50e36e := allocBufferImageCopyMemory(1)
	ref6d50e36e := (*C.VkBufferImageCopy)(mem6d50e36e)
	allocs6d50e36e := new(cgoAllocMap)
	allocs6d50e36e.Add(mem6d50e36e)

	var cbufferOffset_allocs *cgoAllocMap
	ref6d50e36e.bufferOffset, cbufferOffset_allocs = (C.VkDeviceSize)(x.BufferOffset), cgoAllocsUnknown
	allocs6d50e36e.Borrow(cbufferOffset_allocs)

	var cbufferRowLength_allocs *cgoAllocMap
	ref6d50e36e.bufferRowLength, cbufferRowLength_allocs = (C.uint32_t)(x.BufferRowLength), cgoAllocsUnknown
	allocs6d50e36e.Borrow(cbufferRowLength_allocs)

	var cbufferImageHeight_allocs *cgoAllocMap
	ref6d50e36e.bufferImageHeight, cbufferImageHeight_allocs = (C.uint32_t)(x.BufferImageHeight), cgoAllocsUnknown
	allocs6d50e36e.Borrow(cbufferImageHeight_allocs)

	var cimageSubresource_allocs *cgoAllocMap
	ref6d50e36e.imageSubresource, cimageSubresource_allocs = x.ImageSubresource.PassValue()
	allocs6d50e36e.Borrow(cimageSubresource_allocs)

	var cimageOffset_allocs *cgoAllocMap
	ref6d50e36e.imageOffset, cimageOffset_allocs = x.ImageOffset.PassValue()
	allocs6d50e36e.Borrow(cimageOffset_allocs)

	var cimageExtent_allocs *cgoAllocMap
	ref6d50e36e.imageExtent, cimageExtent_allocs = x.ImageExtent.PassValue()
	allocs6d50e36e.Borrow(cimageExtent_allocs)

	x.ref6d50e36e = ref6d50e36e
	x.allocs6d50e36e = allocs6d50e36e
	return ref6d50e36e, allocs6d50e36e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferImageCopy) PassValue() (C.VkBufferImageCopy, *cgoAllocMap) {
	if x.ref6d50e36e != nil {
		return *x.ref6d50e36e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferImageCopy) Deref() {
	if x.ref6d50e36e == nil {
		return
	}
	x.BufferOffset = (DeviceSize)(x.ref6d50e36e.bufferOffset)
	x.BufferRowLength = (uint32)(x.ref6d50e36e.bufferRowLength)
	x.BufferImageHeight = (uint32)(x.ref6d50e36e.bufferImageHeight)
	x.ImageSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref6d50e36e.imageSubresource))
	x.ImageOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref6d50e36e.imageOffset))
	x.ImageExtent = *NewExtent3DRef(unsafe.Pointer(&x.ref6d50e36e.imageExtent))
}

// allocClearDepthStencilValueMemory allocates memory for type C.VkClearDepthStencilValue in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearDepthStencilValueMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearDepthStencilValueValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfClearDepthStencilValueValue = unsafe.Sizeof([1]C.VkClearDepthStencilValue{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ClearDepthStencilValue) Ref() *C.VkClearDepthStencilValue {
	if x == nil {
		return nil
	}
	return x.refa7d07c03
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ClearDepthStencilValue) Free() {
	if x != nil && x.allocsa7d07c03 != nil {
		x.allocsa7d07c03.(*cgoAllocMap).Free()
		x.refa7d07c03 = nil
	}
}

// NewClearDepthStencilValueRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewClearDepthStencilValueRef(ref unsafe.Pointer) *ClearDepthStencilValue {
	if ref == nil {
		return nil
	}
	obj := new(ClearDepthStencilValue)
	obj.refa7d07c03 = (*C.VkClearDepthStencilValue)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ClearDepthStencilValue) PassRef() (*C.VkClearDepthStencilValue, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa7d07c03 != nil {
		return x.refa7d07c03, nil
	}
	mema7d07c03 := allocClearDepthStencilValueMemory(1)
	refa7d07c03 := (*C.VkClearDepthStencilValue)(mema7d07c03)
	allocsa7d07c03 := new(cgoAllocMap)
	allocsa7d07c03.Add(mema7d07c03)

	var cdepth_allocs *cgoAllocMap
	refa7d07c03.depth, cdepth_allocs = (C.float)(x.Depth), cgoAllocsUnknown
	allocsa7d07c03.Borrow(cdepth_allocs)

	var cstencil_allocs *cgoAllocMap
	refa7d07c03.stencil, cstencil_allocs = (C.uint32_t)(x.Stencil), cgoAllocsUnknown
	allocsa7d07c03.Borrow(cstencil_allocs)

	x.refa7d07c03 = refa7d07c03
	x.allocsa7d07c03 = allocsa7d07c03
	return refa7d07c03, allocsa7d07c03

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ClearDepthStencilValue) PassValue() (C.VkClearDepthStencilValue, *cgoAllocMap) {
	if x.refa7d07c03 != nil {
		return *x.refa7d07c03, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ClearDepthStencilValue) Deref() {
	if x.refa7d07c03 == nil {
		return
	}
	x.Depth = (float32)(x.refa7d07c03.depth)
	x.Stencil = (uint32)(x.refa7d07c03.stencil)
}

// allocClearAttachmentMemory allocates memory for type C.VkClearAttachment in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearAttachmentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearAttachmentValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfClearAttachmentValue = unsafe.Sizeof([1]C.VkClearAttachment{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ClearAttachment) Ref() *C.VkClearAttachment {
	if x == nil {
		return nil
	}
	return x.refe9150303
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ClearAttachment) Free() {
	if x != nil && x.allocse9150303 != nil {
		x.allocse9150303.(*cgoAllocMap).Free()
		x.refe9150303 = nil
	}
}

// NewClearAttachmentRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewClearAttachmentRef(ref unsafe.Pointer) *ClearAttachment {
	if ref == nil {
		return nil
	}
	obj := new(ClearAttachment)
	obj.refe9150303 = (*C.VkClearAttachment)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ClearAttachment) PassRef() (*C.VkClearAttachment, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe9150303 != nil {
		return x.refe9150303, nil
	}
	meme9150303 := allocClearAttachmentMemory(1)
	refe9150303 := (*C.VkClearAttachment)(meme9150303)
	allocse9150303 := new(cgoAllocMap)
	allocse9150303.Add(meme9150303)

	var caspectMask_allocs *cgoAllocMap
	refe9150303.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocse9150303.Borrow(caspectMask_allocs)

	var ccolorAttachment_allocs *cgoAllocMap
	refe9150303.colorAttachment, ccolorAttachment_allocs = (C.uint32_t)(x.ColorAttachment), cgoAllocsUnknown
	allocse9150303.Borrow(ccolorAttachment_allocs)

	var cclearValue_allocs *cgoAllocMap
	refe9150303.clearValue, cclearValue_allocs = *(*C.VkClearValue)(unsafe.Pointer(&x.ClearValue)), cgoAllocsUnknown
	allocse9150303.Borrow(cclearValue_allocs)

	x.refe9150303 = refe9150303
	x.allocse9150303 = allocse9150303
	return refe9150303, allocse9150303

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ClearAttachment) PassValue() (C.VkClearAttachment, *cgoAllocMap) {
	if x.refe9150303 != nil {
		return *x.refe9150303, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ClearAttachment) Deref() {
	if x.refe9150303 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.refe9150303.aspectMask)
	x.ColorAttachment = (uint32)(x.refe9150303.colorAttachment)
	x.ClearValue = *(*ClearValue)(unsafe.Pointer(&x.refe9150303.clearValue))
}

// allocClearRectMemory allocates memory for type C.VkClearRect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearRectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfClearRectValue = unsafe.Sizeof([1]C.VkClearRect{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ClearRect) Ref() *C.VkClearRect {
	if x == nil {
		return nil
	}
	return x.ref1d449c8b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ClearRect) Free() {
	if x != nil && x.allocs1d449c8b != nil {
		x.allocs1d449c8b.(*cgoAllocMap).Free()
		x.ref1d449c8b = nil
	}
}

// NewClearRectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewClearRectRef(ref unsafe.Pointer) *ClearRect {
	if ref == nil {
		return nil
	}
	obj := new(ClearRect)
	obj.ref1d449c8b = (*C.VkClearRect)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ClearRect) PassRef() (*C.VkClearRect, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d449c8b != nil {
		return x.ref1d449c8b, nil
	}
	mem1d449c8b := allocClearRectMemory(1)
	ref1d449c8b := (*C.VkClearRect)(mem1d449c8b)
	allocs1d449c8b := new(cgoAllocMap)
	allocs1d449c8b.Add(mem1d449c8b)

	var crect_allocs *cgoAllocMap
	ref1d449c8b.rect, crect_allocs = x.Rect.PassValue()
	allocs1d449c8b.Borrow(crect_allocs)

	var cbaseArrayLayer_allocs *cgoAllocMap
	ref1d449c8b.baseArrayLayer, cbaseArrayLayer_allocs = (C.uint32_t)(x.BaseArrayLayer), cgoAllocsUnknown
	allocs1d449c8b.Borrow(cbaseArrayLayer_allocs)

	var clayerCount_allocs *cgoAllocMap
	ref1d449c8b.layerCount, clayerCount_allocs = (C.uint32_t)(x.LayerCount), cgoAllocsUnknown
	allocs1d449c8b.Borrow(clayerCount_allocs)

	x.ref1d449c8b = ref1d449c8b
	x.allocs1d449c8b = allocs1d449c8b
	return ref1d449c8b, allocs1d449c8b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ClearRect) PassValue() (C.VkClearRect, *cgoAllocMap) {
	if x.ref1d449c8b != nil {
		return *x.ref1d449c8b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ClearRect) Deref() {
	if x.ref1d449c8b == nil {
		return
	}
	x.Rect = *NewRect2DRef(unsafe.Pointer(&x.ref1d449c8b.rect))
	x.BaseArrayLayer = (uint32)(x.ref1d449c8b.baseArrayLayer)
	x.LayerCount = (uint32)(x.ref1d449c8b.layerCount)
}

// allocImageResolveMemory allocates memory for type C.VkImageResolve in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageResolveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageResolveValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageResolveValue = unsafe.Sizeof([1]C.VkImageResolve{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageResolve) Ref() *C.VkImageResolve {
	if x == nil {
		return nil
	}
	return x.ref7bda856d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageResolve) Free() {
	if x != nil && x.allocs7bda856d != nil {
		x.allocs7bda856d.(*cgoAllocMap).Free()
		x.ref7bda856d = nil
	}
}

// NewImageResolveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageResolveRef(ref unsafe.Pointer) *ImageResolve {
	if ref == nil {
		return nil
	}
	obj := new(ImageResolve)
	obj.ref7bda856d = (*C.VkImageResolve)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageResolve) PassRef() (*C.VkImageResolve, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7bda856d != nil {
		return x.ref7bda856d, nil
	}
	mem7bda856d := allocImageResolveMemory(1)
	ref7bda856d := (*C.VkImageResolve)(mem7bda856d)
	allocs7bda856d := new(cgoAllocMap)
	allocs7bda856d.Add(mem7bda856d)

	var csrcSubresource_allocs *cgoAllocMap
	ref7bda856d.srcSubresource, csrcSubresource_allocs = x.SrcSubresource.PassValue()
	allocs7bda856d.Borrow(csrcSubresource_allocs)

	var csrcOffset_allocs *cgoAllocMap
	ref7bda856d.srcOffset, csrcOffset_allocs = x.SrcOffset.PassValue()
	allocs7bda856d.Borrow(csrcOffset_allocs)

	var cdstSubresource_allocs *cgoAllocMap
	ref7bda856d.dstSubresource, cdstSubresource_allocs = x.DstSubresource.PassValue()
	allocs7bda856d.Borrow(cdstSubresource_allocs)

	var cdstOffset_allocs *cgoAllocMap
	ref7bda856d.dstOffset, cdstOffset_allocs = x.DstOffset.PassValue()
	allocs7bda856d.Borrow(cdstOffset_allocs)

	var cextent_allocs *cgoAllocMap
	ref7bda856d.extent, cextent_allocs = x.Extent.PassValue()
	allocs7bda856d.Borrow(cextent_allocs)

	x.ref7bda856d = ref7bda856d
	x.allocs7bda856d = allocs7bda856d
	return ref7bda856d, allocs7bda856d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageResolve) PassValue() (C.VkImageResolve, *cgoAllocMap) {
	if x.ref7bda856d != nil {
		return *x.ref7bda856d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageResolve) Deref() {
	if x.ref7bda856d == nil {
		return
	}
	x.SrcSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref7bda856d.srcSubresource))
	x.SrcOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref7bda856d.srcOffset))
	x.DstSubresource = *NewImageSubresourceLayersRef(unsafe.Pointer(&x.ref7bda856d.dstSubresource))
	x.DstOffset = *NewOffset3DRef(unsafe.Pointer(&x.ref7bda856d.dstOffset))
	x.Extent = *NewExtent3DRef(unsafe.Pointer(&x.ref7bda856d.extent))
}

// allocMemoryBarrierMemory allocates memory for type C.VkMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryBarrierValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryBarrierValue = unsafe.Sizeof([1]C.VkMemoryBarrier{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryBarrier) Ref() *C.VkMemoryBarrier {
	if x == nil {
		return nil
	}
	return x.ref977c944e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryBarrier) Free() {
	if x != nil && x.allocs977c944e != nil {
		x.allocs977c944e.(*cgoAllocMap).Free()
		x.ref977c944e = nil
	}
}

// NewMemoryBarrierRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryBarrierRef(ref unsafe.Pointer) *MemoryBarrier {
	if ref == nil {
		return nil
	}
	obj := new(MemoryBarrier)
	obj.ref977c944e = (*C.VkMemoryBarrier)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryBarrier) PassRef() (*C.VkMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref977c944e != nil {
		return x.ref977c944e, nil
	}
	mem977c944e := allocMemoryBarrierMemory(1)
	ref977c944e := (*C.VkMemoryBarrier)(mem977c944e)
	allocs977c944e := new(cgoAllocMap)
	allocs977c944e.Add(mem977c944e)

	var csType_allocs *cgoAllocMap
	ref977c944e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs977c944e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref977c944e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs977c944e.Borrow(cpNext_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	ref977c944e.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocs977c944e.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	ref977c944e.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocs977c944e.Borrow(cdstAccessMask_allocs)

	x.ref977c944e = ref977c944e
	x.allocs977c944e = allocs977c944e
	return ref977c944e, allocs977c944e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryBarrier) PassValue() (C.VkMemoryBarrier, *cgoAllocMap) {
	if x.ref977c944e != nil {
		return *x.ref977c944e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryBarrier) Deref() {
	if x.ref977c944e == nil {
		return
	}
	x.SType = (StructureType)(x.ref977c944e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref977c944e.pNext))
	x.SrcAccessMask = (AccessFlags)(x.ref977c944e.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.ref977c944e.dstAccessMask)
}

// allocBufferMemoryBarrierMemory allocates memory for type C.VkBufferMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferMemoryBarrierValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferMemoryBarrierValue = unsafe.Sizeof([1]C.VkBufferMemoryBarrier{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferMemoryBarrier) Ref() *C.VkBufferMemoryBarrier {
	if x == nil {
		return nil
	}
	return x.refeaf4700b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferMemoryBarrier) Free() {
	if x != nil && x.allocseaf4700b != nil {
		x.allocseaf4700b.(*cgoAllocMap).Free()
		x.refeaf4700b = nil
	}
}

// NewBufferMemoryBarrierRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferMemoryBarrierRef(ref unsafe.Pointer) *BufferMemoryBarrier {
	if ref == nil {
		return nil
	}
	obj := new(BufferMemoryBarrier)
	obj.refeaf4700b = (*C.VkBufferMemoryBarrier)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferMemoryBarrier) PassRef() (*C.VkBufferMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeaf4700b != nil {
		return x.refeaf4700b, nil
	}
	memeaf4700b := allocBufferMemoryBarrierMemory(1)
	refeaf4700b := (*C.VkBufferMemoryBarrier)(memeaf4700b)
	allocseaf4700b := new(cgoAllocMap)
	allocseaf4700b.Add(memeaf4700b)

	var csType_allocs *cgoAllocMap
	refeaf4700b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseaf4700b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeaf4700b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseaf4700b.Borrow(cpNext_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	refeaf4700b.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocseaf4700b.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	refeaf4700b.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocseaf4700b.Borrow(cdstAccessMask_allocs)

	var csrcQueueFamilyIndex_allocs *cgoAllocMap
	refeaf4700b.srcQueueFamilyIndex, csrcQueueFamilyIndex_allocs = (C.uint32_t)(x.SrcQueueFamilyIndex), cgoAllocsUnknown
	allocseaf4700b.Borrow(csrcQueueFamilyIndex_allocs)

	var cdstQueueFamilyIndex_allocs *cgoAllocMap
	refeaf4700b.dstQueueFamilyIndex, cdstQueueFamilyIndex_allocs = (C.uint32_t)(x.DstQueueFamilyIndex), cgoAllocsUnknown
	allocseaf4700b.Borrow(cdstQueueFamilyIndex_allocs)

	var cbuffer_allocs *cgoAllocMap
	refeaf4700b.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocseaf4700b.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	refeaf4700b.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocseaf4700b.Borrow(coffset_allocs)

	var csize_allocs *cgoAllocMap
	refeaf4700b.size, csize_allocs = (C.VkDeviceSize)(x.Size), cgoAllocsUnknown
	allocseaf4700b.Borrow(csize_allocs)

	x.refeaf4700b = refeaf4700b
	x.allocseaf4700b = allocseaf4700b
	return refeaf4700b, allocseaf4700b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferMemoryBarrier) PassValue() (C.VkBufferMemoryBarrier, *cgoAllocMap) {
	if x.refeaf4700b != nil {
		return *x.refeaf4700b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferMemoryBarrier) Deref() {
	if x.refeaf4700b == nil {
		return
	}
	x.SType = (StructureType)(x.refeaf4700b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeaf4700b.pNext))
	x.SrcAccessMask = (AccessFlags)(x.refeaf4700b.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refeaf4700b.dstAccessMask)
	x.SrcQueueFamilyIndex = (uint32)(x.refeaf4700b.srcQueueFamilyIndex)
	x.DstQueueFamilyIndex = (uint32)(x.refeaf4700b.dstQueueFamilyIndex)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refeaf4700b.buffer))
	x.Offset = (DeviceSize)(x.refeaf4700b.offset)
	x.Size = (DeviceSize)(x.refeaf4700b.size)
}

// allocImageMemoryBarrierMemory allocates memory for type C.VkImageMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageMemoryBarrierValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageMemoryBarrierValue = unsafe.Sizeof([1]C.VkImageMemoryBarrier{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageMemoryBarrier) Ref() *C.VkImageMemoryBarrier {
	if x == nil {
		return nil
	}
	return x.refd52734ec
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageMemoryBarrier) Free() {
	if x != nil && x.allocsd52734ec != nil {
		x.allocsd52734ec.(*cgoAllocMap).Free()
		x.refd52734ec = nil
	}
}

// NewImageMemoryBarrierRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageMemoryBarrierRef(ref unsafe.Pointer) *ImageMemoryBarrier {
	if ref == nil {
		return nil
	}
	obj := new(ImageMemoryBarrier)
	obj.refd52734ec = (*C.VkImageMemoryBarrier)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageMemoryBarrier) PassRef() (*C.VkImageMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd52734ec != nil {
		return x.refd52734ec, nil
	}
	memd52734ec := allocImageMemoryBarrierMemory(1)
	refd52734ec := (*C.VkImageMemoryBarrier)(memd52734ec)
	allocsd52734ec := new(cgoAllocMap)
	allocsd52734ec.Add(memd52734ec)

	var csType_allocs *cgoAllocMap
	refd52734ec.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd52734ec.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd52734ec.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd52734ec.Borrow(cpNext_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	refd52734ec.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocsd52734ec.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	refd52734ec.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocsd52734ec.Borrow(cdstAccessMask_allocs)

	var coldLayout_allocs *cgoAllocMap
	refd52734ec.oldLayout, coldLayout_allocs = (C.VkImageLayout)(x.OldLayout), cgoAllocsUnknown
	allocsd52734ec.Borrow(coldLayout_allocs)

	var cnewLayout_allocs *cgoAllocMap
	refd52734ec.newLayout, cnewLayout_allocs = (C.VkImageLayout)(x.NewLayout), cgoAllocsUnknown
	allocsd52734ec.Borrow(cnewLayout_allocs)

	var csrcQueueFamilyIndex_allocs *cgoAllocMap
	refd52734ec.srcQueueFamilyIndex, csrcQueueFamilyIndex_allocs = (C.uint32_t)(x.SrcQueueFamilyIndex), cgoAllocsUnknown
	allocsd52734ec.Borrow(csrcQueueFamilyIndex_allocs)

	var cdstQueueFamilyIndex_allocs *cgoAllocMap
	refd52734ec.dstQueueFamilyIndex, cdstQueueFamilyIndex_allocs = (C.uint32_t)(x.DstQueueFamilyIndex), cgoAllocsUnknown
	allocsd52734ec.Borrow(cdstQueueFamilyIndex_allocs)

	var cimage_allocs *cgoAllocMap
	refd52734ec.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocsd52734ec.Borrow(cimage_allocs)

	var csubresourceRange_allocs *cgoAllocMap
	refd52734ec.subresourceRange, csubresourceRange_allocs = x.SubresourceRange.PassValue()
	allocsd52734ec.Borrow(csubresourceRange_allocs)

	x.refd52734ec = refd52734ec
	x.allocsd52734ec = allocsd52734ec
	return refd52734ec, allocsd52734ec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageMemoryBarrier) PassValue() (C.VkImageMemoryBarrier, *cgoAllocMap) {
	if x.refd52734ec != nil {
		return *x.refd52734ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageMemoryBarrier) Deref() {
	if x.refd52734ec == nil {
		return
	}
	x.SType = (StructureType)(x.refd52734ec.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd52734ec.pNext))
	x.SrcAccessMask = (AccessFlags)(x.refd52734ec.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refd52734ec.dstAccessMask)
	x.OldLayout = (ImageLayout)(x.refd52734ec.oldLayout)
	x.NewLayout = (ImageLayout)(x.refd52734ec.newLayout)
	x.SrcQueueFamilyIndex = (uint32)(x.refd52734ec.srcQueueFamilyIndex)
	x.DstQueueFamilyIndex = (uint32)(x.refd52734ec.dstQueueFamilyIndex)
	x.Image = *(*Image)(unsafe.Pointer(&x.refd52734ec.image))
	x.SubresourceRange = *NewImageSubresourceRangeRef(unsafe.Pointer(&x.refd52734ec.subresourceRange))
}

// allocRenderPassBeginInfoMemory allocates memory for type C.VkRenderPassBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassBeginInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderPassBeginInfoValue = unsafe.Sizeof([1]C.VkRenderPassBeginInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassBeginInfo) Ref() *C.VkRenderPassBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref3c3752c8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassBeginInfo) Free() {
	if x != nil && x.allocs3c3752c8 != nil {
		x.allocs3c3752c8.(*cgoAllocMap).Free()
		x.ref3c3752c8 = nil
	}
}

// NewRenderPassBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassBeginInfoRef(ref unsafe.Pointer) *RenderPassBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassBeginInfo)
	obj.ref3c3752c8 = (*C.VkRenderPassBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassBeginInfo) PassRef() (*C.VkRenderPassBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c3752c8 != nil {
		return x.ref3c3752c8, nil
	}
	mem3c3752c8 := allocRenderPassBeginInfoMemory(1)
	ref3c3752c8 := (*C.VkRenderPassBeginInfo)(mem3c3752c8)
	allocs3c3752c8 := new(cgoAllocMap)
	allocs3c3752c8.Add(mem3c3752c8)

	var csType_allocs *cgoAllocMap
	ref3c3752c8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3c3752c8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3c3752c8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cpNext_allocs)

	var crenderPass_allocs *cgoAllocMap
	ref3c3752c8.renderPass, crenderPass_allocs = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(crenderPass_allocs)

	var cframebuffer_allocs *cgoAllocMap
	ref3c3752c8.framebuffer, cframebuffer_allocs = *(*C.VkFramebuffer)(unsafe.Pointer(&x.Framebuffer)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cframebuffer_allocs)

	var crenderArea_allocs *cgoAllocMap
	ref3c3752c8.renderArea, crenderArea_allocs = x.RenderArea.PassValue()
	allocs3c3752c8.Borrow(crenderArea_allocs)

	var cclearValueCount_allocs *cgoAllocMap
	ref3c3752c8.clearValueCount, cclearValueCount_allocs = (C.uint32_t)(x.ClearValueCount), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cclearValueCount_allocs)

	var cpClearValues_allocs *cgoAllocMap
	ref3c3752c8.pClearValues, cpClearValues_allocs = (*C.VkClearValue)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PClearValues)).Data)), cgoAllocsUnknown
	allocs3c3752c8.Borrow(cpClearValues_allocs)

	x.ref3c3752c8 = ref3c3752c8
	x.allocs3c3752c8 = allocs3c3752c8
	return ref3c3752c8, allocs3c3752c8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassBeginInfo) PassValue() (C.VkRenderPassBeginInfo, *cgoAllocMap) {
	if x.ref3c3752c8 != nil {
		return *x.ref3c3752c8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassBeginInfo) Deref() {
	if x.ref3c3752c8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3c3752c8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3c3752c8.pNext))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref3c3752c8.renderPass))
	x.Framebuffer = *(*Framebuffer)(unsafe.Pointer(&x.ref3c3752c8.framebuffer))
	x.RenderArea = *NewRect2DRef(unsafe.Pointer(&x.ref3c3752c8.renderArea))
	x.ClearValueCount = (uint32)(x.ref3c3752c8.clearValueCount)
	hxf1231c9 := (*sliceHeader)(unsafe.Pointer(&x.PClearValues))
	hxf1231c9.Data = unsafe.Pointer(x.ref3c3752c8.pClearValues)
	hxf1231c9.Cap = 0x7fffffff
	// hxf1231c9.Len = ?

}

// allocDispatchIndirectCommandMemory allocates memory for type C.VkDispatchIndirectCommand in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDispatchIndirectCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDispatchIndirectCommandValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDispatchIndirectCommandValue = unsafe.Sizeof([1]C.VkDispatchIndirectCommand{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DispatchIndirectCommand) Ref() *C.VkDispatchIndirectCommand {
	if x == nil {
		return nil
	}
	return x.refd298ba27
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DispatchIndirectCommand) Free() {
	if x != nil && x.allocsd298ba27 != nil {
		x.allocsd298ba27.(*cgoAllocMap).Free()
		x.refd298ba27 = nil
	}
}

// NewDispatchIndirectCommandRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDispatchIndirectCommandRef(ref unsafe.Pointer) *DispatchIndirectCommand {
	if ref == nil {
		return nil
	}
	obj := new(DispatchIndirectCommand)
	obj.refd298ba27 = (*C.VkDispatchIndirectCommand)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DispatchIndirectCommand) PassRef() (*C.VkDispatchIndirectCommand, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd298ba27 != nil {
		return x.refd298ba27, nil
	}
	memd298ba27 := allocDispatchIndirectCommandMemory(1)
	refd298ba27 := (*C.VkDispatchIndirectCommand)(memd298ba27)
	allocsd298ba27 := new(cgoAllocMap)
	allocsd298ba27.Add(memd298ba27)

	var cx_allocs *cgoAllocMap
	refd298ba27.x, cx_allocs = (C.uint32_t)(x.X), cgoAllocsUnknown
	allocsd298ba27.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refd298ba27.y, cy_allocs = (C.uint32_t)(x.Y), cgoAllocsUnknown
	allocsd298ba27.Borrow(cy_allocs)

	var cz_allocs *cgoAllocMap
	refd298ba27.z, cz_allocs = (C.uint32_t)(x.Z), cgoAllocsUnknown
	allocsd298ba27.Borrow(cz_allocs)

	x.refd298ba27 = refd298ba27
	x.allocsd298ba27 = allocsd298ba27
	return refd298ba27, allocsd298ba27

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DispatchIndirectCommand) PassValue() (C.VkDispatchIndirectCommand, *cgoAllocMap) {
	if x.refd298ba27 != nil {
		return *x.refd298ba27, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DispatchIndirectCommand) Deref() {
	if x.refd298ba27 == nil {
		return
	}
	x.X = (uint32)(x.refd298ba27.x)
	x.Y = (uint32)(x.refd298ba27.y)
	x.Z = (uint32)(x.refd298ba27.z)
}

// allocDrawIndexedIndirectCommandMemory allocates memory for type C.VkDrawIndexedIndirectCommand in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrawIndexedIndirectCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrawIndexedIndirectCommandValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDrawIndexedIndirectCommandValue = unsafe.Sizeof([1]C.VkDrawIndexedIndirectCommand{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DrawIndexedIndirectCommand) Ref() *C.VkDrawIndexedIndirectCommand {
	if x == nil {
		return nil
	}
	return x.ref4c78b5c3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DrawIndexedIndirectCommand) Free() {
	if x != nil && x.allocs4c78b5c3 != nil {
		x.allocs4c78b5c3.(*cgoAllocMap).Free()
		x.ref4c78b5c3 = nil
	}
}

// NewDrawIndexedIndirectCommandRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDrawIndexedIndirectCommandRef(ref unsafe.Pointer) *DrawIndexedIndirectCommand {
	if ref == nil {
		return nil
	}
	obj := new(DrawIndexedIndirectCommand)
	obj.ref4c78b5c3 = (*C.VkDrawIndexedIndirectCommand)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DrawIndexedIndirectCommand) PassRef() (*C.VkDrawIndexedIndirectCommand, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4c78b5c3 != nil {
		return x.ref4c78b5c3, nil
	}
	mem4c78b5c3 := allocDrawIndexedIndirectCommandMemory(1)
	ref4c78b5c3 := (*C.VkDrawIndexedIndirectCommand)(mem4c78b5c3)
	allocs4c78b5c3 := new(cgoAllocMap)
	allocs4c78b5c3.Add(mem4c78b5c3)

	var cindexCount_allocs *cgoAllocMap
	ref4c78b5c3.indexCount, cindexCount_allocs = (C.uint32_t)(x.IndexCount), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cindexCount_allocs)

	var cinstanceCount_allocs *cgoAllocMap
	ref4c78b5c3.instanceCount, cinstanceCount_allocs = (C.uint32_t)(x.InstanceCount), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cinstanceCount_allocs)

	var cfirstIndex_allocs *cgoAllocMap
	ref4c78b5c3.firstIndex, cfirstIndex_allocs = (C.uint32_t)(x.FirstIndex), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cfirstIndex_allocs)

	var cvertexOffset_allocs *cgoAllocMap
	ref4c78b5c3.vertexOffset, cvertexOffset_allocs = (C.int32_t)(x.VertexOffset), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cvertexOffset_allocs)

	var cfirstInstance_allocs *cgoAllocMap
	ref4c78b5c3.firstInstance, cfirstInstance_allocs = (C.uint32_t)(x.FirstInstance), cgoAllocsUnknown
	allocs4c78b5c3.Borrow(cfirstInstance_allocs)

	x.ref4c78b5c3 = ref4c78b5c3
	x.allocs4c78b5c3 = allocs4c78b5c3
	return ref4c78b5c3, allocs4c78b5c3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DrawIndexedIndirectCommand) PassValue() (C.VkDrawIndexedIndirectCommand, *cgoAllocMap) {
	if x.ref4c78b5c3 != nil {
		return *x.ref4c78b5c3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DrawIndexedIndirectCommand) Deref() {
	if x.ref4c78b5c3 == nil {
		return
	}
	x.IndexCount = (uint32)(x.ref4c78b5c3.indexCount)
	x.InstanceCount = (uint32)(x.ref4c78b5c3.instanceCount)
	x.FirstIndex = (uint32)(x.ref4c78b5c3.firstIndex)
	x.VertexOffset = (int32)(x.ref4c78b5c3.vertexOffset)
	x.FirstInstance = (uint32)(x.ref4c78b5c3.firstInstance)
}

// allocDrawIndirectCommandMemory allocates memory for type C.VkDrawIndirectCommand in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrawIndirectCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrawIndirectCommandValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDrawIndirectCommandValue = unsafe.Sizeof([1]C.VkDrawIndirectCommand{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DrawIndirectCommand) Ref() *C.VkDrawIndirectCommand {
	if x == nil {
		return nil
	}
	return x.ref2b5b67c4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DrawIndirectCommand) Free() {
	if x != nil && x.allocs2b5b67c4 != nil {
		x.allocs2b5b67c4.(*cgoAllocMap).Free()
		x.ref2b5b67c4 = nil
	}
}

// NewDrawIndirectCommandRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDrawIndirectCommandRef(ref unsafe.Pointer) *DrawIndirectCommand {
	if ref == nil {
		return nil
	}
	obj := new(DrawIndirectCommand)
	obj.ref2b5b67c4 = (*C.VkDrawIndirectCommand)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DrawIndirectCommand) PassRef() (*C.VkDrawIndirectCommand, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2b5b67c4 != nil {
		return x.ref2b5b67c4, nil
	}
	mem2b5b67c4 := allocDrawIndirectCommandMemory(1)
	ref2b5b67c4 := (*C.VkDrawIndirectCommand)(mem2b5b67c4)
	allocs2b5b67c4 := new(cgoAllocMap)
	allocs2b5b67c4.Add(mem2b5b67c4)

	var cvertexCount_allocs *cgoAllocMap
	ref2b5b67c4.vertexCount, cvertexCount_allocs = (C.uint32_t)(x.VertexCount), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cvertexCount_allocs)

	var cinstanceCount_allocs *cgoAllocMap
	ref2b5b67c4.instanceCount, cinstanceCount_allocs = (C.uint32_t)(x.InstanceCount), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cinstanceCount_allocs)

	var cfirstVertex_allocs *cgoAllocMap
	ref2b5b67c4.firstVertex, cfirstVertex_allocs = (C.uint32_t)(x.FirstVertex), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cfirstVertex_allocs)

	var cfirstInstance_allocs *cgoAllocMap
	ref2b5b67c4.firstInstance, cfirstInstance_allocs = (C.uint32_t)(x.FirstInstance), cgoAllocsUnknown
	allocs2b5b67c4.Borrow(cfirstInstance_allocs)

	x.ref2b5b67c4 = ref2b5b67c4
	x.allocs2b5b67c4 = allocs2b5b67c4
	return ref2b5b67c4, allocs2b5b67c4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DrawIndirectCommand) PassValue() (C.VkDrawIndirectCommand, *cgoAllocMap) {
	if x.ref2b5b67c4 != nil {
		return *x.ref2b5b67c4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DrawIndirectCommand) Deref() {
	if x.ref2b5b67c4 == nil {
		return
	}
	x.VertexCount = (uint32)(x.ref2b5b67c4.vertexCount)
	x.InstanceCount = (uint32)(x.ref2b5b67c4.instanceCount)
	x.FirstVertex = (uint32)(x.ref2b5b67c4.firstVertex)
	x.FirstInstance = (uint32)(x.ref2b5b67c4.firstInstance)
}

// allocBaseOutStructureMemory allocates memory for type C.VkBaseOutStructure in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBaseOutStructureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBaseOutStructureValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBaseOutStructureValue = unsafe.Sizeof([1]C.VkBaseOutStructure{})

// allocStruct_VkBaseOutStructureMemory allocates memory for type C.struct_VkBaseOutStructure in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct_VkBaseOutStructureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct_VkBaseOutStructureValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStruct_VkBaseOutStructureValue = unsafe.Sizeof([1]C.struct_VkBaseOutStructure{})

// unpackSBaseOutStructure transforms a sliced Go data structure into plain C format.
func unpackSBaseOutStructure(x []BaseOutStructure) (unpacked *C.struct_VkBaseOutStructure, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_VkBaseOutStructure) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStruct_VkBaseOutStructureMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_VkBaseOutStructure)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_VkBaseOutStructure)(h.Data)
	return
}

// packSBaseOutStructure reads sliced Go data structure out from plain C format.
func packSBaseOutStructure(v []BaseOutStructure, ptr0 *C.struct_VkBaseOutStructure) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStruct_VkBaseOutStructureValue]C.struct_VkBaseOutStructure)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBaseOutStructureRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BaseOutStructure) Ref() *C.VkBaseOutStructure {
	if x == nil {
		return nil
	}
	return x.refd536fcd0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BaseOutStructure) Free() {
	if x != nil && x.allocsd536fcd0 != nil {
		x.allocsd536fcd0.(*cgoAllocMap).Free()
		x.refd536fcd0 = nil
	}
}

// NewBaseOutStructureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBaseOutStructureRef(ref unsafe.Pointer) *BaseOutStructure {
	if ref == nil {
		return nil
	}
	obj := new(BaseOutStructure)
	obj.refd536fcd0 = (*C.VkBaseOutStructure)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BaseOutStructure) PassRef() (*C.VkBaseOutStructure, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd536fcd0 != nil {
		return x.refd536fcd0, nil
	}
	memd536fcd0 := allocBaseOutStructureMemory(1)
	refd536fcd0 := (*C.VkBaseOutStructure)(memd536fcd0)
	allocsd536fcd0 := new(cgoAllocMap)
	allocsd536fcd0.Add(memd536fcd0)

	var csType_allocs *cgoAllocMap
	refd536fcd0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd536fcd0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd536fcd0.pNext, cpNext_allocs = unpackSBaseOutStructure(x.PNext)
	allocsd536fcd0.Borrow(cpNext_allocs)

	x.refd536fcd0 = refd536fcd0
	x.allocsd536fcd0 = allocsd536fcd0
	return refd536fcd0, allocsd536fcd0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BaseOutStructure) PassValue() (C.VkBaseOutStructure, *cgoAllocMap) {
	if x.refd536fcd0 != nil {
		return *x.refd536fcd0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BaseOutStructure) Deref() {
	if x.refd536fcd0 == nil {
		return
	}
	x.SType = (StructureType)(x.refd536fcd0.sType)
	packSBaseOutStructure(x.PNext, x.refd536fcd0.pNext)
}

// allocBaseInStructureMemory allocates memory for type C.VkBaseInStructure in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBaseInStructureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBaseInStructureValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBaseInStructureValue = unsafe.Sizeof([1]C.VkBaseInStructure{})

// allocStruct_VkBaseInStructureMemory allocates memory for type C.struct_VkBaseInStructure in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct_VkBaseInStructureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct_VkBaseInStructureValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStruct_VkBaseInStructureValue = unsafe.Sizeof([1]C.struct_VkBaseInStructure{})

// unpackSBaseInStructure transforms a sliced Go data structure into plain C format.
func unpackSBaseInStructure(x []BaseInStructure) (unpacked *C.struct_VkBaseInStructure, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_VkBaseInStructure) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStruct_VkBaseInStructureMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_VkBaseInStructure)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_VkBaseInStructure)(h.Data)
	return
}

// packSBaseInStructure reads sliced Go data structure out from plain C format.
func packSBaseInStructure(v []BaseInStructure, ptr0 *C.struct_VkBaseInStructure) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStruct_VkBaseInStructureValue]C.struct_VkBaseInStructure)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBaseInStructureRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BaseInStructure) Ref() *C.VkBaseInStructure {
	if x == nil {
		return nil
	}
	return x.refeae401a9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BaseInStructure) Free() {
	if x != nil && x.allocseae401a9 != nil {
		x.allocseae401a9.(*cgoAllocMap).Free()
		x.refeae401a9 = nil
	}
}

// NewBaseInStructureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBaseInStructureRef(ref unsafe.Pointer) *BaseInStructure {
	if ref == nil {
		return nil
	}
	obj := new(BaseInStructure)
	obj.refeae401a9 = (*C.VkBaseInStructure)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BaseInStructure) PassRef() (*C.VkBaseInStructure, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeae401a9 != nil {
		return x.refeae401a9, nil
	}
	memeae401a9 := allocBaseInStructureMemory(1)
	refeae401a9 := (*C.VkBaseInStructure)(memeae401a9)
	allocseae401a9 := new(cgoAllocMap)
	allocseae401a9.Add(memeae401a9)

	var csType_allocs *cgoAllocMap
	refeae401a9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseae401a9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeae401a9.pNext, cpNext_allocs = unpackSBaseInStructure(x.PNext)
	allocseae401a9.Borrow(cpNext_allocs)

	x.refeae401a9 = refeae401a9
	x.allocseae401a9 = allocseae401a9
	return refeae401a9, allocseae401a9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BaseInStructure) PassValue() (C.VkBaseInStructure, *cgoAllocMap) {
	if x.refeae401a9 != nil {
		return *x.refeae401a9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BaseInStructure) Deref() {
	if x.refeae401a9 == nil {
		return
	}
	x.SType = (StructureType)(x.refeae401a9.sType)
	packSBaseInStructure(x.PNext, x.refeae401a9.pNext)
}

// allocPhysicalDeviceSubgroupPropertiesMemory allocates memory for type C.VkPhysicalDeviceSubgroupProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSubgroupPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSubgroupPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceSubgroupPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSubgroupProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSubgroupProperties) Ref() *C.VkPhysicalDeviceSubgroupProperties {
	if x == nil {
		return nil
	}
	return x.refb019c29f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSubgroupProperties) Free() {
	if x != nil && x.allocsb019c29f != nil {
		x.allocsb019c29f.(*cgoAllocMap).Free()
		x.refb019c29f = nil
	}
}

// NewPhysicalDeviceSubgroupPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSubgroupPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceSubgroupProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSubgroupProperties)
	obj.refb019c29f = (*C.VkPhysicalDeviceSubgroupProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSubgroupProperties) PassRef() (*C.VkPhysicalDeviceSubgroupProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb019c29f != nil {
		return x.refb019c29f, nil
	}
	memb019c29f := allocPhysicalDeviceSubgroupPropertiesMemory(1)
	refb019c29f := (*C.VkPhysicalDeviceSubgroupProperties)(memb019c29f)
	allocsb019c29f := new(cgoAllocMap)
	allocsb019c29f.Add(memb019c29f)

	var csType_allocs *cgoAllocMap
	refb019c29f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb019c29f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb019c29f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb019c29f.Borrow(cpNext_allocs)

	var csubgroupSize_allocs *cgoAllocMap
	refb019c29f.subgroupSize, csubgroupSize_allocs = (C.uint32_t)(x.SubgroupSize), cgoAllocsUnknown
	allocsb019c29f.Borrow(csubgroupSize_allocs)

	var csupportedStages_allocs *cgoAllocMap
	refb019c29f.supportedStages, csupportedStages_allocs = (C.VkShaderStageFlags)(x.SupportedStages), cgoAllocsUnknown
	allocsb019c29f.Borrow(csupportedStages_allocs)

	var csupportedOperations_allocs *cgoAllocMap
	refb019c29f.supportedOperations, csupportedOperations_allocs = (C.VkSubgroupFeatureFlags)(x.SupportedOperations), cgoAllocsUnknown
	allocsb019c29f.Borrow(csupportedOperations_allocs)

	var cquadOperationsInAllStages_allocs *cgoAllocMap
	refb019c29f.quadOperationsInAllStages, cquadOperationsInAllStages_allocs = (C.VkBool32)(x.QuadOperationsInAllStages), cgoAllocsUnknown
	allocsb019c29f.Borrow(cquadOperationsInAllStages_allocs)

	x.refb019c29f = refb019c29f
	x.allocsb019c29f = allocsb019c29f
	return refb019c29f, allocsb019c29f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSubgroupProperties) PassValue() (C.VkPhysicalDeviceSubgroupProperties, *cgoAllocMap) {
	if x.refb019c29f != nil {
		return *x.refb019c29f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSubgroupProperties) Deref() {
	if x.refb019c29f == nil {
		return
	}
	x.SType = (StructureType)(x.refb019c29f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb019c29f.pNext))
	x.SubgroupSize = (uint32)(x.refb019c29f.subgroupSize)
	x.SupportedStages = (ShaderStageFlags)(x.refb019c29f.supportedStages)
	x.SupportedOperations = (SubgroupFeatureFlags)(x.refb019c29f.supportedOperations)
	x.QuadOperationsInAllStages = (Bool32)(x.refb019c29f.quadOperationsInAllStages)
}

// allocBindBufferMemoryInfoMemory allocates memory for type C.VkBindBufferMemoryInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindBufferMemoryInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindBufferMemoryInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindBufferMemoryInfoValue = unsafe.Sizeof([1]C.VkBindBufferMemoryInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindBufferMemoryInfo) Ref() *C.VkBindBufferMemoryInfo {
	if x == nil {
		return nil
	}
	return x.refd392322d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindBufferMemoryInfo) Free() {
	if x != nil && x.allocsd392322d != nil {
		x.allocsd392322d.(*cgoAllocMap).Free()
		x.refd392322d = nil
	}
}

// NewBindBufferMemoryInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindBufferMemoryInfoRef(ref unsafe.Pointer) *BindBufferMemoryInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindBufferMemoryInfo)
	obj.refd392322d = (*C.VkBindBufferMemoryInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindBufferMemoryInfo) PassRef() (*C.VkBindBufferMemoryInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd392322d != nil {
		return x.refd392322d, nil
	}
	memd392322d := allocBindBufferMemoryInfoMemory(1)
	refd392322d := (*C.VkBindBufferMemoryInfo)(memd392322d)
	allocsd392322d := new(cgoAllocMap)
	allocsd392322d.Add(memd392322d)

	var csType_allocs *cgoAllocMap
	refd392322d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd392322d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd392322d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd392322d.Borrow(cpNext_allocs)

	var cbuffer_allocs *cgoAllocMap
	refd392322d.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsd392322d.Borrow(cbuffer_allocs)

	var cmemory_allocs *cgoAllocMap
	refd392322d.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocsd392322d.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	refd392322d.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocsd392322d.Borrow(cmemoryOffset_allocs)

	x.refd392322d = refd392322d
	x.allocsd392322d = allocsd392322d
	return refd392322d, allocsd392322d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindBufferMemoryInfo) PassValue() (C.VkBindBufferMemoryInfo, *cgoAllocMap) {
	if x.refd392322d != nil {
		return *x.refd392322d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindBufferMemoryInfo) Deref() {
	if x.refd392322d == nil {
		return
	}
	x.SType = (StructureType)(x.refd392322d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd392322d.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refd392322d.buffer))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.refd392322d.memory))
	x.MemoryOffset = (DeviceSize)(x.refd392322d.memoryOffset)
}

// allocBindImageMemoryInfoMemory allocates memory for type C.VkBindImageMemoryInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindImageMemoryInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindImageMemoryInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindImageMemoryInfoValue = unsafe.Sizeof([1]C.VkBindImageMemoryInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImageMemoryInfo) Ref() *C.VkBindImageMemoryInfo {
	if x == nil {
		return nil
	}
	return x.ref767a2113
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImageMemoryInfo) Free() {
	if x != nil && x.allocs767a2113 != nil {
		x.allocs767a2113.(*cgoAllocMap).Free()
		x.ref767a2113 = nil
	}
}

// NewBindImageMemoryInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImageMemoryInfoRef(ref unsafe.Pointer) *BindImageMemoryInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindImageMemoryInfo)
	obj.ref767a2113 = (*C.VkBindImageMemoryInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImageMemoryInfo) PassRef() (*C.VkBindImageMemoryInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref767a2113 != nil {
		return x.ref767a2113, nil
	}
	mem767a2113 := allocBindImageMemoryInfoMemory(1)
	ref767a2113 := (*C.VkBindImageMemoryInfo)(mem767a2113)
	allocs767a2113 := new(cgoAllocMap)
	allocs767a2113.Add(mem767a2113)

	var csType_allocs *cgoAllocMap
	ref767a2113.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs767a2113.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref767a2113.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs767a2113.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	ref767a2113.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs767a2113.Borrow(cimage_allocs)

	var cmemory_allocs *cgoAllocMap
	ref767a2113.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs767a2113.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	ref767a2113.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocs767a2113.Borrow(cmemoryOffset_allocs)

	x.ref767a2113 = ref767a2113
	x.allocs767a2113 = allocs767a2113
	return ref767a2113, allocs767a2113

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImageMemoryInfo) PassValue() (C.VkBindImageMemoryInfo, *cgoAllocMap) {
	if x.ref767a2113 != nil {
		return *x.ref767a2113, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImageMemoryInfo) Deref() {
	if x.ref767a2113 == nil {
		return
	}
	x.SType = (StructureType)(x.ref767a2113.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref767a2113.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref767a2113.image))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref767a2113.memory))
	x.MemoryOffset = (DeviceSize)(x.ref767a2113.memoryOffset)
}

// allocPhysicalDevice16BitStorageFeaturesMemory allocates memory for type C.VkPhysicalDevice16BitStorageFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevice16BitStorageFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevice16BitStorageFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDevice16BitStorageFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDevice16BitStorageFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevice16BitStorageFeatures) Ref() *C.VkPhysicalDevice16BitStorageFeatures {
	if x == nil {
		return nil
	}
	return x.refa90fed14
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevice16BitStorageFeatures) Free() {
	if x != nil && x.allocsa90fed14 != nil {
		x.allocsa90fed14.(*cgoAllocMap).Free()
		x.refa90fed14 = nil
	}
}

// NewPhysicalDevice16BitStorageFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevice16BitStorageFeaturesRef(ref unsafe.Pointer) *PhysicalDevice16BitStorageFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevice16BitStorageFeatures)
	obj.refa90fed14 = (*C.VkPhysicalDevice16BitStorageFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevice16BitStorageFeatures) PassRef() (*C.VkPhysicalDevice16BitStorageFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa90fed14 != nil {
		return x.refa90fed14, nil
	}
	mema90fed14 := allocPhysicalDevice16BitStorageFeaturesMemory(1)
	refa90fed14 := (*C.VkPhysicalDevice16BitStorageFeatures)(mema90fed14)
	allocsa90fed14 := new(cgoAllocMap)
	allocsa90fed14.Add(mema90fed14)

	var csType_allocs *cgoAllocMap
	refa90fed14.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa90fed14.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa90fed14.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa90fed14.Borrow(cpNext_allocs)

	var cstorageBuffer16BitAccess_allocs *cgoAllocMap
	refa90fed14.storageBuffer16BitAccess, cstorageBuffer16BitAccess_allocs = (C.VkBool32)(x.StorageBuffer16BitAccess), cgoAllocsUnknown
	allocsa90fed14.Borrow(cstorageBuffer16BitAccess_allocs)

	var cuniformAndStorageBuffer16BitAccess_allocs *cgoAllocMap
	refa90fed14.uniformAndStorageBuffer16BitAccess, cuniformAndStorageBuffer16BitAccess_allocs = (C.VkBool32)(x.UniformAndStorageBuffer16BitAccess), cgoAllocsUnknown
	allocsa90fed14.Borrow(cuniformAndStorageBuffer16BitAccess_allocs)

	var cstoragePushConstant16_allocs *cgoAllocMap
	refa90fed14.storagePushConstant16, cstoragePushConstant16_allocs = (C.VkBool32)(x.StoragePushConstant16), cgoAllocsUnknown
	allocsa90fed14.Borrow(cstoragePushConstant16_allocs)

	var cstorageInputOutput16_allocs *cgoAllocMap
	refa90fed14.storageInputOutput16, cstorageInputOutput16_allocs = (C.VkBool32)(x.StorageInputOutput16), cgoAllocsUnknown
	allocsa90fed14.Borrow(cstorageInputOutput16_allocs)

	x.refa90fed14 = refa90fed14
	x.allocsa90fed14 = allocsa90fed14
	return refa90fed14, allocsa90fed14

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevice16BitStorageFeatures) PassValue() (C.VkPhysicalDevice16BitStorageFeatures, *cgoAllocMap) {
	if x.refa90fed14 != nil {
		return *x.refa90fed14, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevice16BitStorageFeatures) Deref() {
	if x.refa90fed14 == nil {
		return
	}
	x.SType = (StructureType)(x.refa90fed14.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa90fed14.pNext))
	x.StorageBuffer16BitAccess = (Bool32)(x.refa90fed14.storageBuffer16BitAccess)
	x.UniformAndStorageBuffer16BitAccess = (Bool32)(x.refa90fed14.uniformAndStorageBuffer16BitAccess)
	x.StoragePushConstant16 = (Bool32)(x.refa90fed14.storagePushConstant16)
	x.StorageInputOutput16 = (Bool32)(x.refa90fed14.storageInputOutput16)
}

// allocMemoryDedicatedRequirementsMemory allocates memory for type C.VkMemoryDedicatedRequirements in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryDedicatedRequirementsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryDedicatedRequirementsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryDedicatedRequirementsValue = unsafe.Sizeof([1]C.VkMemoryDedicatedRequirements{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryDedicatedRequirements) Ref() *C.VkMemoryDedicatedRequirements {
	if x == nil {
		return nil
	}
	return x.refaa924122
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryDedicatedRequirements) Free() {
	if x != nil && x.allocsaa924122 != nil {
		x.allocsaa924122.(*cgoAllocMap).Free()
		x.refaa924122 = nil
	}
}

// NewMemoryDedicatedRequirementsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryDedicatedRequirementsRef(ref unsafe.Pointer) *MemoryDedicatedRequirements {
	if ref == nil {
		return nil
	}
	obj := new(MemoryDedicatedRequirements)
	obj.refaa924122 = (*C.VkMemoryDedicatedRequirements)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryDedicatedRequirements) PassRef() (*C.VkMemoryDedicatedRequirements, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaa924122 != nil {
		return x.refaa924122, nil
	}
	memaa924122 := allocMemoryDedicatedRequirementsMemory(1)
	refaa924122 := (*C.VkMemoryDedicatedRequirements)(memaa924122)
	allocsaa924122 := new(cgoAllocMap)
	allocsaa924122.Add(memaa924122)

	var csType_allocs *cgoAllocMap
	refaa924122.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsaa924122.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refaa924122.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsaa924122.Borrow(cpNext_allocs)

	var cprefersDedicatedAllocation_allocs *cgoAllocMap
	refaa924122.prefersDedicatedAllocation, cprefersDedicatedAllocation_allocs = (C.VkBool32)(x.PrefersDedicatedAllocation), cgoAllocsUnknown
	allocsaa924122.Borrow(cprefersDedicatedAllocation_allocs)

	var crequiresDedicatedAllocation_allocs *cgoAllocMap
	refaa924122.requiresDedicatedAllocation, crequiresDedicatedAllocation_allocs = (C.VkBool32)(x.RequiresDedicatedAllocation), cgoAllocsUnknown
	allocsaa924122.Borrow(crequiresDedicatedAllocation_allocs)

	x.refaa924122 = refaa924122
	x.allocsaa924122 = allocsaa924122
	return refaa924122, allocsaa924122

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryDedicatedRequirements) PassValue() (C.VkMemoryDedicatedRequirements, *cgoAllocMap) {
	if x.refaa924122 != nil {
		return *x.refaa924122, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryDedicatedRequirements) Deref() {
	if x.refaa924122 == nil {
		return
	}
	x.SType = (StructureType)(x.refaa924122.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refaa924122.pNext))
	x.PrefersDedicatedAllocation = (Bool32)(x.refaa924122.prefersDedicatedAllocation)
	x.RequiresDedicatedAllocation = (Bool32)(x.refaa924122.requiresDedicatedAllocation)
}

// allocMemoryDedicatedAllocateInfoMemory allocates memory for type C.VkMemoryDedicatedAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryDedicatedAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryDedicatedAllocateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryDedicatedAllocateInfoValue = unsafe.Sizeof([1]C.VkMemoryDedicatedAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryDedicatedAllocateInfo) Ref() *C.VkMemoryDedicatedAllocateInfo {
	if x == nil {
		return nil
	}
	return x.reff8fabe62
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryDedicatedAllocateInfo) Free() {
	if x != nil && x.allocsf8fabe62 != nil {
		x.allocsf8fabe62.(*cgoAllocMap).Free()
		x.reff8fabe62 = nil
	}
}

// NewMemoryDedicatedAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryDedicatedAllocateInfoRef(ref unsafe.Pointer) *MemoryDedicatedAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(MemoryDedicatedAllocateInfo)
	obj.reff8fabe62 = (*C.VkMemoryDedicatedAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryDedicatedAllocateInfo) PassRef() (*C.VkMemoryDedicatedAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff8fabe62 != nil {
		return x.reff8fabe62, nil
	}
	memf8fabe62 := allocMemoryDedicatedAllocateInfoMemory(1)
	reff8fabe62 := (*C.VkMemoryDedicatedAllocateInfo)(memf8fabe62)
	allocsf8fabe62 := new(cgoAllocMap)
	allocsf8fabe62.Add(memf8fabe62)

	var csType_allocs *cgoAllocMap
	reff8fabe62.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf8fabe62.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff8fabe62.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf8fabe62.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	reff8fabe62.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocsf8fabe62.Borrow(cimage_allocs)

	var cbuffer_allocs *cgoAllocMap
	reff8fabe62.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsf8fabe62.Borrow(cbuffer_allocs)

	x.reff8fabe62 = reff8fabe62
	x.allocsf8fabe62 = allocsf8fabe62
	return reff8fabe62, allocsf8fabe62

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryDedicatedAllocateInfo) PassValue() (C.VkMemoryDedicatedAllocateInfo, *cgoAllocMap) {
	if x.reff8fabe62 != nil {
		return *x.reff8fabe62, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryDedicatedAllocateInfo) Deref() {
	if x.reff8fabe62 == nil {
		return
	}
	x.SType = (StructureType)(x.reff8fabe62.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff8fabe62.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.reff8fabe62.image))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.reff8fabe62.buffer))
}

// allocMemoryAllocateFlagsInfoMemory allocates memory for type C.VkMemoryAllocateFlagsInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryAllocateFlagsInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryAllocateFlagsInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryAllocateFlagsInfoValue = unsafe.Sizeof([1]C.VkMemoryAllocateFlagsInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryAllocateFlagsInfo) Ref() *C.VkMemoryAllocateFlagsInfo {
	if x == nil {
		return nil
	}
	return x.ref7ca6664
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryAllocateFlagsInfo) Free() {
	if x != nil && x.allocs7ca6664 != nil {
		x.allocs7ca6664.(*cgoAllocMap).Free()
		x.ref7ca6664 = nil
	}
}

// NewMemoryAllocateFlagsInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryAllocateFlagsInfoRef(ref unsafe.Pointer) *MemoryAllocateFlagsInfo {
	if ref == nil {
		return nil
	}
	obj := new(MemoryAllocateFlagsInfo)
	obj.ref7ca6664 = (*C.VkMemoryAllocateFlagsInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryAllocateFlagsInfo) PassRef() (*C.VkMemoryAllocateFlagsInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7ca6664 != nil {
		return x.ref7ca6664, nil
	}
	mem7ca6664 := allocMemoryAllocateFlagsInfoMemory(1)
	ref7ca6664 := (*C.VkMemoryAllocateFlagsInfo)(mem7ca6664)
	allocs7ca6664 := new(cgoAllocMap)
	allocs7ca6664.Add(mem7ca6664)

	var csType_allocs *cgoAllocMap
	ref7ca6664.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7ca6664.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7ca6664.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7ca6664.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref7ca6664.flags, cflags_allocs = (C.VkMemoryAllocateFlags)(x.Flags), cgoAllocsUnknown
	allocs7ca6664.Borrow(cflags_allocs)

	var cdeviceMask_allocs *cgoAllocMap
	ref7ca6664.deviceMask, cdeviceMask_allocs = (C.uint32_t)(x.DeviceMask), cgoAllocsUnknown
	allocs7ca6664.Borrow(cdeviceMask_allocs)

	x.ref7ca6664 = ref7ca6664
	x.allocs7ca6664 = allocs7ca6664
	return ref7ca6664, allocs7ca6664

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryAllocateFlagsInfo) PassValue() (C.VkMemoryAllocateFlagsInfo, *cgoAllocMap) {
	if x.ref7ca6664 != nil {
		return *x.ref7ca6664, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryAllocateFlagsInfo) Deref() {
	if x.ref7ca6664 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7ca6664.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7ca6664.pNext))
	x.Flags = (MemoryAllocateFlags)(x.ref7ca6664.flags)
	x.DeviceMask = (uint32)(x.ref7ca6664.deviceMask)
}

// allocDeviceGroupRenderPassBeginInfoMemory allocates memory for type C.VkDeviceGroupRenderPassBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupRenderPassBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupRenderPassBeginInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGroupRenderPassBeginInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupRenderPassBeginInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupRenderPassBeginInfo) Ref() *C.VkDeviceGroupRenderPassBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref139f3599
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupRenderPassBeginInfo) Free() {
	if x != nil && x.allocs139f3599 != nil {
		x.allocs139f3599.(*cgoAllocMap).Free()
		x.ref139f3599 = nil
	}
}

// NewDeviceGroupRenderPassBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupRenderPassBeginInfoRef(ref unsafe.Pointer) *DeviceGroupRenderPassBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupRenderPassBeginInfo)
	obj.ref139f3599 = (*C.VkDeviceGroupRenderPassBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupRenderPassBeginInfo) PassRef() (*C.VkDeviceGroupRenderPassBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref139f3599 != nil {
		return x.ref139f3599, nil
	}
	mem139f3599 := allocDeviceGroupRenderPassBeginInfoMemory(1)
	ref139f3599 := (*C.VkDeviceGroupRenderPassBeginInfo)(mem139f3599)
	allocs139f3599 := new(cgoAllocMap)
	allocs139f3599.Add(mem139f3599)

	var csType_allocs *cgoAllocMap
	ref139f3599.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs139f3599.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref139f3599.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs139f3599.Borrow(cpNext_allocs)

	var cdeviceMask_allocs *cgoAllocMap
	ref139f3599.deviceMask, cdeviceMask_allocs = (C.uint32_t)(x.DeviceMask), cgoAllocsUnknown
	allocs139f3599.Borrow(cdeviceMask_allocs)

	var cdeviceRenderAreaCount_allocs *cgoAllocMap
	ref139f3599.deviceRenderAreaCount, cdeviceRenderAreaCount_allocs = (C.uint32_t)(x.DeviceRenderAreaCount), cgoAllocsUnknown
	allocs139f3599.Borrow(cdeviceRenderAreaCount_allocs)

	var cpDeviceRenderAreas_allocs *cgoAllocMap
	ref139f3599.pDeviceRenderAreas, cpDeviceRenderAreas_allocs = unpackSRect2D(x.PDeviceRenderAreas)
	allocs139f3599.Borrow(cpDeviceRenderAreas_allocs)

	x.ref139f3599 = ref139f3599
	x.allocs139f3599 = allocs139f3599
	return ref139f3599, allocs139f3599

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupRenderPassBeginInfo) PassValue() (C.VkDeviceGroupRenderPassBeginInfo, *cgoAllocMap) {
	if x.ref139f3599 != nil {
		return *x.ref139f3599, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupRenderPassBeginInfo) Deref() {
	if x.ref139f3599 == nil {
		return
	}
	x.SType = (StructureType)(x.ref139f3599.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref139f3599.pNext))
	x.DeviceMask = (uint32)(x.ref139f3599.deviceMask)
	x.DeviceRenderAreaCount = (uint32)(x.ref139f3599.deviceRenderAreaCount)
	packSRect2D(x.PDeviceRenderAreas, x.ref139f3599.pDeviceRenderAreas)
}

// allocDeviceGroupCommandBufferBeginInfoMemory allocates memory for type C.VkDeviceGroupCommandBufferBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupCommandBufferBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupCommandBufferBeginInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGroupCommandBufferBeginInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupCommandBufferBeginInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupCommandBufferBeginInfo) Ref() *C.VkDeviceGroupCommandBufferBeginInfo {
	if x == nil {
		return nil
	}
	return x.refb9a8f0cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupCommandBufferBeginInfo) Free() {
	if x != nil && x.allocsb9a8f0cd != nil {
		x.allocsb9a8f0cd.(*cgoAllocMap).Free()
		x.refb9a8f0cd = nil
	}
}

// NewDeviceGroupCommandBufferBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupCommandBufferBeginInfoRef(ref unsafe.Pointer) *DeviceGroupCommandBufferBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupCommandBufferBeginInfo)
	obj.refb9a8f0cd = (*C.VkDeviceGroupCommandBufferBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupCommandBufferBeginInfo) PassRef() (*C.VkDeviceGroupCommandBufferBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb9a8f0cd != nil {
		return x.refb9a8f0cd, nil
	}
	memb9a8f0cd := allocDeviceGroupCommandBufferBeginInfoMemory(1)
	refb9a8f0cd := (*C.VkDeviceGroupCommandBufferBeginInfo)(memb9a8f0cd)
	allocsb9a8f0cd := new(cgoAllocMap)
	allocsb9a8f0cd.Add(memb9a8f0cd)

	var csType_allocs *cgoAllocMap
	refb9a8f0cd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb9a8f0cd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb9a8f0cd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb9a8f0cd.Borrow(cpNext_allocs)

	var cdeviceMask_allocs *cgoAllocMap
	refb9a8f0cd.deviceMask, cdeviceMask_allocs = (C.uint32_t)(x.DeviceMask), cgoAllocsUnknown
	allocsb9a8f0cd.Borrow(cdeviceMask_allocs)

	x.refb9a8f0cd = refb9a8f0cd
	x.allocsb9a8f0cd = allocsb9a8f0cd
	return refb9a8f0cd, allocsb9a8f0cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupCommandBufferBeginInfo) PassValue() (C.VkDeviceGroupCommandBufferBeginInfo, *cgoAllocMap) {
	if x.refb9a8f0cd != nil {
		return *x.refb9a8f0cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupCommandBufferBeginInfo) Deref() {
	if x.refb9a8f0cd == nil {
		return
	}
	x.SType = (StructureType)(x.refb9a8f0cd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb9a8f0cd.pNext))
	x.DeviceMask = (uint32)(x.refb9a8f0cd.deviceMask)
}

// allocDeviceGroupSubmitInfoMemory allocates memory for type C.VkDeviceGroupSubmitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupSubmitInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGroupSubmitInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupSubmitInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupSubmitInfo) Ref() *C.VkDeviceGroupSubmitInfo {
	if x == nil {
		return nil
	}
	return x.refea4e7ce4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupSubmitInfo) Free() {
	if x != nil && x.allocsea4e7ce4 != nil {
		x.allocsea4e7ce4.(*cgoAllocMap).Free()
		x.refea4e7ce4 = nil
	}
}

// NewDeviceGroupSubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupSubmitInfoRef(ref unsafe.Pointer) *DeviceGroupSubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupSubmitInfo)
	obj.refea4e7ce4 = (*C.VkDeviceGroupSubmitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupSubmitInfo) PassRef() (*C.VkDeviceGroupSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refea4e7ce4 != nil {
		return x.refea4e7ce4, nil
	}
	memea4e7ce4 := allocDeviceGroupSubmitInfoMemory(1)
	refea4e7ce4 := (*C.VkDeviceGroupSubmitInfo)(memea4e7ce4)
	allocsea4e7ce4 := new(cgoAllocMap)
	allocsea4e7ce4.Add(memea4e7ce4)

	var csType_allocs *cgoAllocMap
	refea4e7ce4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refea4e7ce4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	refea4e7ce4.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphoreDeviceIndices_allocs *cgoAllocMap
	refea4e7ce4.pWaitSemaphoreDeviceIndices, cpWaitSemaphoreDeviceIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphoreDeviceIndices)).Data)), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(cpWaitSemaphoreDeviceIndices_allocs)

	var ccommandBufferCount_allocs *cgoAllocMap
	refea4e7ce4.commandBufferCount, ccommandBufferCount_allocs = (C.uint32_t)(x.CommandBufferCount), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(ccommandBufferCount_allocs)

	var cpCommandBufferDeviceMasks_allocs *cgoAllocMap
	refea4e7ce4.pCommandBufferDeviceMasks, cpCommandBufferDeviceMasks_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCommandBufferDeviceMasks)).Data)), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(cpCommandBufferDeviceMasks_allocs)

	var csignalSemaphoreCount_allocs *cgoAllocMap
	refea4e7ce4.signalSemaphoreCount, csignalSemaphoreCount_allocs = (C.uint32_t)(x.SignalSemaphoreCount), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(csignalSemaphoreCount_allocs)

	var cpSignalSemaphoreDeviceIndices_allocs *cgoAllocMap
	refea4e7ce4.pSignalSemaphoreDeviceIndices, cpSignalSemaphoreDeviceIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphoreDeviceIndices)).Data)), cgoAllocsUnknown
	allocsea4e7ce4.Borrow(cpSignalSemaphoreDeviceIndices_allocs)

	x.refea4e7ce4 = refea4e7ce4
	x.allocsea4e7ce4 = allocsea4e7ce4
	return refea4e7ce4, allocsea4e7ce4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupSubmitInfo) PassValue() (C.VkDeviceGroupSubmitInfo, *cgoAllocMap) {
	if x.refea4e7ce4 != nil {
		return *x.refea4e7ce4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupSubmitInfo) Deref() {
	if x.refea4e7ce4 == nil {
		return
	}
	x.SType = (StructureType)(x.refea4e7ce4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refea4e7ce4.pNext))
	x.WaitSemaphoreCount = (uint32)(x.refea4e7ce4.waitSemaphoreCount)
	hxf04b15b := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphoreDeviceIndices))
	hxf04b15b.Data = unsafe.Pointer(x.refea4e7ce4.pWaitSemaphoreDeviceIndices)
	hxf04b15b.Cap = 0x7fffffff
	// hxf04b15b.Len = ?

	x.CommandBufferCount = (uint32)(x.refea4e7ce4.commandBufferCount)
	hxf2f888b := (*sliceHeader)(unsafe.Pointer(&x.PCommandBufferDeviceMasks))
	hxf2f888b.Data = unsafe.Pointer(x.refea4e7ce4.pCommandBufferDeviceMasks)
	hxf2f888b.Cap = 0x7fffffff
	// hxf2f888b.Len = ?

	x.SignalSemaphoreCount = (uint32)(x.refea4e7ce4.signalSemaphoreCount)
	hxf5d1de2 := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphoreDeviceIndices))
	hxf5d1de2.Data = unsafe.Pointer(x.refea4e7ce4.pSignalSemaphoreDeviceIndices)
	hxf5d1de2.Cap = 0x7fffffff
	// hxf5d1de2.Len = ?

}

// allocDeviceGroupBindSparseInfoMemory allocates memory for type C.VkDeviceGroupBindSparseInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupBindSparseInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupBindSparseInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGroupBindSparseInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupBindSparseInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupBindSparseInfo) Ref() *C.VkDeviceGroupBindSparseInfo {
	if x == nil {
		return nil
	}
	return x.ref5b5446cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupBindSparseInfo) Free() {
	if x != nil && x.allocs5b5446cd != nil {
		x.allocs5b5446cd.(*cgoAllocMap).Free()
		x.ref5b5446cd = nil
	}
}

// NewDeviceGroupBindSparseInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupBindSparseInfoRef(ref unsafe.Pointer) *DeviceGroupBindSparseInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupBindSparseInfo)
	obj.ref5b5446cd = (*C.VkDeviceGroupBindSparseInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupBindSparseInfo) PassRef() (*C.VkDeviceGroupBindSparseInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5b5446cd != nil {
		return x.ref5b5446cd, nil
	}
	mem5b5446cd := allocDeviceGroupBindSparseInfoMemory(1)
	ref5b5446cd := (*C.VkDeviceGroupBindSparseInfo)(mem5b5446cd)
	allocs5b5446cd := new(cgoAllocMap)
	allocs5b5446cd.Add(mem5b5446cd)

	var csType_allocs *cgoAllocMap
	ref5b5446cd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5b5446cd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5b5446cd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5b5446cd.Borrow(cpNext_allocs)

	var cresourceDeviceIndex_allocs *cgoAllocMap
	ref5b5446cd.resourceDeviceIndex, cresourceDeviceIndex_allocs = (C.uint32_t)(x.ResourceDeviceIndex), cgoAllocsUnknown
	allocs5b5446cd.Borrow(cresourceDeviceIndex_allocs)

	var cmemoryDeviceIndex_allocs *cgoAllocMap
	ref5b5446cd.memoryDeviceIndex, cmemoryDeviceIndex_allocs = (C.uint32_t)(x.MemoryDeviceIndex), cgoAllocsUnknown
	allocs5b5446cd.Borrow(cmemoryDeviceIndex_allocs)

	x.ref5b5446cd = ref5b5446cd
	x.allocs5b5446cd = allocs5b5446cd
	return ref5b5446cd, allocs5b5446cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupBindSparseInfo) PassValue() (C.VkDeviceGroupBindSparseInfo, *cgoAllocMap) {
	if x.ref5b5446cd != nil {
		return *x.ref5b5446cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupBindSparseInfo) Deref() {
	if x.ref5b5446cd == nil {
		return
	}
	x.SType = (StructureType)(x.ref5b5446cd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5b5446cd.pNext))
	x.ResourceDeviceIndex = (uint32)(x.ref5b5446cd.resourceDeviceIndex)
	x.MemoryDeviceIndex = (uint32)(x.ref5b5446cd.memoryDeviceIndex)
}

// allocBindBufferMemoryDeviceGroupInfoMemory allocates memory for type C.VkBindBufferMemoryDeviceGroupInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindBufferMemoryDeviceGroupInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindBufferMemoryDeviceGroupInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindBufferMemoryDeviceGroupInfoValue = unsafe.Sizeof([1]C.VkBindBufferMemoryDeviceGroupInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindBufferMemoryDeviceGroupInfo) Ref() *C.VkBindBufferMemoryDeviceGroupInfo {
	if x == nil {
		return nil
	}
	return x.reff136b64f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindBufferMemoryDeviceGroupInfo) Free() {
	if x != nil && x.allocsf136b64f != nil {
		x.allocsf136b64f.(*cgoAllocMap).Free()
		x.reff136b64f = nil
	}
}

// NewBindBufferMemoryDeviceGroupInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindBufferMemoryDeviceGroupInfoRef(ref unsafe.Pointer) *BindBufferMemoryDeviceGroupInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindBufferMemoryDeviceGroupInfo)
	obj.reff136b64f = (*C.VkBindBufferMemoryDeviceGroupInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindBufferMemoryDeviceGroupInfo) PassRef() (*C.VkBindBufferMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff136b64f != nil {
		return x.reff136b64f, nil
	}
	memf136b64f := allocBindBufferMemoryDeviceGroupInfoMemory(1)
	reff136b64f := (*C.VkBindBufferMemoryDeviceGroupInfo)(memf136b64f)
	allocsf136b64f := new(cgoAllocMap)
	allocsf136b64f.Add(memf136b64f)

	var csType_allocs *cgoAllocMap
	reff136b64f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf136b64f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff136b64f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf136b64f.Borrow(cpNext_allocs)

	var cdeviceIndexCount_allocs *cgoAllocMap
	reff136b64f.deviceIndexCount, cdeviceIndexCount_allocs = (C.uint32_t)(x.DeviceIndexCount), cgoAllocsUnknown
	allocsf136b64f.Borrow(cdeviceIndexCount_allocs)

	var cpDeviceIndices_allocs *cgoAllocMap
	reff136b64f.pDeviceIndices, cpDeviceIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices)).Data)), cgoAllocsUnknown
	allocsf136b64f.Borrow(cpDeviceIndices_allocs)

	x.reff136b64f = reff136b64f
	x.allocsf136b64f = allocsf136b64f
	return reff136b64f, allocsf136b64f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindBufferMemoryDeviceGroupInfo) PassValue() (C.VkBindBufferMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x.reff136b64f != nil {
		return *x.reff136b64f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindBufferMemoryDeviceGroupInfo) Deref() {
	if x.reff136b64f == nil {
		return
	}
	x.SType = (StructureType)(x.reff136b64f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff136b64f.pNext))
	x.DeviceIndexCount = (uint32)(x.reff136b64f.deviceIndexCount)
	hxfe53d34 := (*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices))
	hxfe53d34.Data = unsafe.Pointer(x.reff136b64f.pDeviceIndices)
	hxfe53d34.Cap = 0x7fffffff
	// hxfe53d34.Len = ?

}

// allocBindImageMemoryDeviceGroupInfoMemory allocates memory for type C.VkBindImageMemoryDeviceGroupInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindImageMemoryDeviceGroupInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindImageMemoryDeviceGroupInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindImageMemoryDeviceGroupInfoValue = unsafe.Sizeof([1]C.VkBindImageMemoryDeviceGroupInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImageMemoryDeviceGroupInfo) Ref() *C.VkBindImageMemoryDeviceGroupInfo {
	if x == nil {
		return nil
	}
	return x.ref24f026a5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImageMemoryDeviceGroupInfo) Free() {
	if x != nil && x.allocs24f026a5 != nil {
		x.allocs24f026a5.(*cgoAllocMap).Free()
		x.ref24f026a5 = nil
	}
}

// NewBindImageMemoryDeviceGroupInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImageMemoryDeviceGroupInfoRef(ref unsafe.Pointer) *BindImageMemoryDeviceGroupInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindImageMemoryDeviceGroupInfo)
	obj.ref24f026a5 = (*C.VkBindImageMemoryDeviceGroupInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImageMemoryDeviceGroupInfo) PassRef() (*C.VkBindImageMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref24f026a5 != nil {
		return x.ref24f026a5, nil
	}
	mem24f026a5 := allocBindImageMemoryDeviceGroupInfoMemory(1)
	ref24f026a5 := (*C.VkBindImageMemoryDeviceGroupInfo)(mem24f026a5)
	allocs24f026a5 := new(cgoAllocMap)
	allocs24f026a5.Add(mem24f026a5)

	var csType_allocs *cgoAllocMap
	ref24f026a5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs24f026a5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref24f026a5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs24f026a5.Borrow(cpNext_allocs)

	var cdeviceIndexCount_allocs *cgoAllocMap
	ref24f026a5.deviceIndexCount, cdeviceIndexCount_allocs = (C.uint32_t)(x.DeviceIndexCount), cgoAllocsUnknown
	allocs24f026a5.Borrow(cdeviceIndexCount_allocs)

	var cpDeviceIndices_allocs *cgoAllocMap
	ref24f026a5.pDeviceIndices, cpDeviceIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices)).Data)), cgoAllocsUnknown
	allocs24f026a5.Borrow(cpDeviceIndices_allocs)

	var csplitInstanceBindRegionCount_allocs *cgoAllocMap
	ref24f026a5.splitInstanceBindRegionCount, csplitInstanceBindRegionCount_allocs = (C.uint32_t)(x.SplitInstanceBindRegionCount), cgoAllocsUnknown
	allocs24f026a5.Borrow(csplitInstanceBindRegionCount_allocs)

	var cpSplitInstanceBindRegions_allocs *cgoAllocMap
	ref24f026a5.pSplitInstanceBindRegions, cpSplitInstanceBindRegions_allocs = unpackSRect2D(x.PSplitInstanceBindRegions)
	allocs24f026a5.Borrow(cpSplitInstanceBindRegions_allocs)

	x.ref24f026a5 = ref24f026a5
	x.allocs24f026a5 = allocs24f026a5
	return ref24f026a5, allocs24f026a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImageMemoryDeviceGroupInfo) PassValue() (C.VkBindImageMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x.ref24f026a5 != nil {
		return *x.ref24f026a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImageMemoryDeviceGroupInfo) Deref() {
	if x.ref24f026a5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref24f026a5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref24f026a5.pNext))
	x.DeviceIndexCount = (uint32)(x.ref24f026a5.deviceIndexCount)
	hxf547023 := (*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices))
	hxf547023.Data = unsafe.Pointer(x.ref24f026a5.pDeviceIndices)
	hxf547023.Cap = 0x7fffffff
	// hxf547023.Len = ?

	x.SplitInstanceBindRegionCount = (uint32)(x.ref24f026a5.splitInstanceBindRegionCount)
	packSRect2D(x.PSplitInstanceBindRegions, x.ref24f026a5.pSplitInstanceBindRegions)
}

// allocPhysicalDeviceGroupPropertiesMemory allocates memory for type C.VkPhysicalDeviceGroupProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceGroupPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceGroupPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceGroupPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceGroupProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceGroupProperties) Ref() *C.VkPhysicalDeviceGroupProperties {
	if x == nil {
		return nil
	}
	return x.ref2aa9a663
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceGroupProperties) Free() {
	if x != nil && x.allocs2aa9a663 != nil {
		x.allocs2aa9a663.(*cgoAllocMap).Free()
		x.ref2aa9a663 = nil
	}
}

// NewPhysicalDeviceGroupPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceGroupPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceGroupProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceGroupProperties)
	obj.ref2aa9a663 = (*C.VkPhysicalDeviceGroupProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceGroupProperties) PassRef() (*C.VkPhysicalDeviceGroupProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2aa9a663 != nil {
		return x.ref2aa9a663, nil
	}
	mem2aa9a663 := allocPhysicalDeviceGroupPropertiesMemory(1)
	ref2aa9a663 := (*C.VkPhysicalDeviceGroupProperties)(mem2aa9a663)
	allocs2aa9a663 := new(cgoAllocMap)
	allocs2aa9a663.Add(mem2aa9a663)

	var csType_allocs *cgoAllocMap
	ref2aa9a663.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2aa9a663.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2aa9a663.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2aa9a663.Borrow(cpNext_allocs)

	var cphysicalDeviceCount_allocs *cgoAllocMap
	ref2aa9a663.physicalDeviceCount, cphysicalDeviceCount_allocs = (C.uint32_t)(x.PhysicalDeviceCount), cgoAllocsUnknown
	allocs2aa9a663.Borrow(cphysicalDeviceCount_allocs)

	var cphysicalDevices_allocs *cgoAllocMap
	ref2aa9a663.physicalDevices, cphysicalDevices_allocs = *(*[32]C.VkPhysicalDevice)(unsafe.Pointer(&x.PhysicalDevices)), cgoAllocsUnknown
	allocs2aa9a663.Borrow(cphysicalDevices_allocs)

	var csubsetAllocation_allocs *cgoAllocMap
	ref2aa9a663.subsetAllocation, csubsetAllocation_allocs = (C.VkBool32)(x.SubsetAllocation), cgoAllocsUnknown
	allocs2aa9a663.Borrow(csubsetAllocation_allocs)

	x.ref2aa9a663 = ref2aa9a663
	x.allocs2aa9a663 = allocs2aa9a663
	return ref2aa9a663, allocs2aa9a663

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceGroupProperties) PassValue() (C.VkPhysicalDeviceGroupProperties, *cgoAllocMap) {
	if x.ref2aa9a663 != nil {
		return *x.ref2aa9a663, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceGroupProperties) Deref() {
	if x.ref2aa9a663 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2aa9a663.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2aa9a663.pNext))
	x.PhysicalDeviceCount = (uint32)(x.ref2aa9a663.physicalDeviceCount)
	x.PhysicalDevices = *(*[32]PhysicalDevice)(unsafe.Pointer(&x.ref2aa9a663.physicalDevices))
	x.SubsetAllocation = (Bool32)(x.ref2aa9a663.subsetAllocation)
}

// allocDeviceGroupDeviceCreateInfoMemory allocates memory for type C.VkDeviceGroupDeviceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupDeviceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupDeviceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGroupDeviceCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupDeviceCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupDeviceCreateInfo) Ref() *C.VkDeviceGroupDeviceCreateInfo {
	if x == nil {
		return nil
	}
	return x.refb2275723
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupDeviceCreateInfo) Free() {
	if x != nil && x.allocsb2275723 != nil {
		x.allocsb2275723.(*cgoAllocMap).Free()
		x.refb2275723 = nil
	}
}

// NewDeviceGroupDeviceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupDeviceCreateInfoRef(ref unsafe.Pointer) *DeviceGroupDeviceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupDeviceCreateInfo)
	obj.refb2275723 = (*C.VkDeviceGroupDeviceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupDeviceCreateInfo) PassRef() (*C.VkDeviceGroupDeviceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb2275723 != nil {
		return x.refb2275723, nil
	}
	memb2275723 := allocDeviceGroupDeviceCreateInfoMemory(1)
	refb2275723 := (*C.VkDeviceGroupDeviceCreateInfo)(memb2275723)
	allocsb2275723 := new(cgoAllocMap)
	allocsb2275723.Add(memb2275723)

	var csType_allocs *cgoAllocMap
	refb2275723.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb2275723.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb2275723.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb2275723.Borrow(cpNext_allocs)

	var cphysicalDeviceCount_allocs *cgoAllocMap
	refb2275723.physicalDeviceCount, cphysicalDeviceCount_allocs = (C.uint32_t)(x.PhysicalDeviceCount), cgoAllocsUnknown
	allocsb2275723.Borrow(cphysicalDeviceCount_allocs)

	var cpPhysicalDevices_allocs *cgoAllocMap
	refb2275723.pPhysicalDevices, cpPhysicalDevices_allocs = (*C.VkPhysicalDevice)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PPhysicalDevices)).Data)), cgoAllocsUnknown
	allocsb2275723.Borrow(cpPhysicalDevices_allocs)

	x.refb2275723 = refb2275723
	x.allocsb2275723 = allocsb2275723
	return refb2275723, allocsb2275723

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupDeviceCreateInfo) PassValue() (C.VkDeviceGroupDeviceCreateInfo, *cgoAllocMap) {
	if x.refb2275723 != nil {
		return *x.refb2275723, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupDeviceCreateInfo) Deref() {
	if x.refb2275723 == nil {
		return
	}
	x.SType = (StructureType)(x.refb2275723.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb2275723.pNext))
	x.PhysicalDeviceCount = (uint32)(x.refb2275723.physicalDeviceCount)
	hxf5ebb88 := (*sliceHeader)(unsafe.Pointer(&x.PPhysicalDevices))
	hxf5ebb88.Data = unsafe.Pointer(x.refb2275723.pPhysicalDevices)
	hxf5ebb88.Cap = 0x7fffffff
	// hxf5ebb88.Len = ?

}

// allocBufferMemoryRequirementsInfo2Memory allocates memory for type C.VkBufferMemoryRequirementsInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferMemoryRequirementsInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferMemoryRequirementsInfo2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferMemoryRequirementsInfo2Value = unsafe.Sizeof([1]C.VkBufferMemoryRequirementsInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferMemoryRequirementsInfo2) Ref() *C.VkBufferMemoryRequirementsInfo2 {
	if x == nil {
		return nil
	}
	return x.reff54a2a42
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferMemoryRequirementsInfo2) Free() {
	if x != nil && x.allocsf54a2a42 != nil {
		x.allocsf54a2a42.(*cgoAllocMap).Free()
		x.reff54a2a42 = nil
	}
}

// NewBufferMemoryRequirementsInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferMemoryRequirementsInfo2Ref(ref unsafe.Pointer) *BufferMemoryRequirementsInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(BufferMemoryRequirementsInfo2)
	obj.reff54a2a42 = (*C.VkBufferMemoryRequirementsInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferMemoryRequirementsInfo2) PassRef() (*C.VkBufferMemoryRequirementsInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff54a2a42 != nil {
		return x.reff54a2a42, nil
	}
	memf54a2a42 := allocBufferMemoryRequirementsInfo2Memory(1)
	reff54a2a42 := (*C.VkBufferMemoryRequirementsInfo2)(memf54a2a42)
	allocsf54a2a42 := new(cgoAllocMap)
	allocsf54a2a42.Add(memf54a2a42)

	var csType_allocs *cgoAllocMap
	reff54a2a42.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf54a2a42.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff54a2a42.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf54a2a42.Borrow(cpNext_allocs)

	var cbuffer_allocs *cgoAllocMap
	reff54a2a42.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsf54a2a42.Borrow(cbuffer_allocs)

	x.reff54a2a42 = reff54a2a42
	x.allocsf54a2a42 = allocsf54a2a42
	return reff54a2a42, allocsf54a2a42

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferMemoryRequirementsInfo2) PassValue() (C.VkBufferMemoryRequirementsInfo2, *cgoAllocMap) {
	if x.reff54a2a42 != nil {
		return *x.reff54a2a42, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferMemoryRequirementsInfo2) Deref() {
	if x.reff54a2a42 == nil {
		return
	}
	x.SType = (StructureType)(x.reff54a2a42.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff54a2a42.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.reff54a2a42.buffer))
}

// allocImageMemoryRequirementsInfo2Memory allocates memory for type C.VkImageMemoryRequirementsInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemoryRequirementsInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageMemoryRequirementsInfo2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageMemoryRequirementsInfo2Value = unsafe.Sizeof([1]C.VkImageMemoryRequirementsInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageMemoryRequirementsInfo2) Ref() *C.VkImageMemoryRequirementsInfo2 {
	if x == nil {
		return nil
	}
	return x.ref75b3ca05
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageMemoryRequirementsInfo2) Free() {
	if x != nil && x.allocs75b3ca05 != nil {
		x.allocs75b3ca05.(*cgoAllocMap).Free()
		x.ref75b3ca05 = nil
	}
}

// NewImageMemoryRequirementsInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageMemoryRequirementsInfo2Ref(ref unsafe.Pointer) *ImageMemoryRequirementsInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(ImageMemoryRequirementsInfo2)
	obj.ref75b3ca05 = (*C.VkImageMemoryRequirementsInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageMemoryRequirementsInfo2) PassRef() (*C.VkImageMemoryRequirementsInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref75b3ca05 != nil {
		return x.ref75b3ca05, nil
	}
	mem75b3ca05 := allocImageMemoryRequirementsInfo2Memory(1)
	ref75b3ca05 := (*C.VkImageMemoryRequirementsInfo2)(mem75b3ca05)
	allocs75b3ca05 := new(cgoAllocMap)
	allocs75b3ca05.Add(mem75b3ca05)

	var csType_allocs *cgoAllocMap
	ref75b3ca05.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs75b3ca05.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref75b3ca05.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs75b3ca05.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	ref75b3ca05.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs75b3ca05.Borrow(cimage_allocs)

	x.ref75b3ca05 = ref75b3ca05
	x.allocs75b3ca05 = allocs75b3ca05
	return ref75b3ca05, allocs75b3ca05

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageMemoryRequirementsInfo2) PassValue() (C.VkImageMemoryRequirementsInfo2, *cgoAllocMap) {
	if x.ref75b3ca05 != nil {
		return *x.ref75b3ca05, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageMemoryRequirementsInfo2) Deref() {
	if x.ref75b3ca05 == nil {
		return
	}
	x.SType = (StructureType)(x.ref75b3ca05.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref75b3ca05.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref75b3ca05.image))
}

// allocImageSparseMemoryRequirementsInfo2Memory allocates memory for type C.VkImageSparseMemoryRequirementsInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSparseMemoryRequirementsInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSparseMemoryRequirementsInfo2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageSparseMemoryRequirementsInfo2Value = unsafe.Sizeof([1]C.VkImageSparseMemoryRequirementsInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSparseMemoryRequirementsInfo2) Ref() *C.VkImageSparseMemoryRequirementsInfo2 {
	if x == nil {
		return nil
	}
	return x.ref878956f7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSparseMemoryRequirementsInfo2) Free() {
	if x != nil && x.allocs878956f7 != nil {
		x.allocs878956f7.(*cgoAllocMap).Free()
		x.ref878956f7 = nil
	}
}

// NewImageSparseMemoryRequirementsInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSparseMemoryRequirementsInfo2Ref(ref unsafe.Pointer) *ImageSparseMemoryRequirementsInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(ImageSparseMemoryRequirementsInfo2)
	obj.ref878956f7 = (*C.VkImageSparseMemoryRequirementsInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSparseMemoryRequirementsInfo2) PassRef() (*C.VkImageSparseMemoryRequirementsInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref878956f7 != nil {
		return x.ref878956f7, nil
	}
	mem878956f7 := allocImageSparseMemoryRequirementsInfo2Memory(1)
	ref878956f7 := (*C.VkImageSparseMemoryRequirementsInfo2)(mem878956f7)
	allocs878956f7 := new(cgoAllocMap)
	allocs878956f7.Add(mem878956f7)

	var csType_allocs *cgoAllocMap
	ref878956f7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs878956f7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref878956f7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs878956f7.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	ref878956f7.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs878956f7.Borrow(cimage_allocs)

	x.ref878956f7 = ref878956f7
	x.allocs878956f7 = allocs878956f7
	return ref878956f7, allocs878956f7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSparseMemoryRequirementsInfo2) PassValue() (C.VkImageSparseMemoryRequirementsInfo2, *cgoAllocMap) {
	if x.ref878956f7 != nil {
		return *x.ref878956f7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSparseMemoryRequirementsInfo2) Deref() {
	if x.ref878956f7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref878956f7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref878956f7.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref878956f7.image))
}

// allocMemoryRequirements2Memory allocates memory for type C.VkMemoryRequirements2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryRequirements2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryRequirements2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryRequirements2Value = unsafe.Sizeof([1]C.VkMemoryRequirements2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryRequirements2) Ref() *C.VkMemoryRequirements2 {
	if x == nil {
		return nil
	}
	return x.refc0e75f21
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryRequirements2) Free() {
	if x != nil && x.allocsc0e75f21 != nil {
		x.allocsc0e75f21.(*cgoAllocMap).Free()
		x.refc0e75f21 = nil
	}
}

// NewMemoryRequirements2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryRequirements2Ref(ref unsafe.Pointer) *MemoryRequirements2 {
	if ref == nil {
		return nil
	}
	obj := new(MemoryRequirements2)
	obj.refc0e75f21 = (*C.VkMemoryRequirements2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryRequirements2) PassRef() (*C.VkMemoryRequirements2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0e75f21 != nil {
		return x.refc0e75f21, nil
	}
	memc0e75f21 := allocMemoryRequirements2Memory(1)
	refc0e75f21 := (*C.VkMemoryRequirements2)(memc0e75f21)
	allocsc0e75f21 := new(cgoAllocMap)
	allocsc0e75f21.Add(memc0e75f21)

	var csType_allocs *cgoAllocMap
	refc0e75f21.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc0e75f21.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc0e75f21.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc0e75f21.Borrow(cpNext_allocs)

	var cmemoryRequirements_allocs *cgoAllocMap
	refc0e75f21.memoryRequirements, cmemoryRequirements_allocs = x.MemoryRequirements.PassValue()
	allocsc0e75f21.Borrow(cmemoryRequirements_allocs)

	x.refc0e75f21 = refc0e75f21
	x.allocsc0e75f21 = allocsc0e75f21
	return refc0e75f21, allocsc0e75f21

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryRequirements2) PassValue() (C.VkMemoryRequirements2, *cgoAllocMap) {
	if x.refc0e75f21 != nil {
		return *x.refc0e75f21, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryRequirements2) Deref() {
	if x.refc0e75f21 == nil {
		return
	}
	x.SType = (StructureType)(x.refc0e75f21.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc0e75f21.pNext))
	x.MemoryRequirements = *NewMemoryRequirementsRef(unsafe.Pointer(&x.refc0e75f21.memoryRequirements))
}

// allocSparseImageMemoryRequirements2Memory allocates memory for type C.VkSparseImageMemoryRequirements2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryRequirements2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryRequirements2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageMemoryRequirements2Value = unsafe.Sizeof([1]C.VkSparseImageMemoryRequirements2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageMemoryRequirements2) Ref() *C.VkSparseImageMemoryRequirements2 {
	if x == nil {
		return nil
	}
	return x.refb8da955c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageMemoryRequirements2) Free() {
	if x != nil && x.allocsb8da955c != nil {
		x.allocsb8da955c.(*cgoAllocMap).Free()
		x.refb8da955c = nil
	}
}

// NewSparseImageMemoryRequirements2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageMemoryRequirements2Ref(ref unsafe.Pointer) *SparseImageMemoryRequirements2 {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryRequirements2)
	obj.refb8da955c = (*C.VkSparseImageMemoryRequirements2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageMemoryRequirements2) PassRef() (*C.VkSparseImageMemoryRequirements2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8da955c != nil {
		return x.refb8da955c, nil
	}
	memb8da955c := allocSparseImageMemoryRequirements2Memory(1)
	refb8da955c := (*C.VkSparseImageMemoryRequirements2)(memb8da955c)
	allocsb8da955c := new(cgoAllocMap)
	allocsb8da955c.Add(memb8da955c)

	var csType_allocs *cgoAllocMap
	refb8da955c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb8da955c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb8da955c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb8da955c.Borrow(cpNext_allocs)

	var cmemoryRequirements_allocs *cgoAllocMap
	refb8da955c.memoryRequirements, cmemoryRequirements_allocs = x.MemoryRequirements.PassValue()
	allocsb8da955c.Borrow(cmemoryRequirements_allocs)

	x.refb8da955c = refb8da955c
	x.allocsb8da955c = allocsb8da955c
	return refb8da955c, allocsb8da955c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageMemoryRequirements2) PassValue() (C.VkSparseImageMemoryRequirements2, *cgoAllocMap) {
	if x.refb8da955c != nil {
		return *x.refb8da955c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageMemoryRequirements2) Deref() {
	if x.refb8da955c == nil {
		return
	}
	x.SType = (StructureType)(x.refb8da955c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb8da955c.pNext))
	x.MemoryRequirements = *NewSparseImageMemoryRequirementsRef(unsafe.Pointer(&x.refb8da955c.memoryRequirements))
}

// allocPhysicalDeviceFeatures2Memory allocates memory for type C.VkPhysicalDeviceFeatures2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFeatures2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFeatures2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceFeatures2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceFeatures2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFeatures2) Ref() *C.VkPhysicalDeviceFeatures2 {
	if x == nil {
		return nil
	}
	return x.refff6ed04
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFeatures2) Free() {
	if x != nil && x.allocsff6ed04 != nil {
		x.allocsff6ed04.(*cgoAllocMap).Free()
		x.refff6ed04 = nil
	}
}

// NewPhysicalDeviceFeatures2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFeatures2Ref(ref unsafe.Pointer) *PhysicalDeviceFeatures2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFeatures2)
	obj.refff6ed04 = (*C.VkPhysicalDeviceFeatures2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFeatures2) PassRef() (*C.VkPhysicalDeviceFeatures2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refff6ed04 != nil {
		return x.refff6ed04, nil
	}
	memff6ed04 := allocPhysicalDeviceFeatures2Memory(1)
	refff6ed04 := (*C.VkPhysicalDeviceFeatures2)(memff6ed04)
	allocsff6ed04 := new(cgoAllocMap)
	allocsff6ed04.Add(memff6ed04)

	var csType_allocs *cgoAllocMap
	refff6ed04.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsff6ed04.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refff6ed04.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsff6ed04.Borrow(cpNext_allocs)

	var cfeatures_allocs *cgoAllocMap
	refff6ed04.features, cfeatures_allocs = x.Features.PassValue()
	allocsff6ed04.Borrow(cfeatures_allocs)

	x.refff6ed04 = refff6ed04
	x.allocsff6ed04 = allocsff6ed04
	return refff6ed04, allocsff6ed04

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFeatures2) PassValue() (C.VkPhysicalDeviceFeatures2, *cgoAllocMap) {
	if x.refff6ed04 != nil {
		return *x.refff6ed04, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFeatures2) Deref() {
	if x.refff6ed04 == nil {
		return
	}
	x.SType = (StructureType)(x.refff6ed04.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refff6ed04.pNext))
	x.Features = *NewPhysicalDeviceFeaturesRef(unsafe.Pointer(&x.refff6ed04.features))
}

// allocPhysicalDeviceProperties2Memory allocates memory for type C.VkPhysicalDeviceProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceProperties2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceProperties2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceProperties2) Ref() *C.VkPhysicalDeviceProperties2 {
	if x == nil {
		return nil
	}
	return x.ref947bd13e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceProperties2) Free() {
	if x != nil && x.allocs947bd13e != nil {
		x.allocs947bd13e.(*cgoAllocMap).Free()
		x.ref947bd13e = nil
	}
}

// NewPhysicalDeviceProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceProperties2Ref(ref unsafe.Pointer) *PhysicalDeviceProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProperties2)
	obj.ref947bd13e = (*C.VkPhysicalDeviceProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceProperties2) PassRef() (*C.VkPhysicalDeviceProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref947bd13e != nil {
		return x.ref947bd13e, nil
	}
	mem947bd13e := allocPhysicalDeviceProperties2Memory(1)
	ref947bd13e := (*C.VkPhysicalDeviceProperties2)(mem947bd13e)
	allocs947bd13e := new(cgoAllocMap)
	allocs947bd13e.Add(mem947bd13e)

	var csType_allocs *cgoAllocMap
	ref947bd13e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs947bd13e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref947bd13e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs947bd13e.Borrow(cpNext_allocs)

	var cproperties_allocs *cgoAllocMap
	ref947bd13e.properties, cproperties_allocs = x.Properties.PassValue()
	allocs947bd13e.Borrow(cproperties_allocs)

	x.ref947bd13e = ref947bd13e
	x.allocs947bd13e = allocs947bd13e
	return ref947bd13e, allocs947bd13e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceProperties2) PassValue() (C.VkPhysicalDeviceProperties2, *cgoAllocMap) {
	if x.ref947bd13e != nil {
		return *x.ref947bd13e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceProperties2) Deref() {
	if x.ref947bd13e == nil {
		return
	}
	x.SType = (StructureType)(x.ref947bd13e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref947bd13e.pNext))
	x.Properties = *NewPhysicalDevicePropertiesRef(unsafe.Pointer(&x.ref947bd13e.properties))
}

// allocFormatProperties2Memory allocates memory for type C.VkFormatProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFormatProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFormatProperties2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFormatProperties2Value = unsafe.Sizeof([1]C.VkFormatProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FormatProperties2) Ref() *C.VkFormatProperties2 {
	if x == nil {
		return nil
	}
	return x.refddc6af2a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FormatProperties2) Free() {
	if x != nil && x.allocsddc6af2a != nil {
		x.allocsddc6af2a.(*cgoAllocMap).Free()
		x.refddc6af2a = nil
	}
}

// NewFormatProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFormatProperties2Ref(ref unsafe.Pointer) *FormatProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(FormatProperties2)
	obj.refddc6af2a = (*C.VkFormatProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FormatProperties2) PassRef() (*C.VkFormatProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refddc6af2a != nil {
		return x.refddc6af2a, nil
	}
	memddc6af2a := allocFormatProperties2Memory(1)
	refddc6af2a := (*C.VkFormatProperties2)(memddc6af2a)
	allocsddc6af2a := new(cgoAllocMap)
	allocsddc6af2a.Add(memddc6af2a)

	var csType_allocs *cgoAllocMap
	refddc6af2a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsddc6af2a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refddc6af2a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsddc6af2a.Borrow(cpNext_allocs)

	var cformatProperties_allocs *cgoAllocMap
	refddc6af2a.formatProperties, cformatProperties_allocs = x.FormatProperties.PassValue()
	allocsddc6af2a.Borrow(cformatProperties_allocs)

	x.refddc6af2a = refddc6af2a
	x.allocsddc6af2a = allocsddc6af2a
	return refddc6af2a, allocsddc6af2a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FormatProperties2) PassValue() (C.VkFormatProperties2, *cgoAllocMap) {
	if x.refddc6af2a != nil {
		return *x.refddc6af2a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FormatProperties2) Deref() {
	if x.refddc6af2a == nil {
		return
	}
	x.SType = (StructureType)(x.refddc6af2a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refddc6af2a.pNext))
	x.FormatProperties = *NewFormatPropertiesRef(unsafe.Pointer(&x.refddc6af2a.formatProperties))
}

// allocImageFormatProperties2Memory allocates memory for type C.VkImageFormatProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageFormatProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageFormatProperties2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageFormatProperties2Value = unsafe.Sizeof([1]C.VkImageFormatProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageFormatProperties2) Ref() *C.VkImageFormatProperties2 {
	if x == nil {
		return nil
	}
	return x.ref224187e7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageFormatProperties2) Free() {
	if x != nil && x.allocs224187e7 != nil {
		x.allocs224187e7.(*cgoAllocMap).Free()
		x.ref224187e7 = nil
	}
}

// NewImageFormatProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageFormatProperties2Ref(ref unsafe.Pointer) *ImageFormatProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(ImageFormatProperties2)
	obj.ref224187e7 = (*C.VkImageFormatProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageFormatProperties2) PassRef() (*C.VkImageFormatProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref224187e7 != nil {
		return x.ref224187e7, nil
	}
	mem224187e7 := allocImageFormatProperties2Memory(1)
	ref224187e7 := (*C.VkImageFormatProperties2)(mem224187e7)
	allocs224187e7 := new(cgoAllocMap)
	allocs224187e7.Add(mem224187e7)

	var csType_allocs *cgoAllocMap
	ref224187e7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs224187e7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref224187e7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs224187e7.Borrow(cpNext_allocs)

	var cimageFormatProperties_allocs *cgoAllocMap
	ref224187e7.imageFormatProperties, cimageFormatProperties_allocs = x.ImageFormatProperties.PassValue()
	allocs224187e7.Borrow(cimageFormatProperties_allocs)

	x.ref224187e7 = ref224187e7
	x.allocs224187e7 = allocs224187e7
	return ref224187e7, allocs224187e7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageFormatProperties2) PassValue() (C.VkImageFormatProperties2, *cgoAllocMap) {
	if x.ref224187e7 != nil {
		return *x.ref224187e7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageFormatProperties2) Deref() {
	if x.ref224187e7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref224187e7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref224187e7.pNext))
	x.ImageFormatProperties = *NewImageFormatPropertiesRef(unsafe.Pointer(&x.ref224187e7.imageFormatProperties))
}

// allocPhysicalDeviceImageFormatInfo2Memory allocates memory for type C.VkPhysicalDeviceImageFormatInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceImageFormatInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceImageFormatInfo2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceImageFormatInfo2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceImageFormatInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceImageFormatInfo2) Ref() *C.VkPhysicalDeviceImageFormatInfo2 {
	if x == nil {
		return nil
	}
	return x.ref5934b445
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceImageFormatInfo2) Free() {
	if x != nil && x.allocs5934b445 != nil {
		x.allocs5934b445.(*cgoAllocMap).Free()
		x.ref5934b445 = nil
	}
}

// NewPhysicalDeviceImageFormatInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceImageFormatInfo2Ref(ref unsafe.Pointer) *PhysicalDeviceImageFormatInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceImageFormatInfo2)
	obj.ref5934b445 = (*C.VkPhysicalDeviceImageFormatInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceImageFormatInfo2) PassRef() (*C.VkPhysicalDeviceImageFormatInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5934b445 != nil {
		return x.ref5934b445, nil
	}
	mem5934b445 := allocPhysicalDeviceImageFormatInfo2Memory(1)
	ref5934b445 := (*C.VkPhysicalDeviceImageFormatInfo2)(mem5934b445)
	allocs5934b445 := new(cgoAllocMap)
	allocs5934b445.Add(mem5934b445)

	var csType_allocs *cgoAllocMap
	ref5934b445.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5934b445.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5934b445.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5934b445.Borrow(cpNext_allocs)

	var cformat_allocs *cgoAllocMap
	ref5934b445.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs5934b445.Borrow(cformat_allocs)

	var c_type_allocs *cgoAllocMap
	ref5934b445._type, c_type_allocs = (C.VkImageType)(x.Type), cgoAllocsUnknown
	allocs5934b445.Borrow(c_type_allocs)

	var ctiling_allocs *cgoAllocMap
	ref5934b445.tiling, ctiling_allocs = (C.VkImageTiling)(x.Tiling), cgoAllocsUnknown
	allocs5934b445.Borrow(ctiling_allocs)

	var cusage_allocs *cgoAllocMap
	ref5934b445.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocs5934b445.Borrow(cusage_allocs)

	var cflags_allocs *cgoAllocMap
	ref5934b445.flags, cflags_allocs = (C.VkImageCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs5934b445.Borrow(cflags_allocs)

	x.ref5934b445 = ref5934b445
	x.allocs5934b445 = allocs5934b445
	return ref5934b445, allocs5934b445

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceImageFormatInfo2) PassValue() (C.VkPhysicalDeviceImageFormatInfo2, *cgoAllocMap) {
	if x.ref5934b445 != nil {
		return *x.ref5934b445, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceImageFormatInfo2) Deref() {
	if x.ref5934b445 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5934b445.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5934b445.pNext))
	x.Format = (Format)(x.ref5934b445.format)
	x.Type = (ImageType)(x.ref5934b445._type)
	x.Tiling = (ImageTiling)(x.ref5934b445.tiling)
	x.Usage = (ImageUsageFlags)(x.ref5934b445.usage)
	x.Flags = (ImageCreateFlags)(x.ref5934b445.flags)
}

// allocQueueFamilyProperties2Memory allocates memory for type C.VkQueueFamilyProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueueFamilyProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueueFamilyProperties2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfQueueFamilyProperties2Value = unsafe.Sizeof([1]C.VkQueueFamilyProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueueFamilyProperties2) Ref() *C.VkQueueFamilyProperties2 {
	if x == nil {
		return nil
	}
	return x.ref85bf626c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueueFamilyProperties2) Free() {
	if x != nil && x.allocs85bf626c != nil {
		x.allocs85bf626c.(*cgoAllocMap).Free()
		x.ref85bf626c = nil
	}
}

// NewQueueFamilyProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueueFamilyProperties2Ref(ref unsafe.Pointer) *QueueFamilyProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(QueueFamilyProperties2)
	obj.ref85bf626c = (*C.VkQueueFamilyProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueueFamilyProperties2) PassRef() (*C.VkQueueFamilyProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85bf626c != nil {
		return x.ref85bf626c, nil
	}
	mem85bf626c := allocQueueFamilyProperties2Memory(1)
	ref85bf626c := (*C.VkQueueFamilyProperties2)(mem85bf626c)
	allocs85bf626c := new(cgoAllocMap)
	allocs85bf626c.Add(mem85bf626c)

	var csType_allocs *cgoAllocMap
	ref85bf626c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs85bf626c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref85bf626c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs85bf626c.Borrow(cpNext_allocs)

	var cqueueFamilyProperties_allocs *cgoAllocMap
	ref85bf626c.queueFamilyProperties, cqueueFamilyProperties_allocs = x.QueueFamilyProperties.PassValue()
	allocs85bf626c.Borrow(cqueueFamilyProperties_allocs)

	x.ref85bf626c = ref85bf626c
	x.allocs85bf626c = allocs85bf626c
	return ref85bf626c, allocs85bf626c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueueFamilyProperties2) PassValue() (C.VkQueueFamilyProperties2, *cgoAllocMap) {
	if x.ref85bf626c != nil {
		return *x.ref85bf626c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueueFamilyProperties2) Deref() {
	if x.ref85bf626c == nil {
		return
	}
	x.SType = (StructureType)(x.ref85bf626c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref85bf626c.pNext))
	x.QueueFamilyProperties = *NewQueueFamilyPropertiesRef(unsafe.Pointer(&x.ref85bf626c.queueFamilyProperties))
}

// allocPhysicalDeviceMemoryProperties2Memory allocates memory for type C.VkPhysicalDeviceMemoryProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMemoryProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMemoryProperties2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceMemoryProperties2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceMemoryProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMemoryProperties2) Ref() *C.VkPhysicalDeviceMemoryProperties2 {
	if x == nil {
		return nil
	}
	return x.refd9e39b19
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMemoryProperties2) Free() {
	if x != nil && x.allocsd9e39b19 != nil {
		x.allocsd9e39b19.(*cgoAllocMap).Free()
		x.refd9e39b19 = nil
	}
}

// NewPhysicalDeviceMemoryProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMemoryProperties2Ref(ref unsafe.Pointer) *PhysicalDeviceMemoryProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMemoryProperties2)
	obj.refd9e39b19 = (*C.VkPhysicalDeviceMemoryProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMemoryProperties2) PassRef() (*C.VkPhysicalDeviceMemoryProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd9e39b19 != nil {
		return x.refd9e39b19, nil
	}
	memd9e39b19 := allocPhysicalDeviceMemoryProperties2Memory(1)
	refd9e39b19 := (*C.VkPhysicalDeviceMemoryProperties2)(memd9e39b19)
	allocsd9e39b19 := new(cgoAllocMap)
	allocsd9e39b19.Add(memd9e39b19)

	var csType_allocs *cgoAllocMap
	refd9e39b19.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd9e39b19.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd9e39b19.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd9e39b19.Borrow(cpNext_allocs)

	var cmemoryProperties_allocs *cgoAllocMap
	refd9e39b19.memoryProperties, cmemoryProperties_allocs = x.MemoryProperties.PassValue()
	allocsd9e39b19.Borrow(cmemoryProperties_allocs)

	x.refd9e39b19 = refd9e39b19
	x.allocsd9e39b19 = allocsd9e39b19
	return refd9e39b19, allocsd9e39b19

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMemoryProperties2) PassValue() (C.VkPhysicalDeviceMemoryProperties2, *cgoAllocMap) {
	if x.refd9e39b19 != nil {
		return *x.refd9e39b19, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMemoryProperties2) Deref() {
	if x.refd9e39b19 == nil {
		return
	}
	x.SType = (StructureType)(x.refd9e39b19.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd9e39b19.pNext))
	x.MemoryProperties = *NewPhysicalDeviceMemoryPropertiesRef(unsafe.Pointer(&x.refd9e39b19.memoryProperties))
}

// allocSparseImageFormatProperties2Memory allocates memory for type C.VkSparseImageFormatProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageFormatProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageFormatProperties2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSparseImageFormatProperties2Value = unsafe.Sizeof([1]C.VkSparseImageFormatProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageFormatProperties2) Ref() *C.VkSparseImageFormatProperties2 {
	if x == nil {
		return nil
	}
	return x.ref6b48294b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageFormatProperties2) Free() {
	if x != nil && x.allocs6b48294b != nil {
		x.allocs6b48294b.(*cgoAllocMap).Free()
		x.ref6b48294b = nil
	}
}

// NewSparseImageFormatProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageFormatProperties2Ref(ref unsafe.Pointer) *SparseImageFormatProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageFormatProperties2)
	obj.ref6b48294b = (*C.VkSparseImageFormatProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageFormatProperties2) PassRef() (*C.VkSparseImageFormatProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6b48294b != nil {
		return x.ref6b48294b, nil
	}
	mem6b48294b := allocSparseImageFormatProperties2Memory(1)
	ref6b48294b := (*C.VkSparseImageFormatProperties2)(mem6b48294b)
	allocs6b48294b := new(cgoAllocMap)
	allocs6b48294b.Add(mem6b48294b)

	var csType_allocs *cgoAllocMap
	ref6b48294b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6b48294b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6b48294b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6b48294b.Borrow(cpNext_allocs)

	var cproperties_allocs *cgoAllocMap
	ref6b48294b.properties, cproperties_allocs = x.Properties.PassValue()
	allocs6b48294b.Borrow(cproperties_allocs)

	x.ref6b48294b = ref6b48294b
	x.allocs6b48294b = allocs6b48294b
	return ref6b48294b, allocs6b48294b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageFormatProperties2) PassValue() (C.VkSparseImageFormatProperties2, *cgoAllocMap) {
	if x.ref6b48294b != nil {
		return *x.ref6b48294b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageFormatProperties2) Deref() {
	if x.ref6b48294b == nil {
		return
	}
	x.SType = (StructureType)(x.ref6b48294b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6b48294b.pNext))
	x.Properties = *NewSparseImageFormatPropertiesRef(unsafe.Pointer(&x.ref6b48294b.properties))
}

// allocPhysicalDeviceSparseImageFormatInfo2Memory allocates memory for type C.VkPhysicalDeviceSparseImageFormatInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSparseImageFormatInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSparseImageFormatInfo2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceSparseImageFormatInfo2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceSparseImageFormatInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSparseImageFormatInfo2) Ref() *C.VkPhysicalDeviceSparseImageFormatInfo2 {
	if x == nil {
		return nil
	}
	return x.ref566d5513
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSparseImageFormatInfo2) Free() {
	if x != nil && x.allocs566d5513 != nil {
		x.allocs566d5513.(*cgoAllocMap).Free()
		x.ref566d5513 = nil
	}
}

// NewPhysicalDeviceSparseImageFormatInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSparseImageFormatInfo2Ref(ref unsafe.Pointer) *PhysicalDeviceSparseImageFormatInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSparseImageFormatInfo2)
	obj.ref566d5513 = (*C.VkPhysicalDeviceSparseImageFormatInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSparseImageFormatInfo2) PassRef() (*C.VkPhysicalDeviceSparseImageFormatInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref566d5513 != nil {
		return x.ref566d5513, nil
	}
	mem566d5513 := allocPhysicalDeviceSparseImageFormatInfo2Memory(1)
	ref566d5513 := (*C.VkPhysicalDeviceSparseImageFormatInfo2)(mem566d5513)
	allocs566d5513 := new(cgoAllocMap)
	allocs566d5513.Add(mem566d5513)

	var csType_allocs *cgoAllocMap
	ref566d5513.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs566d5513.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref566d5513.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs566d5513.Borrow(cpNext_allocs)

	var cformat_allocs *cgoAllocMap
	ref566d5513.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs566d5513.Borrow(cformat_allocs)

	var c_type_allocs *cgoAllocMap
	ref566d5513._type, c_type_allocs = (C.VkImageType)(x.Type), cgoAllocsUnknown
	allocs566d5513.Borrow(c_type_allocs)

	var csamples_allocs *cgoAllocMap
	ref566d5513.samples, csamples_allocs = (C.VkSampleCountFlagBits)(x.Samples), cgoAllocsUnknown
	allocs566d5513.Borrow(csamples_allocs)

	var cusage_allocs *cgoAllocMap
	ref566d5513.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocs566d5513.Borrow(cusage_allocs)

	var ctiling_allocs *cgoAllocMap
	ref566d5513.tiling, ctiling_allocs = (C.VkImageTiling)(x.Tiling), cgoAllocsUnknown
	allocs566d5513.Borrow(ctiling_allocs)

	x.ref566d5513 = ref566d5513
	x.allocs566d5513 = allocs566d5513
	return ref566d5513, allocs566d5513

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSparseImageFormatInfo2) PassValue() (C.VkPhysicalDeviceSparseImageFormatInfo2, *cgoAllocMap) {
	if x.ref566d5513 != nil {
		return *x.ref566d5513, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSparseImageFormatInfo2) Deref() {
	if x.ref566d5513 == nil {
		return
	}
	x.SType = (StructureType)(x.ref566d5513.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref566d5513.pNext))
	x.Format = (Format)(x.ref566d5513.format)
	x.Type = (ImageType)(x.ref566d5513._type)
	x.Samples = (SampleCountFlagBits)(x.ref566d5513.samples)
	x.Usage = (ImageUsageFlags)(x.ref566d5513.usage)
	x.Tiling = (ImageTiling)(x.ref566d5513.tiling)
}

// allocPhysicalDevicePointClippingPropertiesMemory allocates memory for type C.VkPhysicalDevicePointClippingProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePointClippingPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePointClippingPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDevicePointClippingPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDevicePointClippingProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevicePointClippingProperties) Ref() *C.VkPhysicalDevicePointClippingProperties {
	if x == nil {
		return nil
	}
	return x.ref5afbd22f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevicePointClippingProperties) Free() {
	if x != nil && x.allocs5afbd22f != nil {
		x.allocs5afbd22f.(*cgoAllocMap).Free()
		x.ref5afbd22f = nil
	}
}

// NewPhysicalDevicePointClippingPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePointClippingPropertiesRef(ref unsafe.Pointer) *PhysicalDevicePointClippingProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevicePointClippingProperties)
	obj.ref5afbd22f = (*C.VkPhysicalDevicePointClippingProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevicePointClippingProperties) PassRef() (*C.VkPhysicalDevicePointClippingProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5afbd22f != nil {
		return x.ref5afbd22f, nil
	}
	mem5afbd22f := allocPhysicalDevicePointClippingPropertiesMemory(1)
	ref5afbd22f := (*C.VkPhysicalDevicePointClippingProperties)(mem5afbd22f)
	allocs5afbd22f := new(cgoAllocMap)
	allocs5afbd22f.Add(mem5afbd22f)

	var csType_allocs *cgoAllocMap
	ref5afbd22f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5afbd22f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5afbd22f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5afbd22f.Borrow(cpNext_allocs)

	var cpointClippingBehavior_allocs *cgoAllocMap
	ref5afbd22f.pointClippingBehavior, cpointClippingBehavior_allocs = (C.VkPointClippingBehavior)(x.PointClippingBehavior), cgoAllocsUnknown
	allocs5afbd22f.Borrow(cpointClippingBehavior_allocs)

	x.ref5afbd22f = ref5afbd22f
	x.allocs5afbd22f = allocs5afbd22f
	return ref5afbd22f, allocs5afbd22f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevicePointClippingProperties) PassValue() (C.VkPhysicalDevicePointClippingProperties, *cgoAllocMap) {
	if x.ref5afbd22f != nil {
		return *x.ref5afbd22f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevicePointClippingProperties) Deref() {
	if x.ref5afbd22f == nil {
		return
	}
	x.SType = (StructureType)(x.ref5afbd22f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5afbd22f.pNext))
	x.PointClippingBehavior = (PointClippingBehavior)(x.ref5afbd22f.pointClippingBehavior)
}

// allocInputAttachmentAspectReferenceMemory allocates memory for type C.VkInputAttachmentAspectReference in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInputAttachmentAspectReferenceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInputAttachmentAspectReferenceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfInputAttachmentAspectReferenceValue = unsafe.Sizeof([1]C.VkInputAttachmentAspectReference{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *InputAttachmentAspectReference) Ref() *C.VkInputAttachmentAspectReference {
	if x == nil {
		return nil
	}
	return x.ref4f7194e6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *InputAttachmentAspectReference) Free() {
	if x != nil && x.allocs4f7194e6 != nil {
		x.allocs4f7194e6.(*cgoAllocMap).Free()
		x.ref4f7194e6 = nil
	}
}

// NewInputAttachmentAspectReferenceRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewInputAttachmentAspectReferenceRef(ref unsafe.Pointer) *InputAttachmentAspectReference {
	if ref == nil {
		return nil
	}
	obj := new(InputAttachmentAspectReference)
	obj.ref4f7194e6 = (*C.VkInputAttachmentAspectReference)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *InputAttachmentAspectReference) PassRef() (*C.VkInputAttachmentAspectReference, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4f7194e6 != nil {
		return x.ref4f7194e6, nil
	}
	mem4f7194e6 := allocInputAttachmentAspectReferenceMemory(1)
	ref4f7194e6 := (*C.VkInputAttachmentAspectReference)(mem4f7194e6)
	allocs4f7194e6 := new(cgoAllocMap)
	allocs4f7194e6.Add(mem4f7194e6)

	var csubpass_allocs *cgoAllocMap
	ref4f7194e6.subpass, csubpass_allocs = (C.uint32_t)(x.Subpass), cgoAllocsUnknown
	allocs4f7194e6.Borrow(csubpass_allocs)

	var cinputAttachmentIndex_allocs *cgoAllocMap
	ref4f7194e6.inputAttachmentIndex, cinputAttachmentIndex_allocs = (C.uint32_t)(x.InputAttachmentIndex), cgoAllocsUnknown
	allocs4f7194e6.Borrow(cinputAttachmentIndex_allocs)

	var caspectMask_allocs *cgoAllocMap
	ref4f7194e6.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocs4f7194e6.Borrow(caspectMask_allocs)

	x.ref4f7194e6 = ref4f7194e6
	x.allocs4f7194e6 = allocs4f7194e6
	return ref4f7194e6, allocs4f7194e6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x InputAttachmentAspectReference) PassValue() (C.VkInputAttachmentAspectReference, *cgoAllocMap) {
	if x.ref4f7194e6 != nil {
		return *x.ref4f7194e6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *InputAttachmentAspectReference) Deref() {
	if x.ref4f7194e6 == nil {
		return
	}
	x.Subpass = (uint32)(x.ref4f7194e6.subpass)
	x.InputAttachmentIndex = (uint32)(x.ref4f7194e6.inputAttachmentIndex)
	x.AspectMask = (ImageAspectFlags)(x.ref4f7194e6.aspectMask)
}

// allocRenderPassInputAttachmentAspectCreateInfoMemory allocates memory for type C.VkRenderPassInputAttachmentAspectCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassInputAttachmentAspectCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassInputAttachmentAspectCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderPassInputAttachmentAspectCreateInfoValue = unsafe.Sizeof([1]C.VkRenderPassInputAttachmentAspectCreateInfo{})

// unpackSInputAttachmentAspectReference transforms a sliced Go data structure into plain C format.
func unpackSInputAttachmentAspectReference(x []InputAttachmentAspectReference) (unpacked *C.VkInputAttachmentAspectReference, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkInputAttachmentAspectReference) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocInputAttachmentAspectReferenceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkInputAttachmentAspectReference)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkInputAttachmentAspectReference)(h.Data)
	return
}

// packSInputAttachmentAspectReference reads sliced Go data structure out from plain C format.
func packSInputAttachmentAspectReference(v []InputAttachmentAspectReference, ptr0 *C.VkInputAttachmentAspectReference) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfInputAttachmentAspectReferenceValue]C.VkInputAttachmentAspectReference)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewInputAttachmentAspectReferenceRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassInputAttachmentAspectCreateInfo) Ref() *C.VkRenderPassInputAttachmentAspectCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref34eaa5c7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassInputAttachmentAspectCreateInfo) Free() {
	if x != nil && x.allocs34eaa5c7 != nil {
		x.allocs34eaa5c7.(*cgoAllocMap).Free()
		x.ref34eaa5c7 = nil
	}
}

// NewRenderPassInputAttachmentAspectCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassInputAttachmentAspectCreateInfoRef(ref unsafe.Pointer) *RenderPassInputAttachmentAspectCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassInputAttachmentAspectCreateInfo)
	obj.ref34eaa5c7 = (*C.VkRenderPassInputAttachmentAspectCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassInputAttachmentAspectCreateInfo) PassRef() (*C.VkRenderPassInputAttachmentAspectCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref34eaa5c7 != nil {
		return x.ref34eaa5c7, nil
	}
	mem34eaa5c7 := allocRenderPassInputAttachmentAspectCreateInfoMemory(1)
	ref34eaa5c7 := (*C.VkRenderPassInputAttachmentAspectCreateInfo)(mem34eaa5c7)
	allocs34eaa5c7 := new(cgoAllocMap)
	allocs34eaa5c7.Add(mem34eaa5c7)

	var csType_allocs *cgoAllocMap
	ref34eaa5c7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs34eaa5c7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref34eaa5c7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs34eaa5c7.Borrow(cpNext_allocs)

	var caspectReferenceCount_allocs *cgoAllocMap
	ref34eaa5c7.aspectReferenceCount, caspectReferenceCount_allocs = (C.uint32_t)(x.AspectReferenceCount), cgoAllocsUnknown
	allocs34eaa5c7.Borrow(caspectReferenceCount_allocs)

	var cpAspectReferences_allocs *cgoAllocMap
	ref34eaa5c7.pAspectReferences, cpAspectReferences_allocs = unpackSInputAttachmentAspectReference(x.PAspectReferences)
	allocs34eaa5c7.Borrow(cpAspectReferences_allocs)

	x.ref34eaa5c7 = ref34eaa5c7
	x.allocs34eaa5c7 = allocs34eaa5c7
	return ref34eaa5c7, allocs34eaa5c7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassInputAttachmentAspectCreateInfo) PassValue() (C.VkRenderPassInputAttachmentAspectCreateInfo, *cgoAllocMap) {
	if x.ref34eaa5c7 != nil {
		return *x.ref34eaa5c7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassInputAttachmentAspectCreateInfo) Deref() {
	if x.ref34eaa5c7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref34eaa5c7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref34eaa5c7.pNext))
	x.AspectReferenceCount = (uint32)(x.ref34eaa5c7.aspectReferenceCount)
	packSInputAttachmentAspectReference(x.PAspectReferences, x.ref34eaa5c7.pAspectReferences)
}

// allocImageViewUsageCreateInfoMemory allocates memory for type C.VkImageViewUsageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageViewUsageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageViewUsageCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageViewUsageCreateInfoValue = unsafe.Sizeof([1]C.VkImageViewUsageCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageViewUsageCreateInfo) Ref() *C.VkImageViewUsageCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref3791cec9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageViewUsageCreateInfo) Free() {
	if x != nil && x.allocs3791cec9 != nil {
		x.allocs3791cec9.(*cgoAllocMap).Free()
		x.ref3791cec9 = nil
	}
}

// NewImageViewUsageCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageViewUsageCreateInfoRef(ref unsafe.Pointer) *ImageViewUsageCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageViewUsageCreateInfo)
	obj.ref3791cec9 = (*C.VkImageViewUsageCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageViewUsageCreateInfo) PassRef() (*C.VkImageViewUsageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3791cec9 != nil {
		return x.ref3791cec9, nil
	}
	mem3791cec9 := allocImageViewUsageCreateInfoMemory(1)
	ref3791cec9 := (*C.VkImageViewUsageCreateInfo)(mem3791cec9)
	allocs3791cec9 := new(cgoAllocMap)
	allocs3791cec9.Add(mem3791cec9)

	var csType_allocs *cgoAllocMap
	ref3791cec9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3791cec9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3791cec9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3791cec9.Borrow(cpNext_allocs)

	var cusage_allocs *cgoAllocMap
	ref3791cec9.usage, cusage_allocs = (C.VkImageUsageFlags)(x.Usage), cgoAllocsUnknown
	allocs3791cec9.Borrow(cusage_allocs)

	x.ref3791cec9 = ref3791cec9
	x.allocs3791cec9 = allocs3791cec9
	return ref3791cec9, allocs3791cec9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageViewUsageCreateInfo) PassValue() (C.VkImageViewUsageCreateInfo, *cgoAllocMap) {
	if x.ref3791cec9 != nil {
		return *x.ref3791cec9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageViewUsageCreateInfo) Deref() {
	if x.ref3791cec9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3791cec9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3791cec9.pNext))
	x.Usage = (ImageUsageFlags)(x.ref3791cec9.usage)
}

// allocPipelineTessellationDomainOriginStateCreateInfoMemory allocates memory for type C.VkPipelineTessellationDomainOriginStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineTessellationDomainOriginStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineTessellationDomainOriginStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineTessellationDomainOriginStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineTessellationDomainOriginStateCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineTessellationDomainOriginStateCreateInfo) Ref() *C.VkPipelineTessellationDomainOriginStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref58ef29bf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineTessellationDomainOriginStateCreateInfo) Free() {
	if x != nil && x.allocs58ef29bf != nil {
		x.allocs58ef29bf.(*cgoAllocMap).Free()
		x.ref58ef29bf = nil
	}
}

// NewPipelineTessellationDomainOriginStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineTessellationDomainOriginStateCreateInfoRef(ref unsafe.Pointer) *PipelineTessellationDomainOriginStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineTessellationDomainOriginStateCreateInfo)
	obj.ref58ef29bf = (*C.VkPipelineTessellationDomainOriginStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineTessellationDomainOriginStateCreateInfo) PassRef() (*C.VkPipelineTessellationDomainOriginStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref58ef29bf != nil {
		return x.ref58ef29bf, nil
	}
	mem58ef29bf := allocPipelineTessellationDomainOriginStateCreateInfoMemory(1)
	ref58ef29bf := (*C.VkPipelineTessellationDomainOriginStateCreateInfo)(mem58ef29bf)
	allocs58ef29bf := new(cgoAllocMap)
	allocs58ef29bf.Add(mem58ef29bf)

	var csType_allocs *cgoAllocMap
	ref58ef29bf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs58ef29bf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref58ef29bf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs58ef29bf.Borrow(cpNext_allocs)

	var cdomainOrigin_allocs *cgoAllocMap
	ref58ef29bf.domainOrigin, cdomainOrigin_allocs = (C.VkTessellationDomainOrigin)(x.DomainOrigin), cgoAllocsUnknown
	allocs58ef29bf.Borrow(cdomainOrigin_allocs)

	x.ref58ef29bf = ref58ef29bf
	x.allocs58ef29bf = allocs58ef29bf
	return ref58ef29bf, allocs58ef29bf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineTessellationDomainOriginStateCreateInfo) PassValue() (C.VkPipelineTessellationDomainOriginStateCreateInfo, *cgoAllocMap) {
	if x.ref58ef29bf != nil {
		return *x.ref58ef29bf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineTessellationDomainOriginStateCreateInfo) Deref() {
	if x.ref58ef29bf == nil {
		return
	}
	x.SType = (StructureType)(x.ref58ef29bf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref58ef29bf.pNext))
	x.DomainOrigin = (TessellationDomainOrigin)(x.ref58ef29bf.domainOrigin)
}

// allocRenderPassMultiviewCreateInfoMemory allocates memory for type C.VkRenderPassMultiviewCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassMultiviewCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassMultiviewCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderPassMultiviewCreateInfoValue = unsafe.Sizeof([1]C.VkRenderPassMultiviewCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassMultiviewCreateInfo) Ref() *C.VkRenderPassMultiviewCreateInfo {
	if x == nil {
		return nil
	}
	return x.refee413e05
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassMultiviewCreateInfo) Free() {
	if x != nil && x.allocsee413e05 != nil {
		x.allocsee413e05.(*cgoAllocMap).Free()
		x.refee413e05 = nil
	}
}

// NewRenderPassMultiviewCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassMultiviewCreateInfoRef(ref unsafe.Pointer) *RenderPassMultiviewCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassMultiviewCreateInfo)
	obj.refee413e05 = (*C.VkRenderPassMultiviewCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassMultiviewCreateInfo) PassRef() (*C.VkRenderPassMultiviewCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refee413e05 != nil {
		return x.refee413e05, nil
	}
	memee413e05 := allocRenderPassMultiviewCreateInfoMemory(1)
	refee413e05 := (*C.VkRenderPassMultiviewCreateInfo)(memee413e05)
	allocsee413e05 := new(cgoAllocMap)
	allocsee413e05.Add(memee413e05)

	var csType_allocs *cgoAllocMap
	refee413e05.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsee413e05.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refee413e05.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsee413e05.Borrow(cpNext_allocs)

	var csubpassCount_allocs *cgoAllocMap
	refee413e05.subpassCount, csubpassCount_allocs = (C.uint32_t)(x.SubpassCount), cgoAllocsUnknown
	allocsee413e05.Borrow(csubpassCount_allocs)

	var cpViewMasks_allocs *cgoAllocMap
	refee413e05.pViewMasks, cpViewMasks_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PViewMasks)).Data)), cgoAllocsUnknown
	allocsee413e05.Borrow(cpViewMasks_allocs)

	var cdependencyCount_allocs *cgoAllocMap
	refee413e05.dependencyCount, cdependencyCount_allocs = (C.uint32_t)(x.DependencyCount), cgoAllocsUnknown
	allocsee413e05.Borrow(cdependencyCount_allocs)

	var cpViewOffsets_allocs *cgoAllocMap
	refee413e05.pViewOffsets, cpViewOffsets_allocs = (*C.int32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PViewOffsets)).Data)), cgoAllocsUnknown
	allocsee413e05.Borrow(cpViewOffsets_allocs)

	var ccorrelationMaskCount_allocs *cgoAllocMap
	refee413e05.correlationMaskCount, ccorrelationMaskCount_allocs = (C.uint32_t)(x.CorrelationMaskCount), cgoAllocsUnknown
	allocsee413e05.Borrow(ccorrelationMaskCount_allocs)

	var cpCorrelationMasks_allocs *cgoAllocMap
	refee413e05.pCorrelationMasks, cpCorrelationMasks_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCorrelationMasks)).Data)), cgoAllocsUnknown
	allocsee413e05.Borrow(cpCorrelationMasks_allocs)

	x.refee413e05 = refee413e05
	x.allocsee413e05 = allocsee413e05
	return refee413e05, allocsee413e05

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassMultiviewCreateInfo) PassValue() (C.VkRenderPassMultiviewCreateInfo, *cgoAllocMap) {
	if x.refee413e05 != nil {
		return *x.refee413e05, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassMultiviewCreateInfo) Deref() {
	if x.refee413e05 == nil {
		return
	}
	x.SType = (StructureType)(x.refee413e05.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refee413e05.pNext))
	x.SubpassCount = (uint32)(x.refee413e05.subpassCount)
	hxff20e84 := (*sliceHeader)(unsafe.Pointer(&x.PViewMasks))
	hxff20e84.Data = unsafe.Pointer(x.refee413e05.pViewMasks)
	hxff20e84.Cap = 0x7fffffff
	// hxff20e84.Len = ?

	x.DependencyCount = (uint32)(x.refee413e05.dependencyCount)
	hxfa26a4d := (*sliceHeader)(unsafe.Pointer(&x.PViewOffsets))
	hxfa26a4d.Data = unsafe.Pointer(x.refee413e05.pViewOffsets)
	hxfa26a4d.Cap = 0x7fffffff
	// hxfa26a4d.Len = ?

	x.CorrelationMaskCount = (uint32)(x.refee413e05.correlationMaskCount)
	hxfe48098 := (*sliceHeader)(unsafe.Pointer(&x.PCorrelationMasks))
	hxfe48098.Data = unsafe.Pointer(x.refee413e05.pCorrelationMasks)
	hxfe48098.Cap = 0x7fffffff
	// hxfe48098.Len = ?

}

// allocPhysicalDeviceMultiviewFeaturesMemory allocates memory for type C.VkPhysicalDeviceMultiviewFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMultiviewFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMultiviewFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceMultiviewFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMultiviewFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMultiviewFeatures) Ref() *C.VkPhysicalDeviceMultiviewFeatures {
	if x == nil {
		return nil
	}
	return x.refd7a7434b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMultiviewFeatures) Free() {
	if x != nil && x.allocsd7a7434b != nil {
		x.allocsd7a7434b.(*cgoAllocMap).Free()
		x.refd7a7434b = nil
	}
}

// NewPhysicalDeviceMultiviewFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMultiviewFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceMultiviewFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMultiviewFeatures)
	obj.refd7a7434b = (*C.VkPhysicalDeviceMultiviewFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMultiviewFeatures) PassRef() (*C.VkPhysicalDeviceMultiviewFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd7a7434b != nil {
		return x.refd7a7434b, nil
	}
	memd7a7434b := allocPhysicalDeviceMultiviewFeaturesMemory(1)
	refd7a7434b := (*C.VkPhysicalDeviceMultiviewFeatures)(memd7a7434b)
	allocsd7a7434b := new(cgoAllocMap)
	allocsd7a7434b.Add(memd7a7434b)

	var csType_allocs *cgoAllocMap
	refd7a7434b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd7a7434b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd7a7434b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd7a7434b.Borrow(cpNext_allocs)

	var cmultiview_allocs *cgoAllocMap
	refd7a7434b.multiview, cmultiview_allocs = (C.VkBool32)(x.Multiview), cgoAllocsUnknown
	allocsd7a7434b.Borrow(cmultiview_allocs)

	var cmultiviewGeometryShader_allocs *cgoAllocMap
	refd7a7434b.multiviewGeometryShader, cmultiviewGeometryShader_allocs = (C.VkBool32)(x.MultiviewGeometryShader), cgoAllocsUnknown
	allocsd7a7434b.Borrow(cmultiviewGeometryShader_allocs)

	var cmultiviewTessellationShader_allocs *cgoAllocMap
	refd7a7434b.multiviewTessellationShader, cmultiviewTessellationShader_allocs = (C.VkBool32)(x.MultiviewTessellationShader), cgoAllocsUnknown
	allocsd7a7434b.Borrow(cmultiviewTessellationShader_allocs)

	x.refd7a7434b = refd7a7434b
	x.allocsd7a7434b = allocsd7a7434b
	return refd7a7434b, allocsd7a7434b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMultiviewFeatures) PassValue() (C.VkPhysicalDeviceMultiviewFeatures, *cgoAllocMap) {
	if x.refd7a7434b != nil {
		return *x.refd7a7434b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMultiviewFeatures) Deref() {
	if x.refd7a7434b == nil {
		return
	}
	x.SType = (StructureType)(x.refd7a7434b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd7a7434b.pNext))
	x.Multiview = (Bool32)(x.refd7a7434b.multiview)
	x.MultiviewGeometryShader = (Bool32)(x.refd7a7434b.multiviewGeometryShader)
	x.MultiviewTessellationShader = (Bool32)(x.refd7a7434b.multiviewTessellationShader)
}

// allocPhysicalDeviceMultiviewPropertiesMemory allocates memory for type C.VkPhysicalDeviceMultiviewProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMultiviewPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMultiviewPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceMultiviewPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMultiviewProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMultiviewProperties) Ref() *C.VkPhysicalDeviceMultiviewProperties {
	if x == nil {
		return nil
	}
	return x.ref95110029
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMultiviewProperties) Free() {
	if x != nil && x.allocs95110029 != nil {
		x.allocs95110029.(*cgoAllocMap).Free()
		x.ref95110029 = nil
	}
}

// NewPhysicalDeviceMultiviewPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMultiviewPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceMultiviewProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMultiviewProperties)
	obj.ref95110029 = (*C.VkPhysicalDeviceMultiviewProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMultiviewProperties) PassRef() (*C.VkPhysicalDeviceMultiviewProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref95110029 != nil {
		return x.ref95110029, nil
	}
	mem95110029 := allocPhysicalDeviceMultiviewPropertiesMemory(1)
	ref95110029 := (*C.VkPhysicalDeviceMultiviewProperties)(mem95110029)
	allocs95110029 := new(cgoAllocMap)
	allocs95110029.Add(mem95110029)

	var csType_allocs *cgoAllocMap
	ref95110029.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs95110029.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref95110029.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs95110029.Borrow(cpNext_allocs)

	var cmaxMultiviewViewCount_allocs *cgoAllocMap
	ref95110029.maxMultiviewViewCount, cmaxMultiviewViewCount_allocs = (C.uint32_t)(x.MaxMultiviewViewCount), cgoAllocsUnknown
	allocs95110029.Borrow(cmaxMultiviewViewCount_allocs)

	var cmaxMultiviewInstanceIndex_allocs *cgoAllocMap
	ref95110029.maxMultiviewInstanceIndex, cmaxMultiviewInstanceIndex_allocs = (C.uint32_t)(x.MaxMultiviewInstanceIndex), cgoAllocsUnknown
	allocs95110029.Borrow(cmaxMultiviewInstanceIndex_allocs)

	x.ref95110029 = ref95110029
	x.allocs95110029 = allocs95110029
	return ref95110029, allocs95110029

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMultiviewProperties) PassValue() (C.VkPhysicalDeviceMultiviewProperties, *cgoAllocMap) {
	if x.ref95110029 != nil {
		return *x.ref95110029, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMultiviewProperties) Deref() {
	if x.ref95110029 == nil {
		return
	}
	x.SType = (StructureType)(x.ref95110029.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref95110029.pNext))
	x.MaxMultiviewViewCount = (uint32)(x.ref95110029.maxMultiviewViewCount)
	x.MaxMultiviewInstanceIndex = (uint32)(x.ref95110029.maxMultiviewInstanceIndex)
}

// allocPhysicalDeviceVariablePointerFeaturesMemory allocates memory for type C.VkPhysicalDeviceVariablePointerFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceVariablePointerFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceVariablePointerFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceVariablePointerFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceVariablePointerFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVariablePointerFeatures) Ref() *C.VkPhysicalDeviceVariablePointerFeatures {
	if x == nil {
		return nil
	}
	return x.refdedd8372
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVariablePointerFeatures) Free() {
	if x != nil && x.allocsdedd8372 != nil {
		x.allocsdedd8372.(*cgoAllocMap).Free()
		x.refdedd8372 = nil
	}
}

// NewPhysicalDeviceVariablePointerFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVariablePointerFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceVariablePointerFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVariablePointerFeatures)
	obj.refdedd8372 = (*C.VkPhysicalDeviceVariablePointerFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVariablePointerFeatures) PassRef() (*C.VkPhysicalDeviceVariablePointerFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdedd8372 != nil {
		return x.refdedd8372, nil
	}
	memdedd8372 := allocPhysicalDeviceVariablePointerFeaturesMemory(1)
	refdedd8372 := (*C.VkPhysicalDeviceVariablePointerFeatures)(memdedd8372)
	allocsdedd8372 := new(cgoAllocMap)
	allocsdedd8372.Add(memdedd8372)

	var csType_allocs *cgoAllocMap
	refdedd8372.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdedd8372.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdedd8372.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdedd8372.Borrow(cpNext_allocs)

	var cvariablePointersStorageBuffer_allocs *cgoAllocMap
	refdedd8372.variablePointersStorageBuffer, cvariablePointersStorageBuffer_allocs = (C.VkBool32)(x.VariablePointersStorageBuffer), cgoAllocsUnknown
	allocsdedd8372.Borrow(cvariablePointersStorageBuffer_allocs)

	var cvariablePointers_allocs *cgoAllocMap
	refdedd8372.variablePointers, cvariablePointers_allocs = (C.VkBool32)(x.VariablePointers), cgoAllocsUnknown
	allocsdedd8372.Borrow(cvariablePointers_allocs)

	x.refdedd8372 = refdedd8372
	x.allocsdedd8372 = allocsdedd8372
	return refdedd8372, allocsdedd8372

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVariablePointerFeatures) PassValue() (C.VkPhysicalDeviceVariablePointerFeatures, *cgoAllocMap) {
	if x.refdedd8372 != nil {
		return *x.refdedd8372, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVariablePointerFeatures) Deref() {
	if x.refdedd8372 == nil {
		return
	}
	x.SType = (StructureType)(x.refdedd8372.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdedd8372.pNext))
	x.VariablePointersStorageBuffer = (Bool32)(x.refdedd8372.variablePointersStorageBuffer)
	x.VariablePointers = (Bool32)(x.refdedd8372.variablePointers)
}

// allocPhysicalDeviceProtectedMemoryFeaturesMemory allocates memory for type C.VkPhysicalDeviceProtectedMemoryFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceProtectedMemoryFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceProtectedMemoryFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceProtectedMemoryFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceProtectedMemoryFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceProtectedMemoryFeatures) Ref() *C.VkPhysicalDeviceProtectedMemoryFeatures {
	if x == nil {
		return nil
	}
	return x.refac441ed1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceProtectedMemoryFeatures) Free() {
	if x != nil && x.allocsac441ed1 != nil {
		x.allocsac441ed1.(*cgoAllocMap).Free()
		x.refac441ed1 = nil
	}
}

// NewPhysicalDeviceProtectedMemoryFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceProtectedMemoryFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceProtectedMemoryFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProtectedMemoryFeatures)
	obj.refac441ed1 = (*C.VkPhysicalDeviceProtectedMemoryFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceProtectedMemoryFeatures) PassRef() (*C.VkPhysicalDeviceProtectedMemoryFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refac441ed1 != nil {
		return x.refac441ed1, nil
	}
	memac441ed1 := allocPhysicalDeviceProtectedMemoryFeaturesMemory(1)
	refac441ed1 := (*C.VkPhysicalDeviceProtectedMemoryFeatures)(memac441ed1)
	allocsac441ed1 := new(cgoAllocMap)
	allocsac441ed1.Add(memac441ed1)

	var csType_allocs *cgoAllocMap
	refac441ed1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsac441ed1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refac441ed1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsac441ed1.Borrow(cpNext_allocs)

	var cprotectedMemory_allocs *cgoAllocMap
	refac441ed1.protectedMemory, cprotectedMemory_allocs = (C.VkBool32)(x.ProtectedMemory), cgoAllocsUnknown
	allocsac441ed1.Borrow(cprotectedMemory_allocs)

	x.refac441ed1 = refac441ed1
	x.allocsac441ed1 = allocsac441ed1
	return refac441ed1, allocsac441ed1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceProtectedMemoryFeatures) PassValue() (C.VkPhysicalDeviceProtectedMemoryFeatures, *cgoAllocMap) {
	if x.refac441ed1 != nil {
		return *x.refac441ed1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceProtectedMemoryFeatures) Deref() {
	if x.refac441ed1 == nil {
		return
	}
	x.SType = (StructureType)(x.refac441ed1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refac441ed1.pNext))
	x.ProtectedMemory = (Bool32)(x.refac441ed1.protectedMemory)
}

// allocPhysicalDeviceProtectedMemoryPropertiesMemory allocates memory for type C.VkPhysicalDeviceProtectedMemoryProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceProtectedMemoryPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceProtectedMemoryPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceProtectedMemoryPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceProtectedMemoryProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceProtectedMemoryProperties) Ref() *C.VkPhysicalDeviceProtectedMemoryProperties {
	if x == nil {
		return nil
	}
	return x.refb653413
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceProtectedMemoryProperties) Free() {
	if x != nil && x.allocsb653413 != nil {
		x.allocsb653413.(*cgoAllocMap).Free()
		x.refb653413 = nil
	}
}

// NewPhysicalDeviceProtectedMemoryPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceProtectedMemoryPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceProtectedMemoryProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProtectedMemoryProperties)
	obj.refb653413 = (*C.VkPhysicalDeviceProtectedMemoryProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceProtectedMemoryProperties) PassRef() (*C.VkPhysicalDeviceProtectedMemoryProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb653413 != nil {
		return x.refb653413, nil
	}
	memb653413 := allocPhysicalDeviceProtectedMemoryPropertiesMemory(1)
	refb653413 := (*C.VkPhysicalDeviceProtectedMemoryProperties)(memb653413)
	allocsb653413 := new(cgoAllocMap)
	allocsb653413.Add(memb653413)

	var csType_allocs *cgoAllocMap
	refb653413.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb653413.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb653413.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb653413.Borrow(cpNext_allocs)

	var cprotectedNoFault_allocs *cgoAllocMap
	refb653413.protectedNoFault, cprotectedNoFault_allocs = (C.VkBool32)(x.ProtectedNoFault), cgoAllocsUnknown
	allocsb653413.Borrow(cprotectedNoFault_allocs)

	x.refb653413 = refb653413
	x.allocsb653413 = allocsb653413
	return refb653413, allocsb653413

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceProtectedMemoryProperties) PassValue() (C.VkPhysicalDeviceProtectedMemoryProperties, *cgoAllocMap) {
	if x.refb653413 != nil {
		return *x.refb653413, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceProtectedMemoryProperties) Deref() {
	if x.refb653413 == nil {
		return
	}
	x.SType = (StructureType)(x.refb653413.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb653413.pNext))
	x.ProtectedNoFault = (Bool32)(x.refb653413.protectedNoFault)
}

// allocDeviceQueueInfo2Memory allocates memory for type C.VkDeviceQueueInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceQueueInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceQueueInfo2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceQueueInfo2Value = unsafe.Sizeof([1]C.VkDeviceQueueInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceQueueInfo2) Ref() *C.VkDeviceQueueInfo2 {
	if x == nil {
		return nil
	}
	return x.ref2f267e52
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceQueueInfo2) Free() {
	if x != nil && x.allocs2f267e52 != nil {
		x.allocs2f267e52.(*cgoAllocMap).Free()
		x.ref2f267e52 = nil
	}
}

// NewDeviceQueueInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceQueueInfo2Ref(ref unsafe.Pointer) *DeviceQueueInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(DeviceQueueInfo2)
	obj.ref2f267e52 = (*C.VkDeviceQueueInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceQueueInfo2) PassRef() (*C.VkDeviceQueueInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f267e52 != nil {
		return x.ref2f267e52, nil
	}
	mem2f267e52 := allocDeviceQueueInfo2Memory(1)
	ref2f267e52 := (*C.VkDeviceQueueInfo2)(mem2f267e52)
	allocs2f267e52 := new(cgoAllocMap)
	allocs2f267e52.Add(mem2f267e52)

	var csType_allocs *cgoAllocMap
	ref2f267e52.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2f267e52.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2f267e52.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2f267e52.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref2f267e52.flags, cflags_allocs = (C.VkDeviceQueueCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs2f267e52.Borrow(cflags_allocs)

	var cqueueFamilyIndex_allocs *cgoAllocMap
	ref2f267e52.queueFamilyIndex, cqueueFamilyIndex_allocs = (C.uint32_t)(x.QueueFamilyIndex), cgoAllocsUnknown
	allocs2f267e52.Borrow(cqueueFamilyIndex_allocs)

	var cqueueIndex_allocs *cgoAllocMap
	ref2f267e52.queueIndex, cqueueIndex_allocs = (C.uint32_t)(x.QueueIndex), cgoAllocsUnknown
	allocs2f267e52.Borrow(cqueueIndex_allocs)

	x.ref2f267e52 = ref2f267e52
	x.allocs2f267e52 = allocs2f267e52
	return ref2f267e52, allocs2f267e52

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceQueueInfo2) PassValue() (C.VkDeviceQueueInfo2, *cgoAllocMap) {
	if x.ref2f267e52 != nil {
		return *x.ref2f267e52, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceQueueInfo2) Deref() {
	if x.ref2f267e52 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2f267e52.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2f267e52.pNext))
	x.Flags = (DeviceQueueCreateFlags)(x.ref2f267e52.flags)
	x.QueueFamilyIndex = (uint32)(x.ref2f267e52.queueFamilyIndex)
	x.QueueIndex = (uint32)(x.ref2f267e52.queueIndex)
}

// allocProtectedSubmitInfoMemory allocates memory for type C.VkProtectedSubmitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocProtectedSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfProtectedSubmitInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfProtectedSubmitInfoValue = unsafe.Sizeof([1]C.VkProtectedSubmitInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ProtectedSubmitInfo) Ref() *C.VkProtectedSubmitInfo {
	if x == nil {
		return nil
	}
	return x.ref6bd69669
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ProtectedSubmitInfo) Free() {
	if x != nil && x.allocs6bd69669 != nil {
		x.allocs6bd69669.(*cgoAllocMap).Free()
		x.ref6bd69669 = nil
	}
}

// NewProtectedSubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewProtectedSubmitInfoRef(ref unsafe.Pointer) *ProtectedSubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(ProtectedSubmitInfo)
	obj.ref6bd69669 = (*C.VkProtectedSubmitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ProtectedSubmitInfo) PassRef() (*C.VkProtectedSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6bd69669 != nil {
		return x.ref6bd69669, nil
	}
	mem6bd69669 := allocProtectedSubmitInfoMemory(1)
	ref6bd69669 := (*C.VkProtectedSubmitInfo)(mem6bd69669)
	allocs6bd69669 := new(cgoAllocMap)
	allocs6bd69669.Add(mem6bd69669)

	var csType_allocs *cgoAllocMap
	ref6bd69669.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6bd69669.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6bd69669.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6bd69669.Borrow(cpNext_allocs)

	var cprotectedSubmit_allocs *cgoAllocMap
	ref6bd69669.protectedSubmit, cprotectedSubmit_allocs = (C.VkBool32)(x.ProtectedSubmit), cgoAllocsUnknown
	allocs6bd69669.Borrow(cprotectedSubmit_allocs)

	x.ref6bd69669 = ref6bd69669
	x.allocs6bd69669 = allocs6bd69669
	return ref6bd69669, allocs6bd69669

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ProtectedSubmitInfo) PassValue() (C.VkProtectedSubmitInfo, *cgoAllocMap) {
	if x.ref6bd69669 != nil {
		return *x.ref6bd69669, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ProtectedSubmitInfo) Deref() {
	if x.ref6bd69669 == nil {
		return
	}
	x.SType = (StructureType)(x.ref6bd69669.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6bd69669.pNext))
	x.ProtectedSubmit = (Bool32)(x.ref6bd69669.protectedSubmit)
}

// allocSamplerYcbcrConversionCreateInfoMemory allocates memory for type C.VkSamplerYcbcrConversionCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerYcbcrConversionCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerYcbcrConversionCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSamplerYcbcrConversionCreateInfoValue = unsafe.Sizeof([1]C.VkSamplerYcbcrConversionCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerYcbcrConversionCreateInfo) Ref() *C.VkSamplerYcbcrConversionCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref9875bff7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerYcbcrConversionCreateInfo) Free() {
	if x != nil && x.allocs9875bff7 != nil {
		x.allocs9875bff7.(*cgoAllocMap).Free()
		x.ref9875bff7 = nil
	}
}

// NewSamplerYcbcrConversionCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerYcbcrConversionCreateInfoRef(ref unsafe.Pointer) *SamplerYcbcrConversionCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SamplerYcbcrConversionCreateInfo)
	obj.ref9875bff7 = (*C.VkSamplerYcbcrConversionCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerYcbcrConversionCreateInfo) PassRef() (*C.VkSamplerYcbcrConversionCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9875bff7 != nil {
		return x.ref9875bff7, nil
	}
	mem9875bff7 := allocSamplerYcbcrConversionCreateInfoMemory(1)
	ref9875bff7 := (*C.VkSamplerYcbcrConversionCreateInfo)(mem9875bff7)
	allocs9875bff7 := new(cgoAllocMap)
	allocs9875bff7.Add(mem9875bff7)

	var csType_allocs *cgoAllocMap
	ref9875bff7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9875bff7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9875bff7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9875bff7.Borrow(cpNext_allocs)

	var cformat_allocs *cgoAllocMap
	ref9875bff7.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocs9875bff7.Borrow(cformat_allocs)

	var cycbcrModel_allocs *cgoAllocMap
	ref9875bff7.ycbcrModel, cycbcrModel_allocs = (C.VkSamplerYcbcrModelConversion)(x.YcbcrModel), cgoAllocsUnknown
	allocs9875bff7.Borrow(cycbcrModel_allocs)

	var cycbcrRange_allocs *cgoAllocMap
	ref9875bff7.ycbcrRange, cycbcrRange_allocs = (C.VkSamplerYcbcrRange)(x.YcbcrRange), cgoAllocsUnknown
	allocs9875bff7.Borrow(cycbcrRange_allocs)

	var ccomponents_allocs *cgoAllocMap
	ref9875bff7.components, ccomponents_allocs = x.Components.PassValue()
	allocs9875bff7.Borrow(ccomponents_allocs)

	var cxChromaOffset_allocs *cgoAllocMap
	ref9875bff7.xChromaOffset, cxChromaOffset_allocs = (C.VkChromaLocation)(x.XChromaOffset), cgoAllocsUnknown
	allocs9875bff7.Borrow(cxChromaOffset_allocs)

	var cyChromaOffset_allocs *cgoAllocMap
	ref9875bff7.yChromaOffset, cyChromaOffset_allocs = (C.VkChromaLocation)(x.YChromaOffset), cgoAllocsUnknown
	allocs9875bff7.Borrow(cyChromaOffset_allocs)

	var cchromaFilter_allocs *cgoAllocMap
	ref9875bff7.chromaFilter, cchromaFilter_allocs = (C.VkFilter)(x.ChromaFilter), cgoAllocsUnknown
	allocs9875bff7.Borrow(cchromaFilter_allocs)

	var cforceExplicitReconstruction_allocs *cgoAllocMap
	ref9875bff7.forceExplicitReconstruction, cforceExplicitReconstruction_allocs = (C.VkBool32)(x.ForceExplicitReconstruction), cgoAllocsUnknown
	allocs9875bff7.Borrow(cforceExplicitReconstruction_allocs)

	x.ref9875bff7 = ref9875bff7
	x.allocs9875bff7 = allocs9875bff7
	return ref9875bff7, allocs9875bff7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerYcbcrConversionCreateInfo) PassValue() (C.VkSamplerYcbcrConversionCreateInfo, *cgoAllocMap) {
	if x.ref9875bff7 != nil {
		return *x.ref9875bff7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerYcbcrConversionCreateInfo) Deref() {
	if x.ref9875bff7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9875bff7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9875bff7.pNext))
	x.Format = (Format)(x.ref9875bff7.format)
	x.YcbcrModel = (SamplerYcbcrModelConversion)(x.ref9875bff7.ycbcrModel)
	x.YcbcrRange = (SamplerYcbcrRange)(x.ref9875bff7.ycbcrRange)
	x.Components = *NewComponentMappingRef(unsafe.Pointer(&x.ref9875bff7.components))
	x.XChromaOffset = (ChromaLocation)(x.ref9875bff7.xChromaOffset)
	x.YChromaOffset = (ChromaLocation)(x.ref9875bff7.yChromaOffset)
	x.ChromaFilter = (Filter)(x.ref9875bff7.chromaFilter)
	x.ForceExplicitReconstruction = (Bool32)(x.ref9875bff7.forceExplicitReconstruction)
}

// allocSamplerYcbcrConversionInfoMemory allocates memory for type C.VkSamplerYcbcrConversionInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerYcbcrConversionInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerYcbcrConversionInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSamplerYcbcrConversionInfoValue = unsafe.Sizeof([1]C.VkSamplerYcbcrConversionInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerYcbcrConversionInfo) Ref() *C.VkSamplerYcbcrConversionInfo {
	if x == nil {
		return nil
	}
	return x.ref11ff5547
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerYcbcrConversionInfo) Free() {
	if x != nil && x.allocs11ff5547 != nil {
		x.allocs11ff5547.(*cgoAllocMap).Free()
		x.ref11ff5547 = nil
	}
}

// NewSamplerYcbcrConversionInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerYcbcrConversionInfoRef(ref unsafe.Pointer) *SamplerYcbcrConversionInfo {
	if ref == nil {
		return nil
	}
	obj := new(SamplerYcbcrConversionInfo)
	obj.ref11ff5547 = (*C.VkSamplerYcbcrConversionInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerYcbcrConversionInfo) PassRef() (*C.VkSamplerYcbcrConversionInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref11ff5547 != nil {
		return x.ref11ff5547, nil
	}
	mem11ff5547 := allocSamplerYcbcrConversionInfoMemory(1)
	ref11ff5547 := (*C.VkSamplerYcbcrConversionInfo)(mem11ff5547)
	allocs11ff5547 := new(cgoAllocMap)
	allocs11ff5547.Add(mem11ff5547)

	var csType_allocs *cgoAllocMap
	ref11ff5547.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs11ff5547.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref11ff5547.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs11ff5547.Borrow(cpNext_allocs)

	var cconversion_allocs *cgoAllocMap
	ref11ff5547.conversion, cconversion_allocs = *(*C.VkSamplerYcbcrConversion)(unsafe.Pointer(&x.Conversion)), cgoAllocsUnknown
	allocs11ff5547.Borrow(cconversion_allocs)

	x.ref11ff5547 = ref11ff5547
	x.allocs11ff5547 = allocs11ff5547
	return ref11ff5547, allocs11ff5547

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerYcbcrConversionInfo) PassValue() (C.VkSamplerYcbcrConversionInfo, *cgoAllocMap) {
	if x.ref11ff5547 != nil {
		return *x.ref11ff5547, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerYcbcrConversionInfo) Deref() {
	if x.ref11ff5547 == nil {
		return
	}
	x.SType = (StructureType)(x.ref11ff5547.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref11ff5547.pNext))
	x.Conversion = *(*SamplerYcbcrConversion)(unsafe.Pointer(&x.ref11ff5547.conversion))
}

// allocBindImagePlaneMemoryInfoMemory allocates memory for type C.VkBindImagePlaneMemoryInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindImagePlaneMemoryInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindImagePlaneMemoryInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindImagePlaneMemoryInfoValue = unsafe.Sizeof([1]C.VkBindImagePlaneMemoryInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImagePlaneMemoryInfo) Ref() *C.VkBindImagePlaneMemoryInfo {
	if x == nil {
		return nil
	}
	return x.ref56b81476
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImagePlaneMemoryInfo) Free() {
	if x != nil && x.allocs56b81476 != nil {
		x.allocs56b81476.(*cgoAllocMap).Free()
		x.ref56b81476 = nil
	}
}

// NewBindImagePlaneMemoryInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImagePlaneMemoryInfoRef(ref unsafe.Pointer) *BindImagePlaneMemoryInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindImagePlaneMemoryInfo)
	obj.ref56b81476 = (*C.VkBindImagePlaneMemoryInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImagePlaneMemoryInfo) PassRef() (*C.VkBindImagePlaneMemoryInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref56b81476 != nil {
		return x.ref56b81476, nil
	}
	mem56b81476 := allocBindImagePlaneMemoryInfoMemory(1)
	ref56b81476 := (*C.VkBindImagePlaneMemoryInfo)(mem56b81476)
	allocs56b81476 := new(cgoAllocMap)
	allocs56b81476.Add(mem56b81476)

	var csType_allocs *cgoAllocMap
	ref56b81476.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs56b81476.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref56b81476.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs56b81476.Borrow(cpNext_allocs)

	var cplaneAspect_allocs *cgoAllocMap
	ref56b81476.planeAspect, cplaneAspect_allocs = (C.VkImageAspectFlagBits)(x.PlaneAspect), cgoAllocsUnknown
	allocs56b81476.Borrow(cplaneAspect_allocs)

	x.ref56b81476 = ref56b81476
	x.allocs56b81476 = allocs56b81476
	return ref56b81476, allocs56b81476

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImagePlaneMemoryInfo) PassValue() (C.VkBindImagePlaneMemoryInfo, *cgoAllocMap) {
	if x.ref56b81476 != nil {
		return *x.ref56b81476, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImagePlaneMemoryInfo) Deref() {
	if x.ref56b81476 == nil {
		return
	}
	x.SType = (StructureType)(x.ref56b81476.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref56b81476.pNext))
	x.PlaneAspect = (ImageAspectFlagBits)(x.ref56b81476.planeAspect)
}

// allocImagePlaneMemoryRequirementsInfoMemory allocates memory for type C.VkImagePlaneMemoryRequirementsInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImagePlaneMemoryRequirementsInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImagePlaneMemoryRequirementsInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImagePlaneMemoryRequirementsInfoValue = unsafe.Sizeof([1]C.VkImagePlaneMemoryRequirementsInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImagePlaneMemoryRequirementsInfo) Ref() *C.VkImagePlaneMemoryRequirementsInfo {
	if x == nil {
		return nil
	}
	return x.refefec131f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImagePlaneMemoryRequirementsInfo) Free() {
	if x != nil && x.allocsefec131f != nil {
		x.allocsefec131f.(*cgoAllocMap).Free()
		x.refefec131f = nil
	}
}

// NewImagePlaneMemoryRequirementsInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImagePlaneMemoryRequirementsInfoRef(ref unsafe.Pointer) *ImagePlaneMemoryRequirementsInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImagePlaneMemoryRequirementsInfo)
	obj.refefec131f = (*C.VkImagePlaneMemoryRequirementsInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImagePlaneMemoryRequirementsInfo) PassRef() (*C.VkImagePlaneMemoryRequirementsInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refefec131f != nil {
		return x.refefec131f, nil
	}
	memefec131f := allocImagePlaneMemoryRequirementsInfoMemory(1)
	refefec131f := (*C.VkImagePlaneMemoryRequirementsInfo)(memefec131f)
	allocsefec131f := new(cgoAllocMap)
	allocsefec131f.Add(memefec131f)

	var csType_allocs *cgoAllocMap
	refefec131f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsefec131f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refefec131f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsefec131f.Borrow(cpNext_allocs)

	var cplaneAspect_allocs *cgoAllocMap
	refefec131f.planeAspect, cplaneAspect_allocs = (C.VkImageAspectFlagBits)(x.PlaneAspect), cgoAllocsUnknown
	allocsefec131f.Borrow(cplaneAspect_allocs)

	x.refefec131f = refefec131f
	x.allocsefec131f = allocsefec131f
	return refefec131f, allocsefec131f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImagePlaneMemoryRequirementsInfo) PassValue() (C.VkImagePlaneMemoryRequirementsInfo, *cgoAllocMap) {
	if x.refefec131f != nil {
		return *x.refefec131f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImagePlaneMemoryRequirementsInfo) Deref() {
	if x.refefec131f == nil {
		return
	}
	x.SType = (StructureType)(x.refefec131f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refefec131f.pNext))
	x.PlaneAspect = (ImageAspectFlagBits)(x.refefec131f.planeAspect)
}

// allocPhysicalDeviceSamplerYcbcrConversionFeaturesMemory allocates memory for type C.VkPhysicalDeviceSamplerYcbcrConversionFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSamplerYcbcrConversionFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSamplerYcbcrConversionFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceSamplerYcbcrConversionFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSamplerYcbcrConversionFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) Ref() *C.VkPhysicalDeviceSamplerYcbcrConversionFeatures {
	if x == nil {
		return nil
	}
	return x.ref1d054d67
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) Free() {
	if x != nil && x.allocs1d054d67 != nil {
		x.allocs1d054d67.(*cgoAllocMap).Free()
		x.ref1d054d67 = nil
	}
}

// NewPhysicalDeviceSamplerYcbcrConversionFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSamplerYcbcrConversionFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceSamplerYcbcrConversionFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSamplerYcbcrConversionFeatures)
	obj.ref1d054d67 = (*C.VkPhysicalDeviceSamplerYcbcrConversionFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) PassRef() (*C.VkPhysicalDeviceSamplerYcbcrConversionFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d054d67 != nil {
		return x.ref1d054d67, nil
	}
	mem1d054d67 := allocPhysicalDeviceSamplerYcbcrConversionFeaturesMemory(1)
	ref1d054d67 := (*C.VkPhysicalDeviceSamplerYcbcrConversionFeatures)(mem1d054d67)
	allocs1d054d67 := new(cgoAllocMap)
	allocs1d054d67.Add(mem1d054d67)

	var csType_allocs *cgoAllocMap
	ref1d054d67.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1d054d67.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1d054d67.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1d054d67.Borrow(cpNext_allocs)

	var csamplerYcbcrConversion_allocs *cgoAllocMap
	ref1d054d67.samplerYcbcrConversion, csamplerYcbcrConversion_allocs = (C.VkBool32)(x.SamplerYcbcrConversion), cgoAllocsUnknown
	allocs1d054d67.Borrow(csamplerYcbcrConversion_allocs)

	x.ref1d054d67 = ref1d054d67
	x.allocs1d054d67 = allocs1d054d67
	return ref1d054d67, allocs1d054d67

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSamplerYcbcrConversionFeatures) PassValue() (C.VkPhysicalDeviceSamplerYcbcrConversionFeatures, *cgoAllocMap) {
	if x.ref1d054d67 != nil {
		return *x.ref1d054d67, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSamplerYcbcrConversionFeatures) Deref() {
	if x.ref1d054d67 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1d054d67.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1d054d67.pNext))
	x.SamplerYcbcrConversion = (Bool32)(x.ref1d054d67.samplerYcbcrConversion)
}

// allocSamplerYcbcrConversionImageFormatPropertiesMemory allocates memory for type C.VkSamplerYcbcrConversionImageFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerYcbcrConversionImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerYcbcrConversionImageFormatPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSamplerYcbcrConversionImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkSamplerYcbcrConversionImageFormatProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerYcbcrConversionImageFormatProperties) Ref() *C.VkSamplerYcbcrConversionImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.ref6bc79530
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerYcbcrConversionImageFormatProperties) Free() {
	if x != nil && x.allocs6bc79530 != nil {
		x.allocs6bc79530.(*cgoAllocMap).Free()
		x.ref6bc79530 = nil
	}
}

// NewSamplerYcbcrConversionImageFormatPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerYcbcrConversionImageFormatPropertiesRef(ref unsafe.Pointer) *SamplerYcbcrConversionImageFormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(SamplerYcbcrConversionImageFormatProperties)
	obj.ref6bc79530 = (*C.VkSamplerYcbcrConversionImageFormatProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerYcbcrConversionImageFormatProperties) PassRef() (*C.VkSamplerYcbcrConversionImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6bc79530 != nil {
		return x.ref6bc79530, nil
	}
	mem6bc79530 := allocSamplerYcbcrConversionImageFormatPropertiesMemory(1)
	ref6bc79530 := (*C.VkSamplerYcbcrConversionImageFormatProperties)(mem6bc79530)
	allocs6bc79530 := new(cgoAllocMap)
	allocs6bc79530.Add(mem6bc79530)

	var csType_allocs *cgoAllocMap
	ref6bc79530.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6bc79530.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6bc79530.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6bc79530.Borrow(cpNext_allocs)

	var ccombinedImageSamplerDescriptorCount_allocs *cgoAllocMap
	ref6bc79530.combinedImageSamplerDescriptorCount, ccombinedImageSamplerDescriptorCount_allocs = (C.uint32_t)(x.CombinedImageSamplerDescriptorCount), cgoAllocsUnknown
	allocs6bc79530.Borrow(ccombinedImageSamplerDescriptorCount_allocs)

	x.ref6bc79530 = ref6bc79530
	x.allocs6bc79530 = allocs6bc79530
	return ref6bc79530, allocs6bc79530

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerYcbcrConversionImageFormatProperties) PassValue() (C.VkSamplerYcbcrConversionImageFormatProperties, *cgoAllocMap) {
	if x.ref6bc79530 != nil {
		return *x.ref6bc79530, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerYcbcrConversionImageFormatProperties) Deref() {
	if x.ref6bc79530 == nil {
		return
	}
	x.SType = (StructureType)(x.ref6bc79530.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6bc79530.pNext))
	x.CombinedImageSamplerDescriptorCount = (uint32)(x.ref6bc79530.combinedImageSamplerDescriptorCount)
}

// allocDescriptorUpdateTemplateEntryMemory allocates memory for type C.VkDescriptorUpdateTemplateEntry in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorUpdateTemplateEntryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorUpdateTemplateEntryValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorUpdateTemplateEntryValue = unsafe.Sizeof([1]C.VkDescriptorUpdateTemplateEntry{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorUpdateTemplateEntry) Ref() *C.VkDescriptorUpdateTemplateEntry {
	if x == nil {
		return nil
	}
	return x.refabf78fb7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorUpdateTemplateEntry) Free() {
	if x != nil && x.allocsabf78fb7 != nil {
		x.allocsabf78fb7.(*cgoAllocMap).Free()
		x.refabf78fb7 = nil
	}
}

// NewDescriptorUpdateTemplateEntryRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorUpdateTemplateEntryRef(ref unsafe.Pointer) *DescriptorUpdateTemplateEntry {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorUpdateTemplateEntry)
	obj.refabf78fb7 = (*C.VkDescriptorUpdateTemplateEntry)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorUpdateTemplateEntry) PassRef() (*C.VkDescriptorUpdateTemplateEntry, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refabf78fb7 != nil {
		return x.refabf78fb7, nil
	}
	memabf78fb7 := allocDescriptorUpdateTemplateEntryMemory(1)
	refabf78fb7 := (*C.VkDescriptorUpdateTemplateEntry)(memabf78fb7)
	allocsabf78fb7 := new(cgoAllocMap)
	allocsabf78fb7.Add(memabf78fb7)

	var cdstBinding_allocs *cgoAllocMap
	refabf78fb7.dstBinding, cdstBinding_allocs = (C.uint32_t)(x.DstBinding), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cdstBinding_allocs)

	var cdstArrayElement_allocs *cgoAllocMap
	refabf78fb7.dstArrayElement, cdstArrayElement_allocs = (C.uint32_t)(x.DstArrayElement), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cdstArrayElement_allocs)

	var cdescriptorCount_allocs *cgoAllocMap
	refabf78fb7.descriptorCount, cdescriptorCount_allocs = (C.uint32_t)(x.DescriptorCount), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cdescriptorCount_allocs)

	var cdescriptorType_allocs *cgoAllocMap
	refabf78fb7.descriptorType, cdescriptorType_allocs = (C.VkDescriptorType)(x.DescriptorType), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cdescriptorType_allocs)

	var coffset_allocs *cgoAllocMap
	refabf78fb7.offset, coffset_allocs = (C.size_t)(x.Offset), cgoAllocsUnknown
	allocsabf78fb7.Borrow(coffset_allocs)

	var cstride_allocs *cgoAllocMap
	refabf78fb7.stride, cstride_allocs = (C.size_t)(x.Stride), cgoAllocsUnknown
	allocsabf78fb7.Borrow(cstride_allocs)

	x.refabf78fb7 = refabf78fb7
	x.allocsabf78fb7 = allocsabf78fb7
	return refabf78fb7, allocsabf78fb7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorUpdateTemplateEntry) PassValue() (C.VkDescriptorUpdateTemplateEntry, *cgoAllocMap) {
	if x.refabf78fb7 != nil {
		return *x.refabf78fb7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorUpdateTemplateEntry) Deref() {
	if x.refabf78fb7 == nil {
		return
	}
	x.DstBinding = (uint32)(x.refabf78fb7.dstBinding)
	x.DstArrayElement = (uint32)(x.refabf78fb7.dstArrayElement)
	x.DescriptorCount = (uint32)(x.refabf78fb7.descriptorCount)
	x.DescriptorType = (DescriptorType)(x.refabf78fb7.descriptorType)
	x.Offset = (uint64)(x.refabf78fb7.offset)
	x.Stride = (uint64)(x.refabf78fb7.stride)
}

// allocDescriptorUpdateTemplateCreateInfoMemory allocates memory for type C.VkDescriptorUpdateTemplateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorUpdateTemplateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorUpdateTemplateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorUpdateTemplateCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorUpdateTemplateCreateInfo{})

// unpackSDescriptorUpdateTemplateEntry transforms a sliced Go data structure into plain C format.
func unpackSDescriptorUpdateTemplateEntry(x []DescriptorUpdateTemplateEntry) (unpacked *C.VkDescriptorUpdateTemplateEntry, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDescriptorUpdateTemplateEntry) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorUpdateTemplateEntryMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorUpdateTemplateEntry)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorUpdateTemplateEntry)(h.Data)
	return
}

// packSDescriptorUpdateTemplateEntry reads sliced Go data structure out from plain C format.
func packSDescriptorUpdateTemplateEntry(v []DescriptorUpdateTemplateEntry, ptr0 *C.VkDescriptorUpdateTemplateEntry) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorUpdateTemplateEntryValue]C.VkDescriptorUpdateTemplateEntry)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorUpdateTemplateEntryRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorUpdateTemplateCreateInfo) Ref() *C.VkDescriptorUpdateTemplateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref2af95951
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorUpdateTemplateCreateInfo) Free() {
	if x != nil && x.allocs2af95951 != nil {
		x.allocs2af95951.(*cgoAllocMap).Free()
		x.ref2af95951 = nil
	}
}

// NewDescriptorUpdateTemplateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorUpdateTemplateCreateInfoRef(ref unsafe.Pointer) *DescriptorUpdateTemplateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorUpdateTemplateCreateInfo)
	obj.ref2af95951 = (*C.VkDescriptorUpdateTemplateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorUpdateTemplateCreateInfo) PassRef() (*C.VkDescriptorUpdateTemplateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2af95951 != nil {
		return x.ref2af95951, nil
	}
	mem2af95951 := allocDescriptorUpdateTemplateCreateInfoMemory(1)
	ref2af95951 := (*C.VkDescriptorUpdateTemplateCreateInfo)(mem2af95951)
	allocs2af95951 := new(cgoAllocMap)
	allocs2af95951.Add(mem2af95951)

	var csType_allocs *cgoAllocMap
	ref2af95951.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2af95951.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2af95951.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2af95951.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref2af95951.flags, cflags_allocs = (C.VkDescriptorUpdateTemplateCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs2af95951.Borrow(cflags_allocs)

	var cdescriptorUpdateEntryCount_allocs *cgoAllocMap
	ref2af95951.descriptorUpdateEntryCount, cdescriptorUpdateEntryCount_allocs = (C.uint32_t)(x.DescriptorUpdateEntryCount), cgoAllocsUnknown
	allocs2af95951.Borrow(cdescriptorUpdateEntryCount_allocs)

	var cpDescriptorUpdateEntries_allocs *cgoAllocMap
	ref2af95951.pDescriptorUpdateEntries, cpDescriptorUpdateEntries_allocs = unpackSDescriptorUpdateTemplateEntry(x.PDescriptorUpdateEntries)
	allocs2af95951.Borrow(cpDescriptorUpdateEntries_allocs)

	var ctemplateType_allocs *cgoAllocMap
	ref2af95951.templateType, ctemplateType_allocs = (C.VkDescriptorUpdateTemplateType)(x.TemplateType), cgoAllocsUnknown
	allocs2af95951.Borrow(ctemplateType_allocs)

	var cdescriptorSetLayout_allocs *cgoAllocMap
	ref2af95951.descriptorSetLayout, cdescriptorSetLayout_allocs = *(*C.VkDescriptorSetLayout)(unsafe.Pointer(&x.DescriptorSetLayout)), cgoAllocsUnknown
	allocs2af95951.Borrow(cdescriptorSetLayout_allocs)

	var cpipelineBindPoint_allocs *cgoAllocMap
	ref2af95951.pipelineBindPoint, cpipelineBindPoint_allocs = (C.VkPipelineBindPoint)(x.PipelineBindPoint), cgoAllocsUnknown
	allocs2af95951.Borrow(cpipelineBindPoint_allocs)

	var cpipelineLayout_allocs *cgoAllocMap
	ref2af95951.pipelineLayout, cpipelineLayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.PipelineLayout)), cgoAllocsUnknown
	allocs2af95951.Borrow(cpipelineLayout_allocs)

	var cset_allocs *cgoAllocMap
	ref2af95951.set, cset_allocs = (C.uint32_t)(x.Set), cgoAllocsUnknown
	allocs2af95951.Borrow(cset_allocs)

	x.ref2af95951 = ref2af95951
	x.allocs2af95951 = allocs2af95951
	return ref2af95951, allocs2af95951

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorUpdateTemplateCreateInfo) PassValue() (C.VkDescriptorUpdateTemplateCreateInfo, *cgoAllocMap) {
	if x.ref2af95951 != nil {
		return *x.ref2af95951, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorUpdateTemplateCreateInfo) Deref() {
	if x.ref2af95951 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2af95951.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2af95951.pNext))
	x.Flags = (DescriptorUpdateTemplateCreateFlags)(x.ref2af95951.flags)
	x.DescriptorUpdateEntryCount = (uint32)(x.ref2af95951.descriptorUpdateEntryCount)
	packSDescriptorUpdateTemplateEntry(x.PDescriptorUpdateEntries, x.ref2af95951.pDescriptorUpdateEntries)
	x.TemplateType = (DescriptorUpdateTemplateType)(x.ref2af95951.templateType)
	x.DescriptorSetLayout = *(*DescriptorSetLayout)(unsafe.Pointer(&x.ref2af95951.descriptorSetLayout))
	x.PipelineBindPoint = (PipelineBindPoint)(x.ref2af95951.pipelineBindPoint)
	x.PipelineLayout = *(*PipelineLayout)(unsafe.Pointer(&x.ref2af95951.pipelineLayout))
	x.Set = (uint32)(x.ref2af95951.set)
}

// allocExternalMemoryPropertiesMemory allocates memory for type C.VkExternalMemoryProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalMemoryPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalMemoryPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalMemoryPropertiesValue = unsafe.Sizeof([1]C.VkExternalMemoryProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalMemoryProperties) Ref() *C.VkExternalMemoryProperties {
	if x == nil {
		return nil
	}
	return x.ref4b738f01
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalMemoryProperties) Free() {
	if x != nil && x.allocs4b738f01 != nil {
		x.allocs4b738f01.(*cgoAllocMap).Free()
		x.ref4b738f01 = nil
	}
}

// NewExternalMemoryPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalMemoryPropertiesRef(ref unsafe.Pointer) *ExternalMemoryProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExternalMemoryProperties)
	obj.ref4b738f01 = (*C.VkExternalMemoryProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalMemoryProperties) PassRef() (*C.VkExternalMemoryProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b738f01 != nil {
		return x.ref4b738f01, nil
	}
	mem4b738f01 := allocExternalMemoryPropertiesMemory(1)
	ref4b738f01 := (*C.VkExternalMemoryProperties)(mem4b738f01)
	allocs4b738f01 := new(cgoAllocMap)
	allocs4b738f01.Add(mem4b738f01)

	var cexternalMemoryFeatures_allocs *cgoAllocMap
	ref4b738f01.externalMemoryFeatures, cexternalMemoryFeatures_allocs = (C.VkExternalMemoryFeatureFlags)(x.ExternalMemoryFeatures), cgoAllocsUnknown
	allocs4b738f01.Borrow(cexternalMemoryFeatures_allocs)

	var cexportFromImportedHandleTypes_allocs *cgoAllocMap
	ref4b738f01.exportFromImportedHandleTypes, cexportFromImportedHandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.ExportFromImportedHandleTypes), cgoAllocsUnknown
	allocs4b738f01.Borrow(cexportFromImportedHandleTypes_allocs)

	var ccompatibleHandleTypes_allocs *cgoAllocMap
	ref4b738f01.compatibleHandleTypes, ccompatibleHandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.CompatibleHandleTypes), cgoAllocsUnknown
	allocs4b738f01.Borrow(ccompatibleHandleTypes_allocs)

	x.ref4b738f01 = ref4b738f01
	x.allocs4b738f01 = allocs4b738f01
	return ref4b738f01, allocs4b738f01

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalMemoryProperties) PassValue() (C.VkExternalMemoryProperties, *cgoAllocMap) {
	if x.ref4b738f01 != nil {
		return *x.ref4b738f01, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalMemoryProperties) Deref() {
	if x.ref4b738f01 == nil {
		return
	}
	x.ExternalMemoryFeatures = (ExternalMemoryFeatureFlags)(x.ref4b738f01.externalMemoryFeatures)
	x.ExportFromImportedHandleTypes = (ExternalMemoryHandleTypeFlags)(x.ref4b738f01.exportFromImportedHandleTypes)
	x.CompatibleHandleTypes = (ExternalMemoryHandleTypeFlags)(x.ref4b738f01.compatibleHandleTypes)
}

// allocPhysicalDeviceExternalImageFormatInfoMemory allocates memory for type C.VkPhysicalDeviceExternalImageFormatInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExternalImageFormatInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExternalImageFormatInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceExternalImageFormatInfoValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExternalImageFormatInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalImageFormatInfo) Ref() *C.VkPhysicalDeviceExternalImageFormatInfo {
	if x == nil {
		return nil
	}
	return x.refc839c724
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalImageFormatInfo) Free() {
	if x != nil && x.allocsc839c724 != nil {
		x.allocsc839c724.(*cgoAllocMap).Free()
		x.refc839c724 = nil
	}
}

// NewPhysicalDeviceExternalImageFormatInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalImageFormatInfoRef(ref unsafe.Pointer) *PhysicalDeviceExternalImageFormatInfo {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalImageFormatInfo)
	obj.refc839c724 = (*C.VkPhysicalDeviceExternalImageFormatInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalImageFormatInfo) PassRef() (*C.VkPhysicalDeviceExternalImageFormatInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc839c724 != nil {
		return x.refc839c724, nil
	}
	memc839c724 := allocPhysicalDeviceExternalImageFormatInfoMemory(1)
	refc839c724 := (*C.VkPhysicalDeviceExternalImageFormatInfo)(memc839c724)
	allocsc839c724 := new(cgoAllocMap)
	allocsc839c724.Add(memc839c724)

	var csType_allocs *cgoAllocMap
	refc839c724.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc839c724.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc839c724.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc839c724.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	refc839c724.handleType, chandleType_allocs = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocsc839c724.Borrow(chandleType_allocs)

	x.refc839c724 = refc839c724
	x.allocsc839c724 = allocsc839c724
	return refc839c724, allocsc839c724

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalImageFormatInfo) PassValue() (C.VkPhysicalDeviceExternalImageFormatInfo, *cgoAllocMap) {
	if x.refc839c724 != nil {
		return *x.refc839c724, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalImageFormatInfo) Deref() {
	if x.refc839c724 == nil {
		return
	}
	x.SType = (StructureType)(x.refc839c724.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc839c724.pNext))
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.refc839c724.handleType)
}

// allocExternalImageFormatPropertiesMemory allocates memory for type C.VkExternalImageFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalImageFormatPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkExternalImageFormatProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalImageFormatProperties) Ref() *C.VkExternalImageFormatProperties {
	if x == nil {
		return nil
	}
	return x.refd404c4b5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalImageFormatProperties) Free() {
	if x != nil && x.allocsd404c4b5 != nil {
		x.allocsd404c4b5.(*cgoAllocMap).Free()
		x.refd404c4b5 = nil
	}
}

// NewExternalImageFormatPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalImageFormatPropertiesRef(ref unsafe.Pointer) *ExternalImageFormatProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExternalImageFormatProperties)
	obj.refd404c4b5 = (*C.VkExternalImageFormatProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalImageFormatProperties) PassRef() (*C.VkExternalImageFormatProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd404c4b5 != nil {
		return x.refd404c4b5, nil
	}
	memd404c4b5 := allocExternalImageFormatPropertiesMemory(1)
	refd404c4b5 := (*C.VkExternalImageFormatProperties)(memd404c4b5)
	allocsd404c4b5 := new(cgoAllocMap)
	allocsd404c4b5.Add(memd404c4b5)

	var csType_allocs *cgoAllocMap
	refd404c4b5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd404c4b5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd404c4b5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd404c4b5.Borrow(cpNext_allocs)

	var cexternalMemoryProperties_allocs *cgoAllocMap
	refd404c4b5.externalMemoryProperties, cexternalMemoryProperties_allocs = x.ExternalMemoryProperties.PassValue()
	allocsd404c4b5.Borrow(cexternalMemoryProperties_allocs)

	x.refd404c4b5 = refd404c4b5
	x.allocsd404c4b5 = allocsd404c4b5
	return refd404c4b5, allocsd404c4b5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalImageFormatProperties) PassValue() (C.VkExternalImageFormatProperties, *cgoAllocMap) {
	if x.refd404c4b5 != nil {
		return *x.refd404c4b5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalImageFormatProperties) Deref() {
	if x.refd404c4b5 == nil {
		return
	}
	x.SType = (StructureType)(x.refd404c4b5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd404c4b5.pNext))
	x.ExternalMemoryProperties = *NewExternalMemoryPropertiesRef(unsafe.Pointer(&x.refd404c4b5.externalMemoryProperties))
}

// allocPhysicalDeviceExternalBufferInfoMemory allocates memory for type C.VkPhysicalDeviceExternalBufferInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExternalBufferInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExternalBufferInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceExternalBufferInfoValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExternalBufferInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalBufferInfo) Ref() *C.VkPhysicalDeviceExternalBufferInfo {
	if x == nil {
		return nil
	}
	return x.ref8d758947
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalBufferInfo) Free() {
	if x != nil && x.allocs8d758947 != nil {
		x.allocs8d758947.(*cgoAllocMap).Free()
		x.ref8d758947 = nil
	}
}

// NewPhysicalDeviceExternalBufferInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalBufferInfoRef(ref unsafe.Pointer) *PhysicalDeviceExternalBufferInfo {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalBufferInfo)
	obj.ref8d758947 = (*C.VkPhysicalDeviceExternalBufferInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalBufferInfo) PassRef() (*C.VkPhysicalDeviceExternalBufferInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8d758947 != nil {
		return x.ref8d758947, nil
	}
	mem8d758947 := allocPhysicalDeviceExternalBufferInfoMemory(1)
	ref8d758947 := (*C.VkPhysicalDeviceExternalBufferInfo)(mem8d758947)
	allocs8d758947 := new(cgoAllocMap)
	allocs8d758947.Add(mem8d758947)

	var csType_allocs *cgoAllocMap
	ref8d758947.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8d758947.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8d758947.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8d758947.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref8d758947.flags, cflags_allocs = (C.VkBufferCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs8d758947.Borrow(cflags_allocs)

	var cusage_allocs *cgoAllocMap
	ref8d758947.usage, cusage_allocs = (C.VkBufferUsageFlags)(x.Usage), cgoAllocsUnknown
	allocs8d758947.Borrow(cusage_allocs)

	var chandleType_allocs *cgoAllocMap
	ref8d758947.handleType, chandleType_allocs = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs8d758947.Borrow(chandleType_allocs)

	x.ref8d758947 = ref8d758947
	x.allocs8d758947 = allocs8d758947
	return ref8d758947, allocs8d758947

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalBufferInfo) PassValue() (C.VkPhysicalDeviceExternalBufferInfo, *cgoAllocMap) {
	if x.ref8d758947 != nil {
		return *x.ref8d758947, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalBufferInfo) Deref() {
	if x.ref8d758947 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8d758947.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8d758947.pNext))
	x.Flags = (BufferCreateFlags)(x.ref8d758947.flags)
	x.Usage = (BufferUsageFlags)(x.ref8d758947.usage)
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.ref8d758947.handleType)
}

// allocExternalBufferPropertiesMemory allocates memory for type C.VkExternalBufferProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalBufferPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalBufferPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalBufferPropertiesValue = unsafe.Sizeof([1]C.VkExternalBufferProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalBufferProperties) Ref() *C.VkExternalBufferProperties {
	if x == nil {
		return nil
	}
	return x.ref12f7c546
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalBufferProperties) Free() {
	if x != nil && x.allocs12f7c546 != nil {
		x.allocs12f7c546.(*cgoAllocMap).Free()
		x.ref12f7c546 = nil
	}
}

// NewExternalBufferPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalBufferPropertiesRef(ref unsafe.Pointer) *ExternalBufferProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExternalBufferProperties)
	obj.ref12f7c546 = (*C.VkExternalBufferProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalBufferProperties) PassRef() (*C.VkExternalBufferProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref12f7c546 != nil {
		return x.ref12f7c546, nil
	}
	mem12f7c546 := allocExternalBufferPropertiesMemory(1)
	ref12f7c546 := (*C.VkExternalBufferProperties)(mem12f7c546)
	allocs12f7c546 := new(cgoAllocMap)
	allocs12f7c546.Add(mem12f7c546)

	var csType_allocs *cgoAllocMap
	ref12f7c546.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs12f7c546.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref12f7c546.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs12f7c546.Borrow(cpNext_allocs)

	var cexternalMemoryProperties_allocs *cgoAllocMap
	ref12f7c546.externalMemoryProperties, cexternalMemoryProperties_allocs = x.ExternalMemoryProperties.PassValue()
	allocs12f7c546.Borrow(cexternalMemoryProperties_allocs)

	x.ref12f7c546 = ref12f7c546
	x.allocs12f7c546 = allocs12f7c546
	return ref12f7c546, allocs12f7c546

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalBufferProperties) PassValue() (C.VkExternalBufferProperties, *cgoAllocMap) {
	if x.ref12f7c546 != nil {
		return *x.ref12f7c546, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalBufferProperties) Deref() {
	if x.ref12f7c546 == nil {
		return
	}
	x.SType = (StructureType)(x.ref12f7c546.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref12f7c546.pNext))
	x.ExternalMemoryProperties = *NewExternalMemoryPropertiesRef(unsafe.Pointer(&x.ref12f7c546.externalMemoryProperties))
}

// allocPhysicalDeviceIDPropertiesMemory allocates memory for type C.VkPhysicalDeviceIDProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceIDPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceIDPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceIDPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceIDProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceIDProperties) Ref() *C.VkPhysicalDeviceIDProperties {
	if x == nil {
		return nil
	}
	return x.refe990a9f3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceIDProperties) Free() {
	if x != nil && x.allocse990a9f3 != nil {
		x.allocse990a9f3.(*cgoAllocMap).Free()
		x.refe990a9f3 = nil
	}
}

// NewPhysicalDeviceIDPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceIDPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceIDProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceIDProperties)
	obj.refe990a9f3 = (*C.VkPhysicalDeviceIDProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceIDProperties) PassRef() (*C.VkPhysicalDeviceIDProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe990a9f3 != nil {
		return x.refe990a9f3, nil
	}
	meme990a9f3 := allocPhysicalDeviceIDPropertiesMemory(1)
	refe990a9f3 := (*C.VkPhysicalDeviceIDProperties)(meme990a9f3)
	allocse990a9f3 := new(cgoAllocMap)
	allocse990a9f3.Add(meme990a9f3)

	var csType_allocs *cgoAllocMap
	refe990a9f3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse990a9f3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe990a9f3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse990a9f3.Borrow(cpNext_allocs)

	var cdeviceUUID_allocs *cgoAllocMap
	refe990a9f3.deviceUUID, cdeviceUUID_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.DeviceUUID)), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdeviceUUID_allocs)

	var cdriverUUID_allocs *cgoAllocMap
	refe990a9f3.driverUUID, cdriverUUID_allocs = *(*[16]C.uint8_t)(unsafe.Pointer(&x.DriverUUID)), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdriverUUID_allocs)

	var cdeviceLUID_allocs *cgoAllocMap
	refe990a9f3.deviceLUID, cdeviceLUID_allocs = *(*[8]C.uint8_t)(unsafe.Pointer(&x.DeviceLUID)), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdeviceLUID_allocs)

	var cdeviceNodeMask_allocs *cgoAllocMap
	refe990a9f3.deviceNodeMask, cdeviceNodeMask_allocs = (C.uint32_t)(x.DeviceNodeMask), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdeviceNodeMask_allocs)

	var cdeviceLUIDValid_allocs *cgoAllocMap
	refe990a9f3.deviceLUIDValid, cdeviceLUIDValid_allocs = (C.VkBool32)(x.DeviceLUIDValid), cgoAllocsUnknown
	allocse990a9f3.Borrow(cdeviceLUIDValid_allocs)

	x.refe990a9f3 = refe990a9f3
	x.allocse990a9f3 = allocse990a9f3
	return refe990a9f3, allocse990a9f3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceIDProperties) PassValue() (C.VkPhysicalDeviceIDProperties, *cgoAllocMap) {
	if x.refe990a9f3 != nil {
		return *x.refe990a9f3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceIDProperties) Deref() {
	if x.refe990a9f3 == nil {
		return
	}
	x.SType = (StructureType)(x.refe990a9f3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe990a9f3.pNext))
	x.DeviceUUID = *(*[16]byte)(unsafe.Pointer(&x.refe990a9f3.deviceUUID))
	x.DriverUUID = *(*[16]byte)(unsafe.Pointer(&x.refe990a9f3.driverUUID))
	x.DeviceLUID = *(*[8]byte)(unsafe.Pointer(&x.refe990a9f3.deviceLUID))
	x.DeviceNodeMask = (uint32)(x.refe990a9f3.deviceNodeMask)
	x.DeviceLUIDValid = (Bool32)(x.refe990a9f3.deviceLUIDValid)
}

// allocExternalMemoryImageCreateInfoMemory allocates memory for type C.VkExternalMemoryImageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalMemoryImageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalMemoryImageCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalMemoryImageCreateInfoValue = unsafe.Sizeof([1]C.VkExternalMemoryImageCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalMemoryImageCreateInfo) Ref() *C.VkExternalMemoryImageCreateInfo {
	if x == nil {
		return nil
	}
	return x.refdaf1185e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalMemoryImageCreateInfo) Free() {
	if x != nil && x.allocsdaf1185e != nil {
		x.allocsdaf1185e.(*cgoAllocMap).Free()
		x.refdaf1185e = nil
	}
}

// NewExternalMemoryImageCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalMemoryImageCreateInfoRef(ref unsafe.Pointer) *ExternalMemoryImageCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ExternalMemoryImageCreateInfo)
	obj.refdaf1185e = (*C.VkExternalMemoryImageCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalMemoryImageCreateInfo) PassRef() (*C.VkExternalMemoryImageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdaf1185e != nil {
		return x.refdaf1185e, nil
	}
	memdaf1185e := allocExternalMemoryImageCreateInfoMemory(1)
	refdaf1185e := (*C.VkExternalMemoryImageCreateInfo)(memdaf1185e)
	allocsdaf1185e := new(cgoAllocMap)
	allocsdaf1185e.Add(memdaf1185e)

	var csType_allocs *cgoAllocMap
	refdaf1185e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdaf1185e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdaf1185e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdaf1185e.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	refdaf1185e.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocsdaf1185e.Borrow(chandleTypes_allocs)

	x.refdaf1185e = refdaf1185e
	x.allocsdaf1185e = allocsdaf1185e
	return refdaf1185e, allocsdaf1185e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalMemoryImageCreateInfo) PassValue() (C.VkExternalMemoryImageCreateInfo, *cgoAllocMap) {
	if x.refdaf1185e != nil {
		return *x.refdaf1185e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalMemoryImageCreateInfo) Deref() {
	if x.refdaf1185e == nil {
		return
	}
	x.SType = (StructureType)(x.refdaf1185e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdaf1185e.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlags)(x.refdaf1185e.handleTypes)
}

// allocExternalMemoryBufferCreateInfoMemory allocates memory for type C.VkExternalMemoryBufferCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalMemoryBufferCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalMemoryBufferCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalMemoryBufferCreateInfoValue = unsafe.Sizeof([1]C.VkExternalMemoryBufferCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalMemoryBufferCreateInfo) Ref() *C.VkExternalMemoryBufferCreateInfo {
	if x == nil {
		return nil
	}
	return x.refd33a9423
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalMemoryBufferCreateInfo) Free() {
	if x != nil && x.allocsd33a9423 != nil {
		x.allocsd33a9423.(*cgoAllocMap).Free()
		x.refd33a9423 = nil
	}
}

// NewExternalMemoryBufferCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalMemoryBufferCreateInfoRef(ref unsafe.Pointer) *ExternalMemoryBufferCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ExternalMemoryBufferCreateInfo)
	obj.refd33a9423 = (*C.VkExternalMemoryBufferCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalMemoryBufferCreateInfo) PassRef() (*C.VkExternalMemoryBufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd33a9423 != nil {
		return x.refd33a9423, nil
	}
	memd33a9423 := allocExternalMemoryBufferCreateInfoMemory(1)
	refd33a9423 := (*C.VkExternalMemoryBufferCreateInfo)(memd33a9423)
	allocsd33a9423 := new(cgoAllocMap)
	allocsd33a9423.Add(memd33a9423)

	var csType_allocs *cgoAllocMap
	refd33a9423.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd33a9423.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd33a9423.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd33a9423.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	refd33a9423.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocsd33a9423.Borrow(chandleTypes_allocs)

	x.refd33a9423 = refd33a9423
	x.allocsd33a9423 = allocsd33a9423
	return refd33a9423, allocsd33a9423

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalMemoryBufferCreateInfo) PassValue() (C.VkExternalMemoryBufferCreateInfo, *cgoAllocMap) {
	if x.refd33a9423 != nil {
		return *x.refd33a9423, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalMemoryBufferCreateInfo) Deref() {
	if x.refd33a9423 == nil {
		return
	}
	x.SType = (StructureType)(x.refd33a9423.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd33a9423.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlags)(x.refd33a9423.handleTypes)
}

// allocExportMemoryAllocateInfoMemory allocates memory for type C.VkExportMemoryAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExportMemoryAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExportMemoryAllocateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExportMemoryAllocateInfoValue = unsafe.Sizeof([1]C.VkExportMemoryAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExportMemoryAllocateInfo) Ref() *C.VkExportMemoryAllocateInfo {
	if x == nil {
		return nil
	}
	return x.refeb76ec64
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExportMemoryAllocateInfo) Free() {
	if x != nil && x.allocseb76ec64 != nil {
		x.allocseb76ec64.(*cgoAllocMap).Free()
		x.refeb76ec64 = nil
	}
}

// NewExportMemoryAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExportMemoryAllocateInfoRef(ref unsafe.Pointer) *ExportMemoryAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ExportMemoryAllocateInfo)
	obj.refeb76ec64 = (*C.VkExportMemoryAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExportMemoryAllocateInfo) PassRef() (*C.VkExportMemoryAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeb76ec64 != nil {
		return x.refeb76ec64, nil
	}
	memeb76ec64 := allocExportMemoryAllocateInfoMemory(1)
	refeb76ec64 := (*C.VkExportMemoryAllocateInfo)(memeb76ec64)
	allocseb76ec64 := new(cgoAllocMap)
	allocseb76ec64.Add(memeb76ec64)

	var csType_allocs *cgoAllocMap
	refeb76ec64.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocseb76ec64.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refeb76ec64.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocseb76ec64.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	refeb76ec64.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocseb76ec64.Borrow(chandleTypes_allocs)

	x.refeb76ec64 = refeb76ec64
	x.allocseb76ec64 = allocseb76ec64
	return refeb76ec64, allocseb76ec64

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExportMemoryAllocateInfo) PassValue() (C.VkExportMemoryAllocateInfo, *cgoAllocMap) {
	if x.refeb76ec64 != nil {
		return *x.refeb76ec64, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExportMemoryAllocateInfo) Deref() {
	if x.refeb76ec64 == nil {
		return
	}
	x.SType = (StructureType)(x.refeb76ec64.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeb76ec64.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlags)(x.refeb76ec64.handleTypes)
}

// allocPhysicalDeviceExternalFenceInfoMemory allocates memory for type C.VkPhysicalDeviceExternalFenceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExternalFenceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExternalFenceInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceExternalFenceInfoValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExternalFenceInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalFenceInfo) Ref() *C.VkPhysicalDeviceExternalFenceInfo {
	if x == nil {
		return nil
	}
	return x.ref9bb660cc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalFenceInfo) Free() {
	if x != nil && x.allocs9bb660cc != nil {
		x.allocs9bb660cc.(*cgoAllocMap).Free()
		x.ref9bb660cc = nil
	}
}

// NewPhysicalDeviceExternalFenceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalFenceInfoRef(ref unsafe.Pointer) *PhysicalDeviceExternalFenceInfo {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalFenceInfo)
	obj.ref9bb660cc = (*C.VkPhysicalDeviceExternalFenceInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalFenceInfo) PassRef() (*C.VkPhysicalDeviceExternalFenceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9bb660cc != nil {
		return x.ref9bb660cc, nil
	}
	mem9bb660cc := allocPhysicalDeviceExternalFenceInfoMemory(1)
	ref9bb660cc := (*C.VkPhysicalDeviceExternalFenceInfo)(mem9bb660cc)
	allocs9bb660cc := new(cgoAllocMap)
	allocs9bb660cc.Add(mem9bb660cc)

	var csType_allocs *cgoAllocMap
	ref9bb660cc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9bb660cc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9bb660cc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9bb660cc.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	ref9bb660cc.handleType, chandleType_allocs = (C.VkExternalFenceHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs9bb660cc.Borrow(chandleType_allocs)

	x.ref9bb660cc = ref9bb660cc
	x.allocs9bb660cc = allocs9bb660cc
	return ref9bb660cc, allocs9bb660cc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalFenceInfo) PassValue() (C.VkPhysicalDeviceExternalFenceInfo, *cgoAllocMap) {
	if x.ref9bb660cc != nil {
		return *x.ref9bb660cc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalFenceInfo) Deref() {
	if x.ref9bb660cc == nil {
		return
	}
	x.SType = (StructureType)(x.ref9bb660cc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9bb660cc.pNext))
	x.HandleType = (ExternalFenceHandleTypeFlagBits)(x.ref9bb660cc.handleType)
}

// allocExternalFencePropertiesMemory allocates memory for type C.VkExternalFenceProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalFencePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalFencePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalFencePropertiesValue = unsafe.Sizeof([1]C.VkExternalFenceProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalFenceProperties) Ref() *C.VkExternalFenceProperties {
	if x == nil {
		return nil
	}
	return x.ref18806773
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalFenceProperties) Free() {
	if x != nil && x.allocs18806773 != nil {
		x.allocs18806773.(*cgoAllocMap).Free()
		x.ref18806773 = nil
	}
}

// NewExternalFencePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalFencePropertiesRef(ref unsafe.Pointer) *ExternalFenceProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExternalFenceProperties)
	obj.ref18806773 = (*C.VkExternalFenceProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalFenceProperties) PassRef() (*C.VkExternalFenceProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref18806773 != nil {
		return x.ref18806773, nil
	}
	mem18806773 := allocExternalFencePropertiesMemory(1)
	ref18806773 := (*C.VkExternalFenceProperties)(mem18806773)
	allocs18806773 := new(cgoAllocMap)
	allocs18806773.Add(mem18806773)

	var csType_allocs *cgoAllocMap
	ref18806773.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs18806773.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref18806773.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs18806773.Borrow(cpNext_allocs)

	var cexportFromImportedHandleTypes_allocs *cgoAllocMap
	ref18806773.exportFromImportedHandleTypes, cexportFromImportedHandleTypes_allocs = (C.VkExternalFenceHandleTypeFlags)(x.ExportFromImportedHandleTypes), cgoAllocsUnknown
	allocs18806773.Borrow(cexportFromImportedHandleTypes_allocs)

	var ccompatibleHandleTypes_allocs *cgoAllocMap
	ref18806773.compatibleHandleTypes, ccompatibleHandleTypes_allocs = (C.VkExternalFenceHandleTypeFlags)(x.CompatibleHandleTypes), cgoAllocsUnknown
	allocs18806773.Borrow(ccompatibleHandleTypes_allocs)

	var cexternalFenceFeatures_allocs *cgoAllocMap
	ref18806773.externalFenceFeatures, cexternalFenceFeatures_allocs = (C.VkExternalFenceFeatureFlags)(x.ExternalFenceFeatures), cgoAllocsUnknown
	allocs18806773.Borrow(cexternalFenceFeatures_allocs)

	x.ref18806773 = ref18806773
	x.allocs18806773 = allocs18806773
	return ref18806773, allocs18806773

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalFenceProperties) PassValue() (C.VkExternalFenceProperties, *cgoAllocMap) {
	if x.ref18806773 != nil {
		return *x.ref18806773, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalFenceProperties) Deref() {
	if x.ref18806773 == nil {
		return
	}
	x.SType = (StructureType)(x.ref18806773.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref18806773.pNext))
	x.ExportFromImportedHandleTypes = (ExternalFenceHandleTypeFlags)(x.ref18806773.exportFromImportedHandleTypes)
	x.CompatibleHandleTypes = (ExternalFenceHandleTypeFlags)(x.ref18806773.compatibleHandleTypes)
	x.ExternalFenceFeatures = (ExternalFenceFeatureFlags)(x.ref18806773.externalFenceFeatures)
}

// allocExportFenceCreateInfoMemory allocates memory for type C.VkExportFenceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExportFenceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExportFenceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExportFenceCreateInfoValue = unsafe.Sizeof([1]C.VkExportFenceCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExportFenceCreateInfo) Ref() *C.VkExportFenceCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref5fef8c3a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExportFenceCreateInfo) Free() {
	if x != nil && x.allocs5fef8c3a != nil {
		x.allocs5fef8c3a.(*cgoAllocMap).Free()
		x.ref5fef8c3a = nil
	}
}

// NewExportFenceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExportFenceCreateInfoRef(ref unsafe.Pointer) *ExportFenceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ExportFenceCreateInfo)
	obj.ref5fef8c3a = (*C.VkExportFenceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExportFenceCreateInfo) PassRef() (*C.VkExportFenceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5fef8c3a != nil {
		return x.ref5fef8c3a, nil
	}
	mem5fef8c3a := allocExportFenceCreateInfoMemory(1)
	ref5fef8c3a := (*C.VkExportFenceCreateInfo)(mem5fef8c3a)
	allocs5fef8c3a := new(cgoAllocMap)
	allocs5fef8c3a.Add(mem5fef8c3a)

	var csType_allocs *cgoAllocMap
	ref5fef8c3a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5fef8c3a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5fef8c3a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5fef8c3a.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	ref5fef8c3a.handleTypes, chandleTypes_allocs = (C.VkExternalFenceHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocs5fef8c3a.Borrow(chandleTypes_allocs)

	x.ref5fef8c3a = ref5fef8c3a
	x.allocs5fef8c3a = allocs5fef8c3a
	return ref5fef8c3a, allocs5fef8c3a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExportFenceCreateInfo) PassValue() (C.VkExportFenceCreateInfo, *cgoAllocMap) {
	if x.ref5fef8c3a != nil {
		return *x.ref5fef8c3a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExportFenceCreateInfo) Deref() {
	if x.ref5fef8c3a == nil {
		return
	}
	x.SType = (StructureType)(x.ref5fef8c3a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5fef8c3a.pNext))
	x.HandleTypes = (ExternalFenceHandleTypeFlags)(x.ref5fef8c3a.handleTypes)
}

// allocExportSemaphoreCreateInfoMemory allocates memory for type C.VkExportSemaphoreCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExportSemaphoreCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExportSemaphoreCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExportSemaphoreCreateInfoValue = unsafe.Sizeof([1]C.VkExportSemaphoreCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExportSemaphoreCreateInfo) Ref() *C.VkExportSemaphoreCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref17b8d6c5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExportSemaphoreCreateInfo) Free() {
	if x != nil && x.allocs17b8d6c5 != nil {
		x.allocs17b8d6c5.(*cgoAllocMap).Free()
		x.ref17b8d6c5 = nil
	}
}

// NewExportSemaphoreCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExportSemaphoreCreateInfoRef(ref unsafe.Pointer) *ExportSemaphoreCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ExportSemaphoreCreateInfo)
	obj.ref17b8d6c5 = (*C.VkExportSemaphoreCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExportSemaphoreCreateInfo) PassRef() (*C.VkExportSemaphoreCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref17b8d6c5 != nil {
		return x.ref17b8d6c5, nil
	}
	mem17b8d6c5 := allocExportSemaphoreCreateInfoMemory(1)
	ref17b8d6c5 := (*C.VkExportSemaphoreCreateInfo)(mem17b8d6c5)
	allocs17b8d6c5 := new(cgoAllocMap)
	allocs17b8d6c5.Add(mem17b8d6c5)

	var csType_allocs *cgoAllocMap
	ref17b8d6c5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs17b8d6c5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref17b8d6c5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs17b8d6c5.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	ref17b8d6c5.handleTypes, chandleTypes_allocs = (C.VkExternalSemaphoreHandleTypeFlags)(x.HandleTypes), cgoAllocsUnknown
	allocs17b8d6c5.Borrow(chandleTypes_allocs)

	x.ref17b8d6c5 = ref17b8d6c5
	x.allocs17b8d6c5 = allocs17b8d6c5
	return ref17b8d6c5, allocs17b8d6c5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExportSemaphoreCreateInfo) PassValue() (C.VkExportSemaphoreCreateInfo, *cgoAllocMap) {
	if x.ref17b8d6c5 != nil {
		return *x.ref17b8d6c5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExportSemaphoreCreateInfo) Deref() {
	if x.ref17b8d6c5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref17b8d6c5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref17b8d6c5.pNext))
	x.HandleTypes = (ExternalSemaphoreHandleTypeFlags)(x.ref17b8d6c5.handleTypes)
}

// allocPhysicalDeviceExternalSemaphoreInfoMemory allocates memory for type C.VkPhysicalDeviceExternalSemaphoreInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExternalSemaphoreInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExternalSemaphoreInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceExternalSemaphoreInfoValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExternalSemaphoreInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalSemaphoreInfo) Ref() *C.VkPhysicalDeviceExternalSemaphoreInfo {
	if x == nil {
		return nil
	}
	return x.ref5981d29e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalSemaphoreInfo) Free() {
	if x != nil && x.allocs5981d29e != nil {
		x.allocs5981d29e.(*cgoAllocMap).Free()
		x.ref5981d29e = nil
	}
}

// NewPhysicalDeviceExternalSemaphoreInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalSemaphoreInfoRef(ref unsafe.Pointer) *PhysicalDeviceExternalSemaphoreInfo {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalSemaphoreInfo)
	obj.ref5981d29e = (*C.VkPhysicalDeviceExternalSemaphoreInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalSemaphoreInfo) PassRef() (*C.VkPhysicalDeviceExternalSemaphoreInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5981d29e != nil {
		return x.ref5981d29e, nil
	}
	mem5981d29e := allocPhysicalDeviceExternalSemaphoreInfoMemory(1)
	ref5981d29e := (*C.VkPhysicalDeviceExternalSemaphoreInfo)(mem5981d29e)
	allocs5981d29e := new(cgoAllocMap)
	allocs5981d29e.Add(mem5981d29e)

	var csType_allocs *cgoAllocMap
	ref5981d29e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5981d29e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5981d29e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5981d29e.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	ref5981d29e.handleType, chandleType_allocs = (C.VkExternalSemaphoreHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs5981d29e.Borrow(chandleType_allocs)

	x.ref5981d29e = ref5981d29e
	x.allocs5981d29e = allocs5981d29e
	return ref5981d29e, allocs5981d29e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalSemaphoreInfo) PassValue() (C.VkPhysicalDeviceExternalSemaphoreInfo, *cgoAllocMap) {
	if x.ref5981d29e != nil {
		return *x.ref5981d29e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalSemaphoreInfo) Deref() {
	if x.ref5981d29e == nil {
		return
	}
	x.SType = (StructureType)(x.ref5981d29e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5981d29e.pNext))
	x.HandleType = (ExternalSemaphoreHandleTypeFlagBits)(x.ref5981d29e.handleType)
}

// allocExternalSemaphorePropertiesMemory allocates memory for type C.VkExternalSemaphoreProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalSemaphorePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalSemaphorePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalSemaphorePropertiesValue = unsafe.Sizeof([1]C.VkExternalSemaphoreProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalSemaphoreProperties) Ref() *C.VkExternalSemaphoreProperties {
	if x == nil {
		return nil
	}
	return x.ref87ec1054
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalSemaphoreProperties) Free() {
	if x != nil && x.allocs87ec1054 != nil {
		x.allocs87ec1054.(*cgoAllocMap).Free()
		x.ref87ec1054 = nil
	}
}

// NewExternalSemaphorePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalSemaphorePropertiesRef(ref unsafe.Pointer) *ExternalSemaphoreProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExternalSemaphoreProperties)
	obj.ref87ec1054 = (*C.VkExternalSemaphoreProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalSemaphoreProperties) PassRef() (*C.VkExternalSemaphoreProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref87ec1054 != nil {
		return x.ref87ec1054, nil
	}
	mem87ec1054 := allocExternalSemaphorePropertiesMemory(1)
	ref87ec1054 := (*C.VkExternalSemaphoreProperties)(mem87ec1054)
	allocs87ec1054 := new(cgoAllocMap)
	allocs87ec1054.Add(mem87ec1054)

	var csType_allocs *cgoAllocMap
	ref87ec1054.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs87ec1054.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref87ec1054.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs87ec1054.Borrow(cpNext_allocs)

	var cexportFromImportedHandleTypes_allocs *cgoAllocMap
	ref87ec1054.exportFromImportedHandleTypes, cexportFromImportedHandleTypes_allocs = (C.VkExternalSemaphoreHandleTypeFlags)(x.ExportFromImportedHandleTypes), cgoAllocsUnknown
	allocs87ec1054.Borrow(cexportFromImportedHandleTypes_allocs)

	var ccompatibleHandleTypes_allocs *cgoAllocMap
	ref87ec1054.compatibleHandleTypes, ccompatibleHandleTypes_allocs = (C.VkExternalSemaphoreHandleTypeFlags)(x.CompatibleHandleTypes), cgoAllocsUnknown
	allocs87ec1054.Borrow(ccompatibleHandleTypes_allocs)

	var cexternalSemaphoreFeatures_allocs *cgoAllocMap
	ref87ec1054.externalSemaphoreFeatures, cexternalSemaphoreFeatures_allocs = (C.VkExternalSemaphoreFeatureFlags)(x.ExternalSemaphoreFeatures), cgoAllocsUnknown
	allocs87ec1054.Borrow(cexternalSemaphoreFeatures_allocs)

	x.ref87ec1054 = ref87ec1054
	x.allocs87ec1054 = allocs87ec1054
	return ref87ec1054, allocs87ec1054

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalSemaphoreProperties) PassValue() (C.VkExternalSemaphoreProperties, *cgoAllocMap) {
	if x.ref87ec1054 != nil {
		return *x.ref87ec1054, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalSemaphoreProperties) Deref() {
	if x.ref87ec1054 == nil {
		return
	}
	x.SType = (StructureType)(x.ref87ec1054.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref87ec1054.pNext))
	x.ExportFromImportedHandleTypes = (ExternalSemaphoreHandleTypeFlags)(x.ref87ec1054.exportFromImportedHandleTypes)
	x.CompatibleHandleTypes = (ExternalSemaphoreHandleTypeFlags)(x.ref87ec1054.compatibleHandleTypes)
	x.ExternalSemaphoreFeatures = (ExternalSemaphoreFeatureFlags)(x.ref87ec1054.externalSemaphoreFeatures)
}

// allocPhysicalDeviceMaintenance3PropertiesMemory allocates memory for type C.VkPhysicalDeviceMaintenance3Properties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMaintenance3PropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMaintenance3PropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceMaintenance3PropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMaintenance3Properties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMaintenance3Properties) Ref() *C.VkPhysicalDeviceMaintenance3Properties {
	if x == nil {
		return nil
	}
	return x.ref12c07777
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMaintenance3Properties) Free() {
	if x != nil && x.allocs12c07777 != nil {
		x.allocs12c07777.(*cgoAllocMap).Free()
		x.ref12c07777 = nil
	}
}

// NewPhysicalDeviceMaintenance3PropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMaintenance3PropertiesRef(ref unsafe.Pointer) *PhysicalDeviceMaintenance3Properties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMaintenance3Properties)
	obj.ref12c07777 = (*C.VkPhysicalDeviceMaintenance3Properties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMaintenance3Properties) PassRef() (*C.VkPhysicalDeviceMaintenance3Properties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref12c07777 != nil {
		return x.ref12c07777, nil
	}
	mem12c07777 := allocPhysicalDeviceMaintenance3PropertiesMemory(1)
	ref12c07777 := (*C.VkPhysicalDeviceMaintenance3Properties)(mem12c07777)
	allocs12c07777 := new(cgoAllocMap)
	allocs12c07777.Add(mem12c07777)

	var csType_allocs *cgoAllocMap
	ref12c07777.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs12c07777.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref12c07777.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs12c07777.Borrow(cpNext_allocs)

	var cmaxPerSetDescriptors_allocs *cgoAllocMap
	ref12c07777.maxPerSetDescriptors, cmaxPerSetDescriptors_allocs = (C.uint32_t)(x.MaxPerSetDescriptors), cgoAllocsUnknown
	allocs12c07777.Borrow(cmaxPerSetDescriptors_allocs)

	var cmaxMemoryAllocationSize_allocs *cgoAllocMap
	ref12c07777.maxMemoryAllocationSize, cmaxMemoryAllocationSize_allocs = (C.VkDeviceSize)(x.MaxMemoryAllocationSize), cgoAllocsUnknown
	allocs12c07777.Borrow(cmaxMemoryAllocationSize_allocs)

	x.ref12c07777 = ref12c07777
	x.allocs12c07777 = allocs12c07777
	return ref12c07777, allocs12c07777

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMaintenance3Properties) PassValue() (C.VkPhysicalDeviceMaintenance3Properties, *cgoAllocMap) {
	if x.ref12c07777 != nil {
		return *x.ref12c07777, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMaintenance3Properties) Deref() {
	if x.ref12c07777 == nil {
		return
	}
	x.SType = (StructureType)(x.ref12c07777.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref12c07777.pNext))
	x.MaxPerSetDescriptors = (uint32)(x.ref12c07777.maxPerSetDescriptors)
	x.MaxMemoryAllocationSize = (DeviceSize)(x.ref12c07777.maxMemoryAllocationSize)
}

// allocDescriptorSetLayoutSupportMemory allocates memory for type C.VkDescriptorSetLayoutSupport in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutSupportMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutSupportValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetLayoutSupportValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutSupport{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetLayoutSupport) Ref() *C.VkDescriptorSetLayoutSupport {
	if x == nil {
		return nil
	}
	return x.ref5802686c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetLayoutSupport) Free() {
	if x != nil && x.allocs5802686c != nil {
		x.allocs5802686c.(*cgoAllocMap).Free()
		x.ref5802686c = nil
	}
}

// NewDescriptorSetLayoutSupportRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetLayoutSupportRef(ref unsafe.Pointer) *DescriptorSetLayoutSupport {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutSupport)
	obj.ref5802686c = (*C.VkDescriptorSetLayoutSupport)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetLayoutSupport) PassRef() (*C.VkDescriptorSetLayoutSupport, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5802686c != nil {
		return x.ref5802686c, nil
	}
	mem5802686c := allocDescriptorSetLayoutSupportMemory(1)
	ref5802686c := (*C.VkDescriptorSetLayoutSupport)(mem5802686c)
	allocs5802686c := new(cgoAllocMap)
	allocs5802686c.Add(mem5802686c)

	var csType_allocs *cgoAllocMap
	ref5802686c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5802686c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5802686c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5802686c.Borrow(cpNext_allocs)

	var csupported_allocs *cgoAllocMap
	ref5802686c.supported, csupported_allocs = (C.VkBool32)(x.Supported), cgoAllocsUnknown
	allocs5802686c.Borrow(csupported_allocs)

	x.ref5802686c = ref5802686c
	x.allocs5802686c = allocs5802686c
	return ref5802686c, allocs5802686c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetLayoutSupport) PassValue() (C.VkDescriptorSetLayoutSupport, *cgoAllocMap) {
	if x.ref5802686c != nil {
		return *x.ref5802686c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetLayoutSupport) Deref() {
	if x.ref5802686c == nil {
		return
	}
	x.SType = (StructureType)(x.ref5802686c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5802686c.pNext))
	x.Supported = (Bool32)(x.ref5802686c.supported)
}

// allocPhysicalDeviceShaderDrawParameterFeaturesMemory allocates memory for type C.VkPhysicalDeviceShaderDrawParameterFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderDrawParameterFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderDrawParameterFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceShaderDrawParameterFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderDrawParameterFeatures{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderDrawParameterFeatures) Ref() *C.VkPhysicalDeviceShaderDrawParameterFeatures {
	if x == nil {
		return nil
	}
	return x.ref23259ea6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderDrawParameterFeatures) Free() {
	if x != nil && x.allocs23259ea6 != nil {
		x.allocs23259ea6.(*cgoAllocMap).Free()
		x.ref23259ea6 = nil
	}
}

// NewPhysicalDeviceShaderDrawParameterFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderDrawParameterFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceShaderDrawParameterFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderDrawParameterFeatures)
	obj.ref23259ea6 = (*C.VkPhysicalDeviceShaderDrawParameterFeatures)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderDrawParameterFeatures) PassRef() (*C.VkPhysicalDeviceShaderDrawParameterFeatures, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref23259ea6 != nil {
		return x.ref23259ea6, nil
	}
	mem23259ea6 := allocPhysicalDeviceShaderDrawParameterFeaturesMemory(1)
	ref23259ea6 := (*C.VkPhysicalDeviceShaderDrawParameterFeatures)(mem23259ea6)
	allocs23259ea6 := new(cgoAllocMap)
	allocs23259ea6.Add(mem23259ea6)

	var csType_allocs *cgoAllocMap
	ref23259ea6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs23259ea6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref23259ea6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs23259ea6.Borrow(cpNext_allocs)

	var cshaderDrawParameters_allocs *cgoAllocMap
	ref23259ea6.shaderDrawParameters, cshaderDrawParameters_allocs = (C.VkBool32)(x.ShaderDrawParameters), cgoAllocsUnknown
	allocs23259ea6.Borrow(cshaderDrawParameters_allocs)

	x.ref23259ea6 = ref23259ea6
	x.allocs23259ea6 = allocs23259ea6
	return ref23259ea6, allocs23259ea6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderDrawParameterFeatures) PassValue() (C.VkPhysicalDeviceShaderDrawParameterFeatures, *cgoAllocMap) {
	if x.ref23259ea6 != nil {
		return *x.ref23259ea6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderDrawParameterFeatures) Deref() {
	if x.ref23259ea6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref23259ea6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref23259ea6.pNext))
	x.ShaderDrawParameters = (Bool32)(x.ref23259ea6.shaderDrawParameters)
}

// allocSurfaceCapabilitiesMemory allocates memory for type C.VkSurfaceCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceCapabilitiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceCapabilitiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSurfaceCapabilitiesValue = unsafe.Sizeof([1]C.VkSurfaceCapabilitiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SurfaceCapabilities) Ref() *C.VkSurfaceCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.ref11d5f596
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SurfaceCapabilities) Free() {
	if x != nil && x.allocs11d5f596 != nil {
		x.allocs11d5f596.(*cgoAllocMap).Free()
		x.ref11d5f596 = nil
	}
}

// NewSurfaceCapabilitiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSurfaceCapabilitiesRef(ref unsafe.Pointer) *SurfaceCapabilities {
	if ref == nil {
		return nil
	}
	obj := new(SurfaceCapabilities)
	obj.ref11d5f596 = (*C.VkSurfaceCapabilitiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SurfaceCapabilities) PassRef() (*C.VkSurfaceCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref11d5f596 != nil {
		return x.ref11d5f596, nil
	}
	mem11d5f596 := allocSurfaceCapabilitiesMemory(1)
	ref11d5f596 := (*C.VkSurfaceCapabilitiesKHR)(mem11d5f596)
	allocs11d5f596 := new(cgoAllocMap)
	allocs11d5f596.Add(mem11d5f596)

	var cminImageCount_allocs *cgoAllocMap
	ref11d5f596.minImageCount, cminImageCount_allocs = (C.uint32_t)(x.MinImageCount), cgoAllocsUnknown
	allocs11d5f596.Borrow(cminImageCount_allocs)

	var cmaxImageCount_allocs *cgoAllocMap
	ref11d5f596.maxImageCount, cmaxImageCount_allocs = (C.uint32_t)(x.MaxImageCount), cgoAllocsUnknown
	allocs11d5f596.Borrow(cmaxImageCount_allocs)

	var ccurrentExtent_allocs *cgoAllocMap
	ref11d5f596.currentExtent, ccurrentExtent_allocs = x.CurrentExtent.PassValue()
	allocs11d5f596.Borrow(ccurrentExtent_allocs)

	var cminImageExtent_allocs *cgoAllocMap
	ref11d5f596.minImageExtent, cminImageExtent_allocs = x.MinImageExtent.PassValue()
	allocs11d5f596.Borrow(cminImageExtent_allocs)

	var cmaxImageExtent_allocs *cgoAllocMap
	ref11d5f596.maxImageExtent, cmaxImageExtent_allocs = x.MaxImageExtent.PassValue()
	allocs11d5f596.Borrow(cmaxImageExtent_allocs)

	var cmaxImageArrayLayers_allocs *cgoAllocMap
	ref11d5f596.maxImageArrayLayers, cmaxImageArrayLayers_allocs = (C.uint32_t)(x.MaxImageArrayLayers), cgoAllocsUnknown
	allocs11d5f596.Borrow(cmaxImageArrayLayers_allocs)

	var csupportedTransforms_allocs *cgoAllocMap
	ref11d5f596.supportedTransforms, csupportedTransforms_allocs = (C.VkSurfaceTransformFlagsKHR)(x.SupportedTransforms), cgoAllocsUnknown
	allocs11d5f596.Borrow(csupportedTransforms_allocs)

	var ccurrentTransform_allocs *cgoAllocMap
	ref11d5f596.currentTransform, ccurrentTransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.CurrentTransform), cgoAllocsUnknown
	allocs11d5f596.Borrow(ccurrentTransform_allocs)

	var csupportedCompositeAlpha_allocs *cgoAllocMap
	ref11d5f596.supportedCompositeAlpha, csupportedCompositeAlpha_allocs = (C.VkCompositeAlphaFlagsKHR)(x.SupportedCompositeAlpha), cgoAllocsUnknown
	allocs11d5f596.Borrow(csupportedCompositeAlpha_allocs)

	var csupportedUsageFlags_allocs *cgoAllocMap
	ref11d5f596.supportedUsageFlags, csupportedUsageFlags_allocs = (C.VkImageUsageFlags)(x.SupportedUsageFlags), cgoAllocsUnknown
	allocs11d5f596.Borrow(csupportedUsageFlags_allocs)

	x.ref11d5f596 = ref11d5f596
	x.allocs11d5f596 = allocs11d5f596
	return ref11d5f596, allocs11d5f596

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SurfaceCapabilities) PassValue() (C.VkSurfaceCapabilitiesKHR, *cgoAllocMap) {
	if x.ref11d5f596 != nil {
		return *x.ref11d5f596, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SurfaceCapabilities) Deref() {
	if x.ref11d5f596 == nil {
		return
	}
	x.MinImageCount = (uint32)(x.ref11d5f596.minImageCount)
	x.MaxImageCount = (uint32)(x.ref11d5f596.maxImageCount)
	x.CurrentExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref11d5f596.currentExtent))
	x.MinImageExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref11d5f596.minImageExtent))
	x.MaxImageExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref11d5f596.maxImageExtent))
	x.MaxImageArrayLayers = (uint32)(x.ref11d5f596.maxImageArrayLayers)
	x.SupportedTransforms = (SurfaceTransformFlags)(x.ref11d5f596.supportedTransforms)
	x.CurrentTransform = (SurfaceTransformFlagBits)(x.ref11d5f596.currentTransform)
	x.SupportedCompositeAlpha = (CompositeAlphaFlags)(x.ref11d5f596.supportedCompositeAlpha)
	x.SupportedUsageFlags = (ImageUsageFlags)(x.ref11d5f596.supportedUsageFlags)
}

// allocSurfaceFormatMemory allocates memory for type C.VkSurfaceFormatKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceFormatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceFormatValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSurfaceFormatValue = unsafe.Sizeof([1]C.VkSurfaceFormatKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SurfaceFormat) Ref() *C.VkSurfaceFormatKHR {
	if x == nil {
		return nil
	}
	return x.refedaf82ca
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SurfaceFormat) Free() {
	if x != nil && x.allocsedaf82ca != nil {
		x.allocsedaf82ca.(*cgoAllocMap).Free()
		x.refedaf82ca = nil
	}
}

// NewSurfaceFormatRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSurfaceFormatRef(ref unsafe.Pointer) *SurfaceFormat {
	if ref == nil {
		return nil
	}
	obj := new(SurfaceFormat)
	obj.refedaf82ca = (*C.VkSurfaceFormatKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SurfaceFormat) PassRef() (*C.VkSurfaceFormatKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refedaf82ca != nil {
		return x.refedaf82ca, nil
	}
	memedaf82ca := allocSurfaceFormatMemory(1)
	refedaf82ca := (*C.VkSurfaceFormatKHR)(memedaf82ca)
	allocsedaf82ca := new(cgoAllocMap)
	allocsedaf82ca.Add(memedaf82ca)

	var cformat_allocs *cgoAllocMap
	refedaf82ca.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocsedaf82ca.Borrow(cformat_allocs)

	var ccolorSpace_allocs *cgoAllocMap
	refedaf82ca.colorSpace, ccolorSpace_allocs = (C.VkColorSpaceKHR)(x.ColorSpace), cgoAllocsUnknown
	allocsedaf82ca.Borrow(ccolorSpace_allocs)

	x.refedaf82ca = refedaf82ca
	x.allocsedaf82ca = allocsedaf82ca
	return refedaf82ca, allocsedaf82ca

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SurfaceFormat) PassValue() (C.VkSurfaceFormatKHR, *cgoAllocMap) {
	if x.refedaf82ca != nil {
		return *x.refedaf82ca, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SurfaceFormat) Deref() {
	if x.refedaf82ca == nil {
		return
	}
	x.Format = (Format)(x.refedaf82ca.format)
	x.ColorSpace = (ColorSpace)(x.refedaf82ca.colorSpace)
}

// allocSwapchainCreateInfoMemory allocates memory for type C.VkSwapchainCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSwapchainCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSwapchainCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSwapchainCreateInfoValue = unsafe.Sizeof([1]C.VkSwapchainCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SwapchainCreateInfo) Ref() *C.VkSwapchainCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.refdb619e1c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SwapchainCreateInfo) Free() {
	if x != nil && x.allocsdb619e1c != nil {
		x.allocsdb619e1c.(*cgoAllocMap).Free()
		x.refdb619e1c = nil
	}
}

// NewSwapchainCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSwapchainCreateInfoRef(ref unsafe.Pointer) *SwapchainCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SwapchainCreateInfo)
	obj.refdb619e1c = (*C.VkSwapchainCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SwapchainCreateInfo) PassRef() (*C.VkSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdb619e1c != nil {
		return x.refdb619e1c, nil
	}
	memdb619e1c := allocSwapchainCreateInfoMemory(1)
	refdb619e1c := (*C.VkSwapchainCreateInfoKHR)(memdb619e1c)
	allocsdb619e1c := new(cgoAllocMap)
	allocsdb619e1c.Add(memdb619e1c)

	var csType_allocs *cgoAllocMap
	refdb619e1c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdb619e1c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdb619e1c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refdb619e1c.flags, cflags_allocs = (C.VkSwapchainCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cflags_allocs)

	var csurface_allocs *cgoAllocMap
	refdb619e1c.surface, csurface_allocs = *(*C.VkSurfaceKHR)(unsafe.Pointer(&x.Surface)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(csurface_allocs)

	var cminImageCount_allocs *cgoAllocMap
	refdb619e1c.minImageCount, cminImageCount_allocs = (C.uint32_t)(x.MinImageCount), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cminImageCount_allocs)

	var cimageFormat_allocs *cgoAllocMap
	refdb619e1c.imageFormat, cimageFormat_allocs = (C.VkFormat)(x.ImageFormat), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageFormat_allocs)

	var cimageColorSpace_allocs *cgoAllocMap
	refdb619e1c.imageColorSpace, cimageColorSpace_allocs = (C.VkColorSpaceKHR)(x.ImageColorSpace), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageColorSpace_allocs)

	var cimageExtent_allocs *cgoAllocMap
	refdb619e1c.imageExtent, cimageExtent_allocs = x.ImageExtent.PassValue()
	allocsdb619e1c.Borrow(cimageExtent_allocs)

	var cimageArrayLayers_allocs *cgoAllocMap
	refdb619e1c.imageArrayLayers, cimageArrayLayers_allocs = (C.uint32_t)(x.ImageArrayLayers), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageArrayLayers_allocs)

	var cimageUsage_allocs *cgoAllocMap
	refdb619e1c.imageUsage, cimageUsage_allocs = (C.VkImageUsageFlags)(x.ImageUsage), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageUsage_allocs)

	var cimageSharingMode_allocs *cgoAllocMap
	refdb619e1c.imageSharingMode, cimageSharingMode_allocs = (C.VkSharingMode)(x.ImageSharingMode), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cimageSharingMode_allocs)

	var cqueueFamilyIndexCount_allocs *cgoAllocMap
	refdb619e1c.queueFamilyIndexCount, cqueueFamilyIndexCount_allocs = (C.uint32_t)(x.QueueFamilyIndexCount), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cqueueFamilyIndexCount_allocs)

	var cpQueueFamilyIndices_allocs *cgoAllocMap
	refdb619e1c.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)).Data)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpQueueFamilyIndices_allocs)

	var cpreTransform_allocs *cgoAllocMap
	refdb619e1c.preTransform, cpreTransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.PreTransform), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpreTransform_allocs)

	var ccompositeAlpha_allocs *cgoAllocMap
	refdb619e1c.compositeAlpha, ccompositeAlpha_allocs = (C.VkCompositeAlphaFlagBitsKHR)(x.CompositeAlpha), cgoAllocsUnknown
	allocsdb619e1c.Borrow(ccompositeAlpha_allocs)

	var cpresentMode_allocs *cgoAllocMap
	refdb619e1c.presentMode, cpresentMode_allocs = (C.VkPresentModeKHR)(x.PresentMode), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cpresentMode_allocs)

	var cclipped_allocs *cgoAllocMap
	refdb619e1c.clipped, cclipped_allocs = (C.VkBool32)(x.Clipped), cgoAllocsUnknown
	allocsdb619e1c.Borrow(cclipped_allocs)

	var coldSwapchain_allocs *cgoAllocMap
	refdb619e1c.oldSwapchain, coldSwapchain_allocs = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.OldSwapchain)), cgoAllocsUnknown
	allocsdb619e1c.Borrow(coldSwapchain_allocs)

	x.refdb619e1c = refdb619e1c
	x.allocsdb619e1c = allocsdb619e1c
	return refdb619e1c, allocsdb619e1c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SwapchainCreateInfo) PassValue() (C.VkSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x.refdb619e1c != nil {
		return *x.refdb619e1c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SwapchainCreateInfo) Deref() {
	if x.refdb619e1c == nil {
		return
	}
	x.SType = (StructureType)(x.refdb619e1c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdb619e1c.pNext))
	x.Flags = (SwapchainCreateFlags)(x.refdb619e1c.flags)
	x.Surface = *(*Surface)(unsafe.Pointer(&x.refdb619e1c.surface))
	x.MinImageCount = (uint32)(x.refdb619e1c.minImageCount)
	x.ImageFormat = (Format)(x.refdb619e1c.imageFormat)
	x.ImageColorSpace = (ColorSpace)(x.refdb619e1c.imageColorSpace)
	x.ImageExtent = *NewExtent2DRef(unsafe.Pointer(&x.refdb619e1c.imageExtent))
	x.ImageArrayLayers = (uint32)(x.refdb619e1c.imageArrayLayers)
	x.ImageUsage = (ImageUsageFlags)(x.refdb619e1c.imageUsage)
	x.ImageSharingMode = (SharingMode)(x.refdb619e1c.imageSharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.refdb619e1c.queueFamilyIndexCount)
	hxffe3496 := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxffe3496.Data = unsafe.Pointer(x.refdb619e1c.pQueueFamilyIndices)
	hxffe3496.Cap = 0x7fffffff
	// hxffe3496.Len = ?

	x.PreTransform = (SurfaceTransformFlagBits)(x.refdb619e1c.preTransform)
	x.CompositeAlpha = (CompositeAlphaFlagBits)(x.refdb619e1c.compositeAlpha)
	x.PresentMode = (PresentMode)(x.refdb619e1c.presentMode)
	x.Clipped = (Bool32)(x.refdb619e1c.clipped)
	x.OldSwapchain = *(*Swapchain)(unsafe.Pointer(&x.refdb619e1c.oldSwapchain))
}

// allocPresentInfoMemory allocates memory for type C.VkPresentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPresentInfoValue = unsafe.Sizeof([1]C.VkPresentInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentInfo) Ref() *C.VkPresentInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref1d0e82d4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentInfo) Free() {
	if x != nil && x.allocs1d0e82d4 != nil {
		x.allocs1d0e82d4.(*cgoAllocMap).Free()
		x.ref1d0e82d4 = nil
	}
}

// NewPresentInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentInfoRef(ref unsafe.Pointer) *PresentInfo {
	if ref == nil {
		return nil
	}
	obj := new(PresentInfo)
	obj.ref1d0e82d4 = (*C.VkPresentInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentInfo) PassRef() (*C.VkPresentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d0e82d4 != nil {
		return x.ref1d0e82d4, nil
	}
	mem1d0e82d4 := allocPresentInfoMemory(1)
	ref1d0e82d4 := (*C.VkPresentInfoKHR)(mem1d0e82d4)
	allocs1d0e82d4 := new(cgoAllocMap)
	allocs1d0e82d4.Add(mem1d0e82d4)

	var csType_allocs *cgoAllocMap
	ref1d0e82d4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1d0e82d4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpNext_allocs)

	var cwaitSemaphoreCount_allocs *cgoAllocMap
	ref1d0e82d4.waitSemaphoreCount, cwaitSemaphoreCount_allocs = (C.uint32_t)(x.WaitSemaphoreCount), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cwaitSemaphoreCount_allocs)

	var cpWaitSemaphores_allocs *cgoAllocMap
	ref1d0e82d4.pWaitSemaphores, cpWaitSemaphores_allocs = (*C.VkSemaphore)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)).Data)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpWaitSemaphores_allocs)

	var cswapchainCount_allocs *cgoAllocMap
	ref1d0e82d4.swapchainCount, cswapchainCount_allocs = (C.uint32_t)(x.SwapchainCount), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cswapchainCount_allocs)

	var cpSwapchains_allocs *cgoAllocMap
	ref1d0e82d4.pSwapchains, cpSwapchains_allocs = (*C.VkSwapchainKHR)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PSwapchains)).Data)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpSwapchains_allocs)

	var cpImageIndices_allocs *cgoAllocMap
	ref1d0e82d4.pImageIndices, cpImageIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PImageIndices)).Data)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpImageIndices_allocs)

	var cpResults_allocs *cgoAllocMap
	ref1d0e82d4.pResults, cpResults_allocs = (*C.VkResult)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PResults)).Data)), cgoAllocsUnknown
	allocs1d0e82d4.Borrow(cpResults_allocs)

	x.ref1d0e82d4 = ref1d0e82d4
	x.allocs1d0e82d4 = allocs1d0e82d4
	return ref1d0e82d4, allocs1d0e82d4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentInfo) PassValue() (C.VkPresentInfoKHR, *cgoAllocMap) {
	if x.ref1d0e82d4 != nil {
		return *x.ref1d0e82d4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentInfo) Deref() {
	if x.ref1d0e82d4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1d0e82d4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1d0e82d4.pNext))
	x.WaitSemaphoreCount = (uint32)(x.ref1d0e82d4.waitSemaphoreCount)
	hxf5d48a6 := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxf5d48a6.Data = unsafe.Pointer(x.ref1d0e82d4.pWaitSemaphores)
	hxf5d48a6.Cap = 0x7fffffff
	// hxf5d48a6.Len = ?

	x.SwapchainCount = (uint32)(x.ref1d0e82d4.swapchainCount)
	hxf685469 := (*sliceHeader)(unsafe.Pointer(&x.PSwapchains))
	hxf685469.Data = unsafe.Pointer(x.ref1d0e82d4.pSwapchains)
	hxf685469.Cap = 0x7fffffff
	// hxf685469.Len = ?

	hxf03a9a7 := (*sliceHeader)(unsafe.Pointer(&x.PImageIndices))
	hxf03a9a7.Data = unsafe.Pointer(x.ref1d0e82d4.pImageIndices)
	hxf03a9a7.Cap = 0x7fffffff
	// hxf03a9a7.Len = ?

	hxff24242 := (*sliceHeader)(unsafe.Pointer(&x.PResults))
	hxff24242.Data = unsafe.Pointer(x.ref1d0e82d4.pResults)
	hxff24242.Cap = 0x7fffffff
	// hxff24242.Len = ?

}

// allocImageSwapchainCreateInfoMemory allocates memory for type C.VkImageSwapchainCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSwapchainCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSwapchainCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageSwapchainCreateInfoValue = unsafe.Sizeof([1]C.VkImageSwapchainCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSwapchainCreateInfo) Ref() *C.VkImageSwapchainCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.refd83cc5d0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSwapchainCreateInfo) Free() {
	if x != nil && x.allocsd83cc5d0 != nil {
		x.allocsd83cc5d0.(*cgoAllocMap).Free()
		x.refd83cc5d0 = nil
	}
}

// NewImageSwapchainCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSwapchainCreateInfoRef(ref unsafe.Pointer) *ImageSwapchainCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageSwapchainCreateInfo)
	obj.refd83cc5d0 = (*C.VkImageSwapchainCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSwapchainCreateInfo) PassRef() (*C.VkImageSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd83cc5d0 != nil {
		return x.refd83cc5d0, nil
	}
	memd83cc5d0 := allocImageSwapchainCreateInfoMemory(1)
	refd83cc5d0 := (*C.VkImageSwapchainCreateInfoKHR)(memd83cc5d0)
	allocsd83cc5d0 := new(cgoAllocMap)
	allocsd83cc5d0.Add(memd83cc5d0)

	var csType_allocs *cgoAllocMap
	refd83cc5d0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd83cc5d0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd83cc5d0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd83cc5d0.Borrow(cpNext_allocs)

	var cswapchain_allocs *cgoAllocMap
	refd83cc5d0.swapchain, cswapchain_allocs = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.Swapchain)), cgoAllocsUnknown
	allocsd83cc5d0.Borrow(cswapchain_allocs)

	x.refd83cc5d0 = refd83cc5d0
	x.allocsd83cc5d0 = allocsd83cc5d0
	return refd83cc5d0, allocsd83cc5d0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSwapchainCreateInfo) PassValue() (C.VkImageSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x.refd83cc5d0 != nil {
		return *x.refd83cc5d0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSwapchainCreateInfo) Deref() {
	if x.refd83cc5d0 == nil {
		return
	}
	x.SType = (StructureType)(x.refd83cc5d0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd83cc5d0.pNext))
	x.Swapchain = *(*Swapchain)(unsafe.Pointer(&x.refd83cc5d0.swapchain))
}

// allocBindImageMemorySwapchainInfoMemory allocates memory for type C.VkBindImageMemorySwapchainInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindImageMemorySwapchainInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindImageMemorySwapchainInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindImageMemorySwapchainInfoValue = unsafe.Sizeof([1]C.VkBindImageMemorySwapchainInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImageMemorySwapchainInfo) Ref() *C.VkBindImageMemorySwapchainInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref1aa25cb6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImageMemorySwapchainInfo) Free() {
	if x != nil && x.allocs1aa25cb6 != nil {
		x.allocs1aa25cb6.(*cgoAllocMap).Free()
		x.ref1aa25cb6 = nil
	}
}

// NewBindImageMemorySwapchainInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImageMemorySwapchainInfoRef(ref unsafe.Pointer) *BindImageMemorySwapchainInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindImageMemorySwapchainInfo)
	obj.ref1aa25cb6 = (*C.VkBindImageMemorySwapchainInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImageMemorySwapchainInfo) PassRef() (*C.VkBindImageMemorySwapchainInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1aa25cb6 != nil {
		return x.ref1aa25cb6, nil
	}
	mem1aa25cb6 := allocBindImageMemorySwapchainInfoMemory(1)
	ref1aa25cb6 := (*C.VkBindImageMemorySwapchainInfoKHR)(mem1aa25cb6)
	allocs1aa25cb6 := new(cgoAllocMap)
	allocs1aa25cb6.Add(mem1aa25cb6)

	var csType_allocs *cgoAllocMap
	ref1aa25cb6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1aa25cb6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1aa25cb6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1aa25cb6.Borrow(cpNext_allocs)

	var cswapchain_allocs *cgoAllocMap
	ref1aa25cb6.swapchain, cswapchain_allocs = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.Swapchain)), cgoAllocsUnknown
	allocs1aa25cb6.Borrow(cswapchain_allocs)

	var cimageIndex_allocs *cgoAllocMap
	ref1aa25cb6.imageIndex, cimageIndex_allocs = (C.uint32_t)(x.ImageIndex), cgoAllocsUnknown
	allocs1aa25cb6.Borrow(cimageIndex_allocs)

	x.ref1aa25cb6 = ref1aa25cb6
	x.allocs1aa25cb6 = allocs1aa25cb6
	return ref1aa25cb6, allocs1aa25cb6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImageMemorySwapchainInfo) PassValue() (C.VkBindImageMemorySwapchainInfoKHR, *cgoAllocMap) {
	if x.ref1aa25cb6 != nil {
		return *x.ref1aa25cb6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImageMemorySwapchainInfo) Deref() {
	if x.ref1aa25cb6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1aa25cb6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1aa25cb6.pNext))
	x.Swapchain = *(*Swapchain)(unsafe.Pointer(&x.ref1aa25cb6.swapchain))
	x.ImageIndex = (uint32)(x.ref1aa25cb6.imageIndex)
}

// allocAcquireNextImageInfoMemory allocates memory for type C.VkAcquireNextImageInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAcquireNextImageInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAcquireNextImageInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAcquireNextImageInfoValue = unsafe.Sizeof([1]C.VkAcquireNextImageInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AcquireNextImageInfo) Ref() *C.VkAcquireNextImageInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref588806a5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AcquireNextImageInfo) Free() {
	if x != nil && x.allocs588806a5 != nil {
		x.allocs588806a5.(*cgoAllocMap).Free()
		x.ref588806a5 = nil
	}
}

// NewAcquireNextImageInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAcquireNextImageInfoRef(ref unsafe.Pointer) *AcquireNextImageInfo {
	if ref == nil {
		return nil
	}
	obj := new(AcquireNextImageInfo)
	obj.ref588806a5 = (*C.VkAcquireNextImageInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AcquireNextImageInfo) PassRef() (*C.VkAcquireNextImageInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref588806a5 != nil {
		return x.ref588806a5, nil
	}
	mem588806a5 := allocAcquireNextImageInfoMemory(1)
	ref588806a5 := (*C.VkAcquireNextImageInfoKHR)(mem588806a5)
	allocs588806a5 := new(cgoAllocMap)
	allocs588806a5.Add(mem588806a5)

	var csType_allocs *cgoAllocMap
	ref588806a5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs588806a5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref588806a5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs588806a5.Borrow(cpNext_allocs)

	var cswapchain_allocs *cgoAllocMap
	ref588806a5.swapchain, cswapchain_allocs = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.Swapchain)), cgoAllocsUnknown
	allocs588806a5.Borrow(cswapchain_allocs)

	var ctimeout_allocs *cgoAllocMap
	ref588806a5.timeout, ctimeout_allocs = (C.uint64_t)(x.Timeout), cgoAllocsUnknown
	allocs588806a5.Borrow(ctimeout_allocs)

	var csemaphore_allocs *cgoAllocMap
	ref588806a5.semaphore, csemaphore_allocs = *(*C.VkSemaphore)(unsafe.Pointer(&x.Semaphore)), cgoAllocsUnknown
	allocs588806a5.Borrow(csemaphore_allocs)

	var cfence_allocs *cgoAllocMap
	ref588806a5.fence, cfence_allocs = *(*C.VkFence)(unsafe.Pointer(&x.Fence)), cgoAllocsUnknown
	allocs588806a5.Borrow(cfence_allocs)

	var cdeviceMask_allocs *cgoAllocMap
	ref588806a5.deviceMask, cdeviceMask_allocs = (C.uint32_t)(x.DeviceMask), cgoAllocsUnknown
	allocs588806a5.Borrow(cdeviceMask_allocs)

	x.ref588806a5 = ref588806a5
	x.allocs588806a5 = allocs588806a5
	return ref588806a5, allocs588806a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AcquireNextImageInfo) PassValue() (C.VkAcquireNextImageInfoKHR, *cgoAllocMap) {
	if x.ref588806a5 != nil {
		return *x.ref588806a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AcquireNextImageInfo) Deref() {
	if x.ref588806a5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref588806a5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref588806a5.pNext))
	x.Swapchain = *(*Swapchain)(unsafe.Pointer(&x.ref588806a5.swapchain))
	x.Timeout = (uint64)(x.ref588806a5.timeout)
	x.Semaphore = *(*Semaphore)(unsafe.Pointer(&x.ref588806a5.semaphore))
	x.Fence = *(*Fence)(unsafe.Pointer(&x.ref588806a5.fence))
	x.DeviceMask = (uint32)(x.ref588806a5.deviceMask)
}

// allocDeviceGroupPresentCapabilitiesMemory allocates memory for type C.VkDeviceGroupPresentCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupPresentCapabilitiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupPresentCapabilitiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGroupPresentCapabilitiesValue = unsafe.Sizeof([1]C.VkDeviceGroupPresentCapabilitiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupPresentCapabilities) Ref() *C.VkDeviceGroupPresentCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.refa3962c81
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupPresentCapabilities) Free() {
	if x != nil && x.allocsa3962c81 != nil {
		x.allocsa3962c81.(*cgoAllocMap).Free()
		x.refa3962c81 = nil
	}
}

// NewDeviceGroupPresentCapabilitiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupPresentCapabilitiesRef(ref unsafe.Pointer) *DeviceGroupPresentCapabilities {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupPresentCapabilities)
	obj.refa3962c81 = (*C.VkDeviceGroupPresentCapabilitiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupPresentCapabilities) PassRef() (*C.VkDeviceGroupPresentCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa3962c81 != nil {
		return x.refa3962c81, nil
	}
	mema3962c81 := allocDeviceGroupPresentCapabilitiesMemory(1)
	refa3962c81 := (*C.VkDeviceGroupPresentCapabilitiesKHR)(mema3962c81)
	allocsa3962c81 := new(cgoAllocMap)
	allocsa3962c81.Add(mema3962c81)

	var csType_allocs *cgoAllocMap
	refa3962c81.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa3962c81.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa3962c81.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa3962c81.Borrow(cpNext_allocs)

	var cpresentMask_allocs *cgoAllocMap
	refa3962c81.presentMask, cpresentMask_allocs = *(*[32]C.uint32_t)(unsafe.Pointer(&x.PresentMask)), cgoAllocsUnknown
	allocsa3962c81.Borrow(cpresentMask_allocs)

	var cmodes_allocs *cgoAllocMap
	refa3962c81.modes, cmodes_allocs = (C.VkDeviceGroupPresentModeFlagsKHR)(x.Modes), cgoAllocsUnknown
	allocsa3962c81.Borrow(cmodes_allocs)

	x.refa3962c81 = refa3962c81
	x.allocsa3962c81 = allocsa3962c81
	return refa3962c81, allocsa3962c81

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupPresentCapabilities) PassValue() (C.VkDeviceGroupPresentCapabilitiesKHR, *cgoAllocMap) {
	if x.refa3962c81 != nil {
		return *x.refa3962c81, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupPresentCapabilities) Deref() {
	if x.refa3962c81 == nil {
		return
	}
	x.SType = (StructureType)(x.refa3962c81.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa3962c81.pNext))
	x.PresentMask = *(*[32]uint32)(unsafe.Pointer(&x.refa3962c81.presentMask))
	x.Modes = (DeviceGroupPresentModeFlags)(x.refa3962c81.modes)
}

// allocDeviceGroupPresentInfoMemory allocates memory for type C.VkDeviceGroupPresentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupPresentInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupPresentInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGroupPresentInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupPresentInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupPresentInfo) Ref() *C.VkDeviceGroupPresentInfoKHR {
	if x == nil {
		return nil
	}
	return x.reff6912d09
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupPresentInfo) Free() {
	if x != nil && x.allocsf6912d09 != nil {
		x.allocsf6912d09.(*cgoAllocMap).Free()
		x.reff6912d09 = nil
	}
}

// NewDeviceGroupPresentInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupPresentInfoRef(ref unsafe.Pointer) *DeviceGroupPresentInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupPresentInfo)
	obj.reff6912d09 = (*C.VkDeviceGroupPresentInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupPresentInfo) PassRef() (*C.VkDeviceGroupPresentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff6912d09 != nil {
		return x.reff6912d09, nil
	}
	memf6912d09 := allocDeviceGroupPresentInfoMemory(1)
	reff6912d09 := (*C.VkDeviceGroupPresentInfoKHR)(memf6912d09)
	allocsf6912d09 := new(cgoAllocMap)
	allocsf6912d09.Add(memf6912d09)

	var csType_allocs *cgoAllocMap
	reff6912d09.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf6912d09.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff6912d09.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf6912d09.Borrow(cpNext_allocs)

	var cswapchainCount_allocs *cgoAllocMap
	reff6912d09.swapchainCount, cswapchainCount_allocs = (C.uint32_t)(x.SwapchainCount), cgoAllocsUnknown
	allocsf6912d09.Borrow(cswapchainCount_allocs)

	var cpDeviceMasks_allocs *cgoAllocMap
	reff6912d09.pDeviceMasks, cpDeviceMasks_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDeviceMasks)).Data)), cgoAllocsUnknown
	allocsf6912d09.Borrow(cpDeviceMasks_allocs)

	var cmode_allocs *cgoAllocMap
	reff6912d09.mode, cmode_allocs = (C.VkDeviceGroupPresentModeFlagBitsKHR)(x.Mode), cgoAllocsUnknown
	allocsf6912d09.Borrow(cmode_allocs)

	x.reff6912d09 = reff6912d09
	x.allocsf6912d09 = allocsf6912d09
	return reff6912d09, allocsf6912d09

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupPresentInfo) PassValue() (C.VkDeviceGroupPresentInfoKHR, *cgoAllocMap) {
	if x.reff6912d09 != nil {
		return *x.reff6912d09, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupPresentInfo) Deref() {
	if x.reff6912d09 == nil {
		return
	}
	x.SType = (StructureType)(x.reff6912d09.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff6912d09.pNext))
	x.SwapchainCount = (uint32)(x.reff6912d09.swapchainCount)
	hxfe93325 := (*sliceHeader)(unsafe.Pointer(&x.PDeviceMasks))
	hxfe93325.Data = unsafe.Pointer(x.reff6912d09.pDeviceMasks)
	hxfe93325.Cap = 0x7fffffff
	// hxfe93325.Len = ?

	x.Mode = (DeviceGroupPresentModeFlagBits)(x.reff6912d09.mode)
}

// allocDeviceGroupSwapchainCreateInfoMemory allocates memory for type C.VkDeviceGroupSwapchainCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupSwapchainCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupSwapchainCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGroupSwapchainCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupSwapchainCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupSwapchainCreateInfo) Ref() *C.VkDeviceGroupSwapchainCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref44ae0c0e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupSwapchainCreateInfo) Free() {
	if x != nil && x.allocs44ae0c0e != nil {
		x.allocs44ae0c0e.(*cgoAllocMap).Free()
		x.ref44ae0c0e = nil
	}
}

// NewDeviceGroupSwapchainCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupSwapchainCreateInfoRef(ref unsafe.Pointer) *DeviceGroupSwapchainCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupSwapchainCreateInfo)
	obj.ref44ae0c0e = (*C.VkDeviceGroupSwapchainCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupSwapchainCreateInfo) PassRef() (*C.VkDeviceGroupSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref44ae0c0e != nil {
		return x.ref44ae0c0e, nil
	}
	mem44ae0c0e := allocDeviceGroupSwapchainCreateInfoMemory(1)
	ref44ae0c0e := (*C.VkDeviceGroupSwapchainCreateInfoKHR)(mem44ae0c0e)
	allocs44ae0c0e := new(cgoAllocMap)
	allocs44ae0c0e.Add(mem44ae0c0e)

	var csType_allocs *cgoAllocMap
	ref44ae0c0e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs44ae0c0e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref44ae0c0e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs44ae0c0e.Borrow(cpNext_allocs)

	var cmodes_allocs *cgoAllocMap
	ref44ae0c0e.modes, cmodes_allocs = (C.VkDeviceGroupPresentModeFlagsKHR)(x.Modes), cgoAllocsUnknown
	allocs44ae0c0e.Borrow(cmodes_allocs)

	x.ref44ae0c0e = ref44ae0c0e
	x.allocs44ae0c0e = allocs44ae0c0e
	return ref44ae0c0e, allocs44ae0c0e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupSwapchainCreateInfo) PassValue() (C.VkDeviceGroupSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x.ref44ae0c0e != nil {
		return *x.ref44ae0c0e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupSwapchainCreateInfo) Deref() {
	if x.ref44ae0c0e == nil {
		return
	}
	x.SType = (StructureType)(x.ref44ae0c0e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref44ae0c0e.pNext))
	x.Modes = (DeviceGroupPresentModeFlags)(x.ref44ae0c0e.modes)
}

// allocDisplayPropertiesMemory allocates memory for type C.VkDisplayPropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPropertiesValue = unsafe.Sizeof([1]C.VkDisplayPropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayProperties) Ref() *C.VkDisplayPropertiesKHR {
	if x == nil {
		return nil
	}
	return x.reffe2a7187
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayProperties) Free() {
	if x != nil && x.allocsfe2a7187 != nil {
		x.allocsfe2a7187.(*cgoAllocMap).Free()
		x.reffe2a7187 = nil
	}
}

// NewDisplayPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPropertiesRef(ref unsafe.Pointer) *DisplayProperties {
	if ref == nil {
		return nil
	}
	obj := new(DisplayProperties)
	obj.reffe2a7187 = (*C.VkDisplayPropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayProperties) PassRef() (*C.VkDisplayPropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe2a7187 != nil {
		return x.reffe2a7187, nil
	}
	memfe2a7187 := allocDisplayPropertiesMemory(1)
	reffe2a7187 := (*C.VkDisplayPropertiesKHR)(memfe2a7187)
	allocsfe2a7187 := new(cgoAllocMap)
	allocsfe2a7187.Add(memfe2a7187)

	var cdisplay_allocs *cgoAllocMap
	reffe2a7187.display, cdisplay_allocs = *(*C.VkDisplayKHR)(unsafe.Pointer(&x.Display)), cgoAllocsUnknown
	allocsfe2a7187.Borrow(cdisplay_allocs)

	var cdisplayName_allocs *cgoAllocMap
	reffe2a7187.displayName, cdisplayName_allocs = unpackPCharString(x.DisplayName)
	allocsfe2a7187.Borrow(cdisplayName_allocs)

	var cphysicalDimensions_allocs *cgoAllocMap
	reffe2a7187.physicalDimensions, cphysicalDimensions_allocs = x.PhysicalDimensions.PassValue()
	allocsfe2a7187.Borrow(cphysicalDimensions_allocs)

	var cphysicalResolution_allocs *cgoAllocMap
	reffe2a7187.physicalResolution, cphysicalResolution_allocs = x.PhysicalResolution.PassValue()
	allocsfe2a7187.Borrow(cphysicalResolution_allocs)

	var csupportedTransforms_allocs *cgoAllocMap
	reffe2a7187.supportedTransforms, csupportedTransforms_allocs = (C.VkSurfaceTransformFlagsKHR)(x.SupportedTransforms), cgoAllocsUnknown
	allocsfe2a7187.Borrow(csupportedTransforms_allocs)

	var cplaneReorderPossible_allocs *cgoAllocMap
	reffe2a7187.planeReorderPossible, cplaneReorderPossible_allocs = (C.VkBool32)(x.PlaneReorderPossible), cgoAllocsUnknown
	allocsfe2a7187.Borrow(cplaneReorderPossible_allocs)

	var cpersistentContent_allocs *cgoAllocMap
	reffe2a7187.persistentContent, cpersistentContent_allocs = (C.VkBool32)(x.PersistentContent), cgoAllocsUnknown
	allocsfe2a7187.Borrow(cpersistentContent_allocs)

	x.reffe2a7187 = reffe2a7187
	x.allocsfe2a7187 = allocsfe2a7187
	return reffe2a7187, allocsfe2a7187

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayProperties) PassValue() (C.VkDisplayPropertiesKHR, *cgoAllocMap) {
	if x.reffe2a7187 != nil {
		return *x.reffe2a7187, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayProperties) Deref() {
	if x.reffe2a7187 == nil {
		return
	}
	x.Display = *(*Display)(unsafe.Pointer(&x.reffe2a7187.display))
	x.DisplayName = packPCharString(x.reffe2a7187.displayName)
	x.PhysicalDimensions = *NewExtent2DRef(unsafe.Pointer(&x.reffe2a7187.physicalDimensions))
	x.PhysicalResolution = *NewExtent2DRef(unsafe.Pointer(&x.reffe2a7187.physicalResolution))
	x.SupportedTransforms = (SurfaceTransformFlags)(x.reffe2a7187.supportedTransforms)
	x.PlaneReorderPossible = (Bool32)(x.reffe2a7187.planeReorderPossible)
	x.PersistentContent = (Bool32)(x.reffe2a7187.persistentContent)
}

// allocDisplayModeParametersMemory allocates memory for type C.VkDisplayModeParametersKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModeParametersMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModeParametersValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayModeParametersValue = unsafe.Sizeof([1]C.VkDisplayModeParametersKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayModeParameters) Ref() *C.VkDisplayModeParametersKHR {
	if x == nil {
		return nil
	}
	return x.refe016f77f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayModeParameters) Free() {
	if x != nil && x.allocse016f77f != nil {
		x.allocse016f77f.(*cgoAllocMap).Free()
		x.refe016f77f = nil
	}
}

// NewDisplayModeParametersRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayModeParametersRef(ref unsafe.Pointer) *DisplayModeParameters {
	if ref == nil {
		return nil
	}
	obj := new(DisplayModeParameters)
	obj.refe016f77f = (*C.VkDisplayModeParametersKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayModeParameters) PassRef() (*C.VkDisplayModeParametersKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe016f77f != nil {
		return x.refe016f77f, nil
	}
	meme016f77f := allocDisplayModeParametersMemory(1)
	refe016f77f := (*C.VkDisplayModeParametersKHR)(meme016f77f)
	allocse016f77f := new(cgoAllocMap)
	allocse016f77f.Add(meme016f77f)

	var cvisibleRegion_allocs *cgoAllocMap
	refe016f77f.visibleRegion, cvisibleRegion_allocs = x.VisibleRegion.PassValue()
	allocse016f77f.Borrow(cvisibleRegion_allocs)

	var crefreshRate_allocs *cgoAllocMap
	refe016f77f.refreshRate, crefreshRate_allocs = (C.uint32_t)(x.RefreshRate), cgoAllocsUnknown
	allocse016f77f.Borrow(crefreshRate_allocs)

	x.refe016f77f = refe016f77f
	x.allocse016f77f = allocse016f77f
	return refe016f77f, allocse016f77f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayModeParameters) PassValue() (C.VkDisplayModeParametersKHR, *cgoAllocMap) {
	if x.refe016f77f != nil {
		return *x.refe016f77f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayModeParameters) Deref() {
	if x.refe016f77f == nil {
		return
	}
	x.VisibleRegion = *NewExtent2DRef(unsafe.Pointer(&x.refe016f77f.visibleRegion))
	x.RefreshRate = (uint32)(x.refe016f77f.refreshRate)
}

// allocDisplayModePropertiesMemory allocates memory for type C.VkDisplayModePropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayModePropertiesValue = unsafe.Sizeof([1]C.VkDisplayModePropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayModeProperties) Ref() *C.VkDisplayModePropertiesKHR {
	if x == nil {
		return nil
	}
	return x.ref5e3abaaa
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayModeProperties) Free() {
	if x != nil && x.allocs5e3abaaa != nil {
		x.allocs5e3abaaa.(*cgoAllocMap).Free()
		x.ref5e3abaaa = nil
	}
}

// NewDisplayModePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayModePropertiesRef(ref unsafe.Pointer) *DisplayModeProperties {
	if ref == nil {
		return nil
	}
	obj := new(DisplayModeProperties)
	obj.ref5e3abaaa = (*C.VkDisplayModePropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayModeProperties) PassRef() (*C.VkDisplayModePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5e3abaaa != nil {
		return x.ref5e3abaaa, nil
	}
	mem5e3abaaa := allocDisplayModePropertiesMemory(1)
	ref5e3abaaa := (*C.VkDisplayModePropertiesKHR)(mem5e3abaaa)
	allocs5e3abaaa := new(cgoAllocMap)
	allocs5e3abaaa.Add(mem5e3abaaa)

	var cdisplayMode_allocs *cgoAllocMap
	ref5e3abaaa.displayMode, cdisplayMode_allocs = *(*C.VkDisplayModeKHR)(unsafe.Pointer(&x.DisplayMode)), cgoAllocsUnknown
	allocs5e3abaaa.Borrow(cdisplayMode_allocs)

	var cparameters_allocs *cgoAllocMap
	ref5e3abaaa.parameters, cparameters_allocs = x.Parameters.PassValue()
	allocs5e3abaaa.Borrow(cparameters_allocs)

	x.ref5e3abaaa = ref5e3abaaa
	x.allocs5e3abaaa = allocs5e3abaaa
	return ref5e3abaaa, allocs5e3abaaa

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayModeProperties) PassValue() (C.VkDisplayModePropertiesKHR, *cgoAllocMap) {
	if x.ref5e3abaaa != nil {
		return *x.ref5e3abaaa, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayModeProperties) Deref() {
	if x.ref5e3abaaa == nil {
		return
	}
	x.DisplayMode = *(*DisplayMode)(unsafe.Pointer(&x.ref5e3abaaa.displayMode))
	x.Parameters = *NewDisplayModeParametersRef(unsafe.Pointer(&x.ref5e3abaaa.parameters))
}

// allocDisplayModeCreateInfoMemory allocates memory for type C.VkDisplayModeCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModeCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModeCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayModeCreateInfoValue = unsafe.Sizeof([1]C.VkDisplayModeCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayModeCreateInfo) Ref() *C.VkDisplayModeCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref392fca31
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayModeCreateInfo) Free() {
	if x != nil && x.allocs392fca31 != nil {
		x.allocs392fca31.(*cgoAllocMap).Free()
		x.ref392fca31 = nil
	}
}

// NewDisplayModeCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayModeCreateInfoRef(ref unsafe.Pointer) *DisplayModeCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DisplayModeCreateInfo)
	obj.ref392fca31 = (*C.VkDisplayModeCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayModeCreateInfo) PassRef() (*C.VkDisplayModeCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref392fca31 != nil {
		return x.ref392fca31, nil
	}
	mem392fca31 := allocDisplayModeCreateInfoMemory(1)
	ref392fca31 := (*C.VkDisplayModeCreateInfoKHR)(mem392fca31)
	allocs392fca31 := new(cgoAllocMap)
	allocs392fca31.Add(mem392fca31)

	var csType_allocs *cgoAllocMap
	ref392fca31.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs392fca31.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref392fca31.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs392fca31.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref392fca31.flags, cflags_allocs = (C.VkDisplayModeCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs392fca31.Borrow(cflags_allocs)

	var cparameters_allocs *cgoAllocMap
	ref392fca31.parameters, cparameters_allocs = x.Parameters.PassValue()
	allocs392fca31.Borrow(cparameters_allocs)

	x.ref392fca31 = ref392fca31
	x.allocs392fca31 = allocs392fca31
	return ref392fca31, allocs392fca31

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayModeCreateInfo) PassValue() (C.VkDisplayModeCreateInfoKHR, *cgoAllocMap) {
	if x.ref392fca31 != nil {
		return *x.ref392fca31, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayModeCreateInfo) Deref() {
	if x.ref392fca31 == nil {
		return
	}
	x.SType = (StructureType)(x.ref392fca31.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref392fca31.pNext))
	x.Flags = (DisplayModeCreateFlags)(x.ref392fca31.flags)
	x.Parameters = *NewDisplayModeParametersRef(unsafe.Pointer(&x.ref392fca31.parameters))
}

// allocDisplayPlaneCapabilitiesMemory allocates memory for type C.VkDisplayPlaneCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlaneCapabilitiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlaneCapabilitiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPlaneCapabilitiesValue = unsafe.Sizeof([1]C.VkDisplayPlaneCapabilitiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlaneCapabilities) Ref() *C.VkDisplayPlaneCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.ref6f31fcaf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlaneCapabilities) Free() {
	if x != nil && x.allocs6f31fcaf != nil {
		x.allocs6f31fcaf.(*cgoAllocMap).Free()
		x.ref6f31fcaf = nil
	}
}

// NewDisplayPlaneCapabilitiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlaneCapabilitiesRef(ref unsafe.Pointer) *DisplayPlaneCapabilities {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneCapabilities)
	obj.ref6f31fcaf = (*C.VkDisplayPlaneCapabilitiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlaneCapabilities) PassRef() (*C.VkDisplayPlaneCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6f31fcaf != nil {
		return x.ref6f31fcaf, nil
	}
	mem6f31fcaf := allocDisplayPlaneCapabilitiesMemory(1)
	ref6f31fcaf := (*C.VkDisplayPlaneCapabilitiesKHR)(mem6f31fcaf)
	allocs6f31fcaf := new(cgoAllocMap)
	allocs6f31fcaf.Add(mem6f31fcaf)

	var csupportedAlpha_allocs *cgoAllocMap
	ref6f31fcaf.supportedAlpha, csupportedAlpha_allocs = (C.VkDisplayPlaneAlphaFlagsKHR)(x.SupportedAlpha), cgoAllocsUnknown
	allocs6f31fcaf.Borrow(csupportedAlpha_allocs)

	var cminSrcPosition_allocs *cgoAllocMap
	ref6f31fcaf.minSrcPosition, cminSrcPosition_allocs = x.MinSrcPosition.PassValue()
	allocs6f31fcaf.Borrow(cminSrcPosition_allocs)

	var cmaxSrcPosition_allocs *cgoAllocMap
	ref6f31fcaf.maxSrcPosition, cmaxSrcPosition_allocs = x.MaxSrcPosition.PassValue()
	allocs6f31fcaf.Borrow(cmaxSrcPosition_allocs)

	var cminSrcExtent_allocs *cgoAllocMap
	ref6f31fcaf.minSrcExtent, cminSrcExtent_allocs = x.MinSrcExtent.PassValue()
	allocs6f31fcaf.Borrow(cminSrcExtent_allocs)

	var cmaxSrcExtent_allocs *cgoAllocMap
	ref6f31fcaf.maxSrcExtent, cmaxSrcExtent_allocs = x.MaxSrcExtent.PassValue()
	allocs6f31fcaf.Borrow(cmaxSrcExtent_allocs)

	var cminDstPosition_allocs *cgoAllocMap
	ref6f31fcaf.minDstPosition, cminDstPosition_allocs = x.MinDstPosition.PassValue()
	allocs6f31fcaf.Borrow(cminDstPosition_allocs)

	var cmaxDstPosition_allocs *cgoAllocMap
	ref6f31fcaf.maxDstPosition, cmaxDstPosition_allocs = x.MaxDstPosition.PassValue()
	allocs6f31fcaf.Borrow(cmaxDstPosition_allocs)

	var cminDstExtent_allocs *cgoAllocMap
	ref6f31fcaf.minDstExtent, cminDstExtent_allocs = x.MinDstExtent.PassValue()
	allocs6f31fcaf.Borrow(cminDstExtent_allocs)

	var cmaxDstExtent_allocs *cgoAllocMap
	ref6f31fcaf.maxDstExtent, cmaxDstExtent_allocs = x.MaxDstExtent.PassValue()
	allocs6f31fcaf.Borrow(cmaxDstExtent_allocs)

	x.ref6f31fcaf = ref6f31fcaf
	x.allocs6f31fcaf = allocs6f31fcaf
	return ref6f31fcaf, allocs6f31fcaf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlaneCapabilities) PassValue() (C.VkDisplayPlaneCapabilitiesKHR, *cgoAllocMap) {
	if x.ref6f31fcaf != nil {
		return *x.ref6f31fcaf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlaneCapabilities) Deref() {
	if x.ref6f31fcaf == nil {
		return
	}
	x.SupportedAlpha = (DisplayPlaneAlphaFlags)(x.ref6f31fcaf.supportedAlpha)
	x.MinSrcPosition = *NewOffset2DRef(unsafe.Pointer(&x.ref6f31fcaf.minSrcPosition))
	x.MaxSrcPosition = *NewOffset2DRef(unsafe.Pointer(&x.ref6f31fcaf.maxSrcPosition))
	x.MinSrcExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref6f31fcaf.minSrcExtent))
	x.MaxSrcExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref6f31fcaf.maxSrcExtent))
	x.MinDstPosition = *NewOffset2DRef(unsafe.Pointer(&x.ref6f31fcaf.minDstPosition))
	x.MaxDstPosition = *NewOffset2DRef(unsafe.Pointer(&x.ref6f31fcaf.maxDstPosition))
	x.MinDstExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref6f31fcaf.minDstExtent))
	x.MaxDstExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref6f31fcaf.maxDstExtent))
}

// allocDisplayPlanePropertiesMemory allocates memory for type C.VkDisplayPlanePropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlanePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlanePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPlanePropertiesValue = unsafe.Sizeof([1]C.VkDisplayPlanePropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlaneProperties) Ref() *C.VkDisplayPlanePropertiesKHR {
	if x == nil {
		return nil
	}
	return x.refce3db3f6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlaneProperties) Free() {
	if x != nil && x.allocsce3db3f6 != nil {
		x.allocsce3db3f6.(*cgoAllocMap).Free()
		x.refce3db3f6 = nil
	}
}

// NewDisplayPlanePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlanePropertiesRef(ref unsafe.Pointer) *DisplayPlaneProperties {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneProperties)
	obj.refce3db3f6 = (*C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlaneProperties) PassRef() (*C.VkDisplayPlanePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refce3db3f6 != nil {
		return x.refce3db3f6, nil
	}
	memce3db3f6 := allocDisplayPlanePropertiesMemory(1)
	refce3db3f6 := (*C.VkDisplayPlanePropertiesKHR)(memce3db3f6)
	allocsce3db3f6 := new(cgoAllocMap)
	allocsce3db3f6.Add(memce3db3f6)

	var ccurrentDisplay_allocs *cgoAllocMap
	refce3db3f6.currentDisplay, ccurrentDisplay_allocs = *(*C.VkDisplayKHR)(unsafe.Pointer(&x.CurrentDisplay)), cgoAllocsUnknown
	allocsce3db3f6.Borrow(ccurrentDisplay_allocs)

	var ccurrentStackIndex_allocs *cgoAllocMap
	refce3db3f6.currentStackIndex, ccurrentStackIndex_allocs = (C.uint32_t)(x.CurrentStackIndex), cgoAllocsUnknown
	allocsce3db3f6.Borrow(ccurrentStackIndex_allocs)

	x.refce3db3f6 = refce3db3f6
	x.allocsce3db3f6 = allocsce3db3f6
	return refce3db3f6, allocsce3db3f6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlaneProperties) PassValue() (C.VkDisplayPlanePropertiesKHR, *cgoAllocMap) {
	if x.refce3db3f6 != nil {
		return *x.refce3db3f6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlaneProperties) Deref() {
	if x.refce3db3f6 == nil {
		return
	}
	x.CurrentDisplay = *(*Display)(unsafe.Pointer(&x.refce3db3f6.currentDisplay))
	x.CurrentStackIndex = (uint32)(x.refce3db3f6.currentStackIndex)
}

// allocDisplaySurfaceCreateInfoMemory allocates memory for type C.VkDisplaySurfaceCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplaySurfaceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplaySurfaceCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplaySurfaceCreateInfoValue = unsafe.Sizeof([1]C.VkDisplaySurfaceCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplaySurfaceCreateInfo) Ref() *C.VkDisplaySurfaceCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref58445c35
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplaySurfaceCreateInfo) Free() {
	if x != nil && x.allocs58445c35 != nil {
		x.allocs58445c35.(*cgoAllocMap).Free()
		x.ref58445c35 = nil
	}
}

// NewDisplaySurfaceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplaySurfaceCreateInfoRef(ref unsafe.Pointer) *DisplaySurfaceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DisplaySurfaceCreateInfo)
	obj.ref58445c35 = (*C.VkDisplaySurfaceCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplaySurfaceCreateInfo) PassRef() (*C.VkDisplaySurfaceCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref58445c35 != nil {
		return x.ref58445c35, nil
	}
	mem58445c35 := allocDisplaySurfaceCreateInfoMemory(1)
	ref58445c35 := (*C.VkDisplaySurfaceCreateInfoKHR)(mem58445c35)
	allocs58445c35 := new(cgoAllocMap)
	allocs58445c35.Add(mem58445c35)

	var csType_allocs *cgoAllocMap
	ref58445c35.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs58445c35.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref58445c35.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs58445c35.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref58445c35.flags, cflags_allocs = (C.VkDisplaySurfaceCreateFlagsKHR)(x.Flags), cgoAllocsUnknown
	allocs58445c35.Borrow(cflags_allocs)

	var cdisplayMode_allocs *cgoAllocMap
	ref58445c35.displayMode, cdisplayMode_allocs = *(*C.VkDisplayModeKHR)(unsafe.Pointer(&x.DisplayMode)), cgoAllocsUnknown
	allocs58445c35.Borrow(cdisplayMode_allocs)

	var cplaneIndex_allocs *cgoAllocMap
	ref58445c35.planeIndex, cplaneIndex_allocs = (C.uint32_t)(x.PlaneIndex), cgoAllocsUnknown
	allocs58445c35.Borrow(cplaneIndex_allocs)

	var cplaneStackIndex_allocs *cgoAllocMap
	ref58445c35.planeStackIndex, cplaneStackIndex_allocs = (C.uint32_t)(x.PlaneStackIndex), cgoAllocsUnknown
	allocs58445c35.Borrow(cplaneStackIndex_allocs)

	var ctransform_allocs *cgoAllocMap
	ref58445c35.transform, ctransform_allocs = (C.VkSurfaceTransformFlagBitsKHR)(x.Transform), cgoAllocsUnknown
	allocs58445c35.Borrow(ctransform_allocs)

	var cglobalAlpha_allocs *cgoAllocMap
	ref58445c35.globalAlpha, cglobalAlpha_allocs = (C.float)(x.GlobalAlpha), cgoAllocsUnknown
	allocs58445c35.Borrow(cglobalAlpha_allocs)

	var calphaMode_allocs *cgoAllocMap
	ref58445c35.alphaMode, calphaMode_allocs = (C.VkDisplayPlaneAlphaFlagBitsKHR)(x.AlphaMode), cgoAllocsUnknown
	allocs58445c35.Borrow(calphaMode_allocs)

	var cimageExtent_allocs *cgoAllocMap
	ref58445c35.imageExtent, cimageExtent_allocs = x.ImageExtent.PassValue()
	allocs58445c35.Borrow(cimageExtent_allocs)

	x.ref58445c35 = ref58445c35
	x.allocs58445c35 = allocs58445c35
	return ref58445c35, allocs58445c35

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplaySurfaceCreateInfo) PassValue() (C.VkDisplaySurfaceCreateInfoKHR, *cgoAllocMap) {
	if x.ref58445c35 != nil {
		return *x.ref58445c35, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplaySurfaceCreateInfo) Deref() {
	if x.ref58445c35 == nil {
		return
	}
	x.SType = (StructureType)(x.ref58445c35.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref58445c35.pNext))
	x.Flags = (DisplaySurfaceCreateFlags)(x.ref58445c35.flags)
	x.DisplayMode = *(*DisplayMode)(unsafe.Pointer(&x.ref58445c35.displayMode))
	x.PlaneIndex = (uint32)(x.ref58445c35.planeIndex)
	x.PlaneStackIndex = (uint32)(x.ref58445c35.planeStackIndex)
	x.Transform = (SurfaceTransformFlagBits)(x.ref58445c35.transform)
	x.GlobalAlpha = (float32)(x.ref58445c35.globalAlpha)
	x.AlphaMode = (DisplayPlaneAlphaFlagBits)(x.ref58445c35.alphaMode)
	x.ImageExtent = *NewExtent2DRef(unsafe.Pointer(&x.ref58445c35.imageExtent))
}

// allocDisplayPresentInfoMemory allocates memory for type C.VkDisplayPresentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPresentInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPresentInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPresentInfoValue = unsafe.Sizeof([1]C.VkDisplayPresentInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPresentInfo) Ref() *C.VkDisplayPresentInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref8d2571e4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPresentInfo) Free() {
	if x != nil && x.allocs8d2571e4 != nil {
		x.allocs8d2571e4.(*cgoAllocMap).Free()
		x.ref8d2571e4 = nil
	}
}

// NewDisplayPresentInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPresentInfoRef(ref unsafe.Pointer) *DisplayPresentInfo {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPresentInfo)
	obj.ref8d2571e4 = (*C.VkDisplayPresentInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPresentInfo) PassRef() (*C.VkDisplayPresentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8d2571e4 != nil {
		return x.ref8d2571e4, nil
	}
	mem8d2571e4 := allocDisplayPresentInfoMemory(1)
	ref8d2571e4 := (*C.VkDisplayPresentInfoKHR)(mem8d2571e4)
	allocs8d2571e4 := new(cgoAllocMap)
	allocs8d2571e4.Add(mem8d2571e4)

	var csType_allocs *cgoAllocMap
	ref8d2571e4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8d2571e4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8d2571e4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8d2571e4.Borrow(cpNext_allocs)

	var csrcRect_allocs *cgoAllocMap
	ref8d2571e4.srcRect, csrcRect_allocs = x.SrcRect.PassValue()
	allocs8d2571e4.Borrow(csrcRect_allocs)

	var cdstRect_allocs *cgoAllocMap
	ref8d2571e4.dstRect, cdstRect_allocs = x.DstRect.PassValue()
	allocs8d2571e4.Borrow(cdstRect_allocs)

	var cpersistent_allocs *cgoAllocMap
	ref8d2571e4.persistent, cpersistent_allocs = (C.VkBool32)(x.Persistent), cgoAllocsUnknown
	allocs8d2571e4.Borrow(cpersistent_allocs)

	x.ref8d2571e4 = ref8d2571e4
	x.allocs8d2571e4 = allocs8d2571e4
	return ref8d2571e4, allocs8d2571e4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPresentInfo) PassValue() (C.VkDisplayPresentInfoKHR, *cgoAllocMap) {
	if x.ref8d2571e4 != nil {
		return *x.ref8d2571e4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPresentInfo) Deref() {
	if x.ref8d2571e4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8d2571e4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8d2571e4.pNext))
	x.SrcRect = *NewRect2DRef(unsafe.Pointer(&x.ref8d2571e4.srcRect))
	x.DstRect = *NewRect2DRef(unsafe.Pointer(&x.ref8d2571e4.dstRect))
	x.Persistent = (Bool32)(x.ref8d2571e4.persistent)
}

// allocImportMemoryFdInfoMemory allocates memory for type C.VkImportMemoryFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImportMemoryFdInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImportMemoryFdInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImportMemoryFdInfoValue = unsafe.Sizeof([1]C.VkImportMemoryFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImportMemoryFdInfo) Ref() *C.VkImportMemoryFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref73f83287
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImportMemoryFdInfo) Free() {
	if x != nil && x.allocs73f83287 != nil {
		x.allocs73f83287.(*cgoAllocMap).Free()
		x.ref73f83287 = nil
	}
}

// NewImportMemoryFdInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImportMemoryFdInfoRef(ref unsafe.Pointer) *ImportMemoryFdInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImportMemoryFdInfo)
	obj.ref73f83287 = (*C.VkImportMemoryFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImportMemoryFdInfo) PassRef() (*C.VkImportMemoryFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref73f83287 != nil {
		return x.ref73f83287, nil
	}
	mem73f83287 := allocImportMemoryFdInfoMemory(1)
	ref73f83287 := (*C.VkImportMemoryFdInfoKHR)(mem73f83287)
	allocs73f83287 := new(cgoAllocMap)
	allocs73f83287.Add(mem73f83287)

	var csType_allocs *cgoAllocMap
	ref73f83287.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs73f83287.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref73f83287.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs73f83287.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	ref73f83287.handleType, chandleType_allocs = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs73f83287.Borrow(chandleType_allocs)

	var cfd_allocs *cgoAllocMap
	ref73f83287.fd, cfd_allocs = (C.int)(x.Fd), cgoAllocsUnknown
	allocs73f83287.Borrow(cfd_allocs)

	x.ref73f83287 = ref73f83287
	x.allocs73f83287 = allocs73f83287
	return ref73f83287, allocs73f83287

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImportMemoryFdInfo) PassValue() (C.VkImportMemoryFdInfoKHR, *cgoAllocMap) {
	if x.ref73f83287 != nil {
		return *x.ref73f83287, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImportMemoryFdInfo) Deref() {
	if x.ref73f83287 == nil {
		return
	}
	x.SType = (StructureType)(x.ref73f83287.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref73f83287.pNext))
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.ref73f83287.handleType)
	x.Fd = (int32)(x.ref73f83287.fd)
}

// allocMemoryFdPropertiesMemory allocates memory for type C.VkMemoryFdPropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryFdPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryFdPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryFdPropertiesValue = unsafe.Sizeof([1]C.VkMemoryFdPropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryFdProperties) Ref() *C.VkMemoryFdPropertiesKHR {
	if x == nil {
		return nil
	}
	return x.ref51e16d38
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryFdProperties) Free() {
	if x != nil && x.allocs51e16d38 != nil {
		x.allocs51e16d38.(*cgoAllocMap).Free()
		x.ref51e16d38 = nil
	}
}

// NewMemoryFdPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryFdPropertiesRef(ref unsafe.Pointer) *MemoryFdProperties {
	if ref == nil {
		return nil
	}
	obj := new(MemoryFdProperties)
	obj.ref51e16d38 = (*C.VkMemoryFdPropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryFdProperties) PassRef() (*C.VkMemoryFdPropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref51e16d38 != nil {
		return x.ref51e16d38, nil
	}
	mem51e16d38 := allocMemoryFdPropertiesMemory(1)
	ref51e16d38 := (*C.VkMemoryFdPropertiesKHR)(mem51e16d38)
	allocs51e16d38 := new(cgoAllocMap)
	allocs51e16d38.Add(mem51e16d38)

	var csType_allocs *cgoAllocMap
	ref51e16d38.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs51e16d38.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref51e16d38.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs51e16d38.Borrow(cpNext_allocs)

	var cmemoryTypeBits_allocs *cgoAllocMap
	ref51e16d38.memoryTypeBits, cmemoryTypeBits_allocs = (C.uint32_t)(x.MemoryTypeBits), cgoAllocsUnknown
	allocs51e16d38.Borrow(cmemoryTypeBits_allocs)

	x.ref51e16d38 = ref51e16d38
	x.allocs51e16d38 = allocs51e16d38
	return ref51e16d38, allocs51e16d38

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryFdProperties) PassValue() (C.VkMemoryFdPropertiesKHR, *cgoAllocMap) {
	if x.ref51e16d38 != nil {
		return *x.ref51e16d38, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryFdProperties) Deref() {
	if x.ref51e16d38 == nil {
		return
	}
	x.SType = (StructureType)(x.ref51e16d38.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref51e16d38.pNext))
	x.MemoryTypeBits = (uint32)(x.ref51e16d38.memoryTypeBits)
}

// allocMemoryGetFdInfoMemory allocates memory for type C.VkMemoryGetFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryGetFdInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryGetFdInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryGetFdInfoValue = unsafe.Sizeof([1]C.VkMemoryGetFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryGetFdInfo) Ref() *C.VkMemoryGetFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref75a079b1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryGetFdInfo) Free() {
	if x != nil && x.allocs75a079b1 != nil {
		x.allocs75a079b1.(*cgoAllocMap).Free()
		x.ref75a079b1 = nil
	}
}

// NewMemoryGetFdInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryGetFdInfoRef(ref unsafe.Pointer) *MemoryGetFdInfo {
	if ref == nil {
		return nil
	}
	obj := new(MemoryGetFdInfo)
	obj.ref75a079b1 = (*C.VkMemoryGetFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryGetFdInfo) PassRef() (*C.VkMemoryGetFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref75a079b1 != nil {
		return x.ref75a079b1, nil
	}
	mem75a079b1 := allocMemoryGetFdInfoMemory(1)
	ref75a079b1 := (*C.VkMemoryGetFdInfoKHR)(mem75a079b1)
	allocs75a079b1 := new(cgoAllocMap)
	allocs75a079b1.Add(mem75a079b1)

	var csType_allocs *cgoAllocMap
	ref75a079b1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs75a079b1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref75a079b1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs75a079b1.Borrow(cpNext_allocs)

	var cmemory_allocs *cgoAllocMap
	ref75a079b1.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocs75a079b1.Borrow(cmemory_allocs)

	var chandleType_allocs *cgoAllocMap
	ref75a079b1.handleType, chandleType_allocs = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs75a079b1.Borrow(chandleType_allocs)

	x.ref75a079b1 = ref75a079b1
	x.allocs75a079b1 = allocs75a079b1
	return ref75a079b1, allocs75a079b1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryGetFdInfo) PassValue() (C.VkMemoryGetFdInfoKHR, *cgoAllocMap) {
	if x.ref75a079b1 != nil {
		return *x.ref75a079b1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryGetFdInfo) Deref() {
	if x.ref75a079b1 == nil {
		return
	}
	x.SType = (StructureType)(x.ref75a079b1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref75a079b1.pNext))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref75a079b1.memory))
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.ref75a079b1.handleType)
}

// allocImportSemaphoreFdInfoMemory allocates memory for type C.VkImportSemaphoreFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImportSemaphoreFdInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImportSemaphoreFdInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImportSemaphoreFdInfoValue = unsafe.Sizeof([1]C.VkImportSemaphoreFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImportSemaphoreFdInfo) Ref() *C.VkImportSemaphoreFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.refbc2f829a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImportSemaphoreFdInfo) Free() {
	if x != nil && x.allocsbc2f829a != nil {
		x.allocsbc2f829a.(*cgoAllocMap).Free()
		x.refbc2f829a = nil
	}
}

// NewImportSemaphoreFdInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImportSemaphoreFdInfoRef(ref unsafe.Pointer) *ImportSemaphoreFdInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImportSemaphoreFdInfo)
	obj.refbc2f829a = (*C.VkImportSemaphoreFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImportSemaphoreFdInfo) PassRef() (*C.VkImportSemaphoreFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbc2f829a != nil {
		return x.refbc2f829a, nil
	}
	membc2f829a := allocImportSemaphoreFdInfoMemory(1)
	refbc2f829a := (*C.VkImportSemaphoreFdInfoKHR)(membc2f829a)
	allocsbc2f829a := new(cgoAllocMap)
	allocsbc2f829a.Add(membc2f829a)

	var csType_allocs *cgoAllocMap
	refbc2f829a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbc2f829a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbc2f829a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbc2f829a.Borrow(cpNext_allocs)

	var csemaphore_allocs *cgoAllocMap
	refbc2f829a.semaphore, csemaphore_allocs = *(*C.VkSemaphore)(unsafe.Pointer(&x.Semaphore)), cgoAllocsUnknown
	allocsbc2f829a.Borrow(csemaphore_allocs)

	var cflags_allocs *cgoAllocMap
	refbc2f829a.flags, cflags_allocs = (C.VkSemaphoreImportFlags)(x.Flags), cgoAllocsUnknown
	allocsbc2f829a.Borrow(cflags_allocs)

	var chandleType_allocs *cgoAllocMap
	refbc2f829a.handleType, chandleType_allocs = (C.VkExternalSemaphoreHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocsbc2f829a.Borrow(chandleType_allocs)

	var cfd_allocs *cgoAllocMap
	refbc2f829a.fd, cfd_allocs = (C.int)(x.Fd), cgoAllocsUnknown
	allocsbc2f829a.Borrow(cfd_allocs)

	x.refbc2f829a = refbc2f829a
	x.allocsbc2f829a = allocsbc2f829a
	return refbc2f829a, allocsbc2f829a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImportSemaphoreFdInfo) PassValue() (C.VkImportSemaphoreFdInfoKHR, *cgoAllocMap) {
	if x.refbc2f829a != nil {
		return *x.refbc2f829a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImportSemaphoreFdInfo) Deref() {
	if x.refbc2f829a == nil {
		return
	}
	x.SType = (StructureType)(x.refbc2f829a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbc2f829a.pNext))
	x.Semaphore = *(*Semaphore)(unsafe.Pointer(&x.refbc2f829a.semaphore))
	x.Flags = (SemaphoreImportFlags)(x.refbc2f829a.flags)
	x.HandleType = (ExternalSemaphoreHandleTypeFlagBits)(x.refbc2f829a.handleType)
	x.Fd = (int32)(x.refbc2f829a.fd)
}

// allocSemaphoreGetFdInfoMemory allocates memory for type C.VkSemaphoreGetFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreGetFdInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreGetFdInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSemaphoreGetFdInfoValue = unsafe.Sizeof([1]C.VkSemaphoreGetFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SemaphoreGetFdInfo) Ref() *C.VkSemaphoreGetFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.refd9bd07cf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SemaphoreGetFdInfo) Free() {
	if x != nil && x.allocsd9bd07cf != nil {
		x.allocsd9bd07cf.(*cgoAllocMap).Free()
		x.refd9bd07cf = nil
	}
}

// NewSemaphoreGetFdInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSemaphoreGetFdInfoRef(ref unsafe.Pointer) *SemaphoreGetFdInfo {
	if ref == nil {
		return nil
	}
	obj := new(SemaphoreGetFdInfo)
	obj.refd9bd07cf = (*C.VkSemaphoreGetFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SemaphoreGetFdInfo) PassRef() (*C.VkSemaphoreGetFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd9bd07cf != nil {
		return x.refd9bd07cf, nil
	}
	memd9bd07cf := allocSemaphoreGetFdInfoMemory(1)
	refd9bd07cf := (*C.VkSemaphoreGetFdInfoKHR)(memd9bd07cf)
	allocsd9bd07cf := new(cgoAllocMap)
	allocsd9bd07cf.Add(memd9bd07cf)

	var csType_allocs *cgoAllocMap
	refd9bd07cf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd9bd07cf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd9bd07cf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd9bd07cf.Borrow(cpNext_allocs)

	var csemaphore_allocs *cgoAllocMap
	refd9bd07cf.semaphore, csemaphore_allocs = *(*C.VkSemaphore)(unsafe.Pointer(&x.Semaphore)), cgoAllocsUnknown
	allocsd9bd07cf.Borrow(csemaphore_allocs)

	var chandleType_allocs *cgoAllocMap
	refd9bd07cf.handleType, chandleType_allocs = (C.VkExternalSemaphoreHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocsd9bd07cf.Borrow(chandleType_allocs)

	x.refd9bd07cf = refd9bd07cf
	x.allocsd9bd07cf = allocsd9bd07cf
	return refd9bd07cf, allocsd9bd07cf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SemaphoreGetFdInfo) PassValue() (C.VkSemaphoreGetFdInfoKHR, *cgoAllocMap) {
	if x.refd9bd07cf != nil {
		return *x.refd9bd07cf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SemaphoreGetFdInfo) Deref() {
	if x.refd9bd07cf == nil {
		return
	}
	x.SType = (StructureType)(x.refd9bd07cf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd9bd07cf.pNext))
	x.Semaphore = *(*Semaphore)(unsafe.Pointer(&x.refd9bd07cf.semaphore))
	x.HandleType = (ExternalSemaphoreHandleTypeFlagBits)(x.refd9bd07cf.handleType)
}

// allocPhysicalDevicePushDescriptorPropertiesMemory allocates memory for type C.VkPhysicalDevicePushDescriptorPropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePushDescriptorPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePushDescriptorPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDevicePushDescriptorPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDevicePushDescriptorPropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevicePushDescriptorProperties) Ref() *C.VkPhysicalDevicePushDescriptorPropertiesKHR {
	if x == nil {
		return nil
	}
	return x.ref8c58a1a5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevicePushDescriptorProperties) Free() {
	if x != nil && x.allocs8c58a1a5 != nil {
		x.allocs8c58a1a5.(*cgoAllocMap).Free()
		x.ref8c58a1a5 = nil
	}
}

// NewPhysicalDevicePushDescriptorPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePushDescriptorPropertiesRef(ref unsafe.Pointer) *PhysicalDevicePushDescriptorProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevicePushDescriptorProperties)
	obj.ref8c58a1a5 = (*C.VkPhysicalDevicePushDescriptorPropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevicePushDescriptorProperties) PassRef() (*C.VkPhysicalDevicePushDescriptorPropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8c58a1a5 != nil {
		return x.ref8c58a1a5, nil
	}
	mem8c58a1a5 := allocPhysicalDevicePushDescriptorPropertiesMemory(1)
	ref8c58a1a5 := (*C.VkPhysicalDevicePushDescriptorPropertiesKHR)(mem8c58a1a5)
	allocs8c58a1a5 := new(cgoAllocMap)
	allocs8c58a1a5.Add(mem8c58a1a5)

	var csType_allocs *cgoAllocMap
	ref8c58a1a5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8c58a1a5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8c58a1a5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8c58a1a5.Borrow(cpNext_allocs)

	var cmaxPushDescriptors_allocs *cgoAllocMap
	ref8c58a1a5.maxPushDescriptors, cmaxPushDescriptors_allocs = (C.uint32_t)(x.MaxPushDescriptors), cgoAllocsUnknown
	allocs8c58a1a5.Borrow(cmaxPushDescriptors_allocs)

	x.ref8c58a1a5 = ref8c58a1a5
	x.allocs8c58a1a5 = allocs8c58a1a5
	return ref8c58a1a5, allocs8c58a1a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevicePushDescriptorProperties) PassValue() (C.VkPhysicalDevicePushDescriptorPropertiesKHR, *cgoAllocMap) {
	if x.ref8c58a1a5 != nil {
		return *x.ref8c58a1a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevicePushDescriptorProperties) Deref() {
	if x.ref8c58a1a5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8c58a1a5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8c58a1a5.pNext))
	x.MaxPushDescriptors = (uint32)(x.ref8c58a1a5.maxPushDescriptors)
}

// allocRectLayerMemory allocates memory for type C.VkRectLayerKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectLayerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectLayerValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRectLayerValue = unsafe.Sizeof([1]C.VkRectLayerKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RectLayer) Ref() *C.VkRectLayerKHR {
	if x == nil {
		return nil
	}
	return x.refaf248476
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RectLayer) Free() {
	if x != nil && x.allocsaf248476 != nil {
		x.allocsaf248476.(*cgoAllocMap).Free()
		x.refaf248476 = nil
	}
}

// NewRectLayerRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRectLayerRef(ref unsafe.Pointer) *RectLayer {
	if ref == nil {
		return nil
	}
	obj := new(RectLayer)
	obj.refaf248476 = (*C.VkRectLayerKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RectLayer) PassRef() (*C.VkRectLayerKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaf248476 != nil {
		return x.refaf248476, nil
	}
	memaf248476 := allocRectLayerMemory(1)
	refaf248476 := (*C.VkRectLayerKHR)(memaf248476)
	allocsaf248476 := new(cgoAllocMap)
	allocsaf248476.Add(memaf248476)

	var coffset_allocs *cgoAllocMap
	refaf248476.offset, coffset_allocs = x.Offset.PassValue()
	allocsaf248476.Borrow(coffset_allocs)

	var cextent_allocs *cgoAllocMap
	refaf248476.extent, cextent_allocs = x.Extent.PassValue()
	allocsaf248476.Borrow(cextent_allocs)

	var clayer_allocs *cgoAllocMap
	refaf248476.layer, clayer_allocs = (C.uint32_t)(x.Layer), cgoAllocsUnknown
	allocsaf248476.Borrow(clayer_allocs)

	x.refaf248476 = refaf248476
	x.allocsaf248476 = allocsaf248476
	return refaf248476, allocsaf248476

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RectLayer) PassValue() (C.VkRectLayerKHR, *cgoAllocMap) {
	if x.refaf248476 != nil {
		return *x.refaf248476, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RectLayer) Deref() {
	if x.refaf248476 == nil {
		return
	}
	x.Offset = *NewOffset2DRef(unsafe.Pointer(&x.refaf248476.offset))
	x.Extent = *NewExtent2DRef(unsafe.Pointer(&x.refaf248476.extent))
	x.Layer = (uint32)(x.refaf248476.layer)
}

// allocPresentRegionMemory allocates memory for type C.VkPresentRegionKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentRegionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentRegionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPresentRegionValue = unsafe.Sizeof([1]C.VkPresentRegionKHR{})

// unpackSRectLayer transforms a sliced Go data structure into plain C format.
func unpackSRectLayer(x []RectLayer) (unpacked *C.VkRectLayerKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkRectLayerKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRectLayerMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRectLayerKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRectLayerKHR)(h.Data)
	return
}

// packSRectLayer reads sliced Go data structure out from plain C format.
func packSRectLayer(v []RectLayer, ptr0 *C.VkRectLayerKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRectLayerValue]C.VkRectLayerKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRectLayerRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentRegion) Ref() *C.VkPresentRegionKHR {
	if x == nil {
		return nil
	}
	return x.refbbc0d1b9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentRegion) Free() {
	if x != nil && x.allocsbbc0d1b9 != nil {
		x.allocsbbc0d1b9.(*cgoAllocMap).Free()
		x.refbbc0d1b9 = nil
	}
}

// NewPresentRegionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentRegionRef(ref unsafe.Pointer) *PresentRegion {
	if ref == nil {
		return nil
	}
	obj := new(PresentRegion)
	obj.refbbc0d1b9 = (*C.VkPresentRegionKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentRegion) PassRef() (*C.VkPresentRegionKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbbc0d1b9 != nil {
		return x.refbbc0d1b9, nil
	}
	membbc0d1b9 := allocPresentRegionMemory(1)
	refbbc0d1b9 := (*C.VkPresentRegionKHR)(membbc0d1b9)
	allocsbbc0d1b9 := new(cgoAllocMap)
	allocsbbc0d1b9.Add(membbc0d1b9)

	var crectangleCount_allocs *cgoAllocMap
	refbbc0d1b9.rectangleCount, crectangleCount_allocs = (C.uint32_t)(x.RectangleCount), cgoAllocsUnknown
	allocsbbc0d1b9.Borrow(crectangleCount_allocs)

	var cpRectangles_allocs *cgoAllocMap
	refbbc0d1b9.pRectangles, cpRectangles_allocs = unpackSRectLayer(x.PRectangles)
	allocsbbc0d1b9.Borrow(cpRectangles_allocs)

	x.refbbc0d1b9 = refbbc0d1b9
	x.allocsbbc0d1b9 = allocsbbc0d1b9
	return refbbc0d1b9, allocsbbc0d1b9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentRegion) PassValue() (C.VkPresentRegionKHR, *cgoAllocMap) {
	if x.refbbc0d1b9 != nil {
		return *x.refbbc0d1b9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentRegion) Deref() {
	if x.refbbc0d1b9 == nil {
		return
	}
	x.RectangleCount = (uint32)(x.refbbc0d1b9.rectangleCount)
	packSRectLayer(x.PRectangles, x.refbbc0d1b9.pRectangles)
}

// allocPresentRegionsMemory allocates memory for type C.VkPresentRegionsKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentRegionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentRegionsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPresentRegionsValue = unsafe.Sizeof([1]C.VkPresentRegionsKHR{})

// unpackSPresentRegion transforms a sliced Go data structure into plain C format.
func unpackSPresentRegion(x []PresentRegion) (unpacked *C.VkPresentRegionKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPresentRegionKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPresentRegionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPresentRegionKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPresentRegionKHR)(h.Data)
	return
}

// packSPresentRegion reads sliced Go data structure out from plain C format.
func packSPresentRegion(v []PresentRegion, ptr0 *C.VkPresentRegionKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPresentRegionValue]C.VkPresentRegionKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPresentRegionRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentRegions) Ref() *C.VkPresentRegionsKHR {
	if x == nil {
		return nil
	}
	return x.ref62958060
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentRegions) Free() {
	if x != nil && x.allocs62958060 != nil {
		x.allocs62958060.(*cgoAllocMap).Free()
		x.ref62958060 = nil
	}
}

// NewPresentRegionsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentRegionsRef(ref unsafe.Pointer) *PresentRegions {
	if ref == nil {
		return nil
	}
	obj := new(PresentRegions)
	obj.ref62958060 = (*C.VkPresentRegionsKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentRegions) PassRef() (*C.VkPresentRegionsKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref62958060 != nil {
		return x.ref62958060, nil
	}
	mem62958060 := allocPresentRegionsMemory(1)
	ref62958060 := (*C.VkPresentRegionsKHR)(mem62958060)
	allocs62958060 := new(cgoAllocMap)
	allocs62958060.Add(mem62958060)

	var csType_allocs *cgoAllocMap
	ref62958060.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs62958060.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref62958060.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs62958060.Borrow(cpNext_allocs)

	var cswapchainCount_allocs *cgoAllocMap
	ref62958060.swapchainCount, cswapchainCount_allocs = (C.uint32_t)(x.SwapchainCount), cgoAllocsUnknown
	allocs62958060.Borrow(cswapchainCount_allocs)

	var cpRegions_allocs *cgoAllocMap
	ref62958060.pRegions, cpRegions_allocs = unpackSPresentRegion(x.PRegions)
	allocs62958060.Borrow(cpRegions_allocs)

	x.ref62958060 = ref62958060
	x.allocs62958060 = allocs62958060
	return ref62958060, allocs62958060

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentRegions) PassValue() (C.VkPresentRegionsKHR, *cgoAllocMap) {
	if x.ref62958060 != nil {
		return *x.ref62958060, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentRegions) Deref() {
	if x.ref62958060 == nil {
		return
	}
	x.SType = (StructureType)(x.ref62958060.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref62958060.pNext))
	x.SwapchainCount = (uint32)(x.ref62958060.swapchainCount)
	packSPresentRegion(x.PRegions, x.ref62958060.pRegions)
}

// allocAttachmentDescription2Memory allocates memory for type C.VkAttachmentDescription2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentDescription2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentDescription2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAttachmentDescription2Value = unsafe.Sizeof([1]C.VkAttachmentDescription2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentDescription2) Ref() *C.VkAttachmentDescription2KHR {
	if x == nil {
		return nil
	}
	return x.refe0fc3d48
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentDescription2) Free() {
	if x != nil && x.allocse0fc3d48 != nil {
		x.allocse0fc3d48.(*cgoAllocMap).Free()
		x.refe0fc3d48 = nil
	}
}

// NewAttachmentDescription2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentDescription2Ref(ref unsafe.Pointer) *AttachmentDescription2 {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentDescription2)
	obj.refe0fc3d48 = (*C.VkAttachmentDescription2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentDescription2) PassRef() (*C.VkAttachmentDescription2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe0fc3d48 != nil {
		return x.refe0fc3d48, nil
	}
	meme0fc3d48 := allocAttachmentDescription2Memory(1)
	refe0fc3d48 := (*C.VkAttachmentDescription2KHR)(meme0fc3d48)
	allocse0fc3d48 := new(cgoAllocMap)
	allocse0fc3d48.Add(meme0fc3d48)

	var csType_allocs *cgoAllocMap
	refe0fc3d48.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse0fc3d48.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe0fc3d48.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refe0fc3d48.flags, cflags_allocs = (C.VkAttachmentDescriptionFlags)(x.Flags), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cflags_allocs)

	var cformat_allocs *cgoAllocMap
	refe0fc3d48.format, cformat_allocs = (C.VkFormat)(x.Format), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cformat_allocs)

	var csamples_allocs *cgoAllocMap
	refe0fc3d48.samples, csamples_allocs = (C.VkSampleCountFlagBits)(x.Samples), cgoAllocsUnknown
	allocse0fc3d48.Borrow(csamples_allocs)

	var cloadOp_allocs *cgoAllocMap
	refe0fc3d48.loadOp, cloadOp_allocs = (C.VkAttachmentLoadOp)(x.LoadOp), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cloadOp_allocs)

	var cstoreOp_allocs *cgoAllocMap
	refe0fc3d48.storeOp, cstoreOp_allocs = (C.VkAttachmentStoreOp)(x.StoreOp), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cstoreOp_allocs)

	var cstencilLoadOp_allocs *cgoAllocMap
	refe0fc3d48.stencilLoadOp, cstencilLoadOp_allocs = (C.VkAttachmentLoadOp)(x.StencilLoadOp), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cstencilLoadOp_allocs)

	var cstencilStoreOp_allocs *cgoAllocMap
	refe0fc3d48.stencilStoreOp, cstencilStoreOp_allocs = (C.VkAttachmentStoreOp)(x.StencilStoreOp), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cstencilStoreOp_allocs)

	var cinitialLayout_allocs *cgoAllocMap
	refe0fc3d48.initialLayout, cinitialLayout_allocs = (C.VkImageLayout)(x.InitialLayout), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cinitialLayout_allocs)

	var cfinalLayout_allocs *cgoAllocMap
	refe0fc3d48.finalLayout, cfinalLayout_allocs = (C.VkImageLayout)(x.FinalLayout), cgoAllocsUnknown
	allocse0fc3d48.Borrow(cfinalLayout_allocs)

	x.refe0fc3d48 = refe0fc3d48
	x.allocse0fc3d48 = allocse0fc3d48
	return refe0fc3d48, allocse0fc3d48

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentDescription2) PassValue() (C.VkAttachmentDescription2KHR, *cgoAllocMap) {
	if x.refe0fc3d48 != nil {
		return *x.refe0fc3d48, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentDescription2) Deref() {
	if x.refe0fc3d48 == nil {
		return
	}
	x.SType = (StructureType)(x.refe0fc3d48.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe0fc3d48.pNext))
	x.Flags = (AttachmentDescriptionFlags)(x.refe0fc3d48.flags)
	x.Format = (Format)(x.refe0fc3d48.format)
	x.Samples = (SampleCountFlagBits)(x.refe0fc3d48.samples)
	x.LoadOp = (AttachmentLoadOp)(x.refe0fc3d48.loadOp)
	x.StoreOp = (AttachmentStoreOp)(x.refe0fc3d48.storeOp)
	x.StencilLoadOp = (AttachmentLoadOp)(x.refe0fc3d48.stencilLoadOp)
	x.StencilStoreOp = (AttachmentStoreOp)(x.refe0fc3d48.stencilStoreOp)
	x.InitialLayout = (ImageLayout)(x.refe0fc3d48.initialLayout)
	x.FinalLayout = (ImageLayout)(x.refe0fc3d48.finalLayout)
}

// allocAttachmentReference2Memory allocates memory for type C.VkAttachmentReference2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentReference2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentReference2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAttachmentReference2Value = unsafe.Sizeof([1]C.VkAttachmentReference2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentReference2) Ref() *C.VkAttachmentReference2KHR {
	if x == nil {
		return nil
	}
	return x.refa31684a1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentReference2) Free() {
	if x != nil && x.allocsa31684a1 != nil {
		x.allocsa31684a1.(*cgoAllocMap).Free()
		x.refa31684a1 = nil
	}
}

// NewAttachmentReference2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentReference2Ref(ref unsafe.Pointer) *AttachmentReference2 {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentReference2)
	obj.refa31684a1 = (*C.VkAttachmentReference2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentReference2) PassRef() (*C.VkAttachmentReference2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa31684a1 != nil {
		return x.refa31684a1, nil
	}
	mema31684a1 := allocAttachmentReference2Memory(1)
	refa31684a1 := (*C.VkAttachmentReference2KHR)(mema31684a1)
	allocsa31684a1 := new(cgoAllocMap)
	allocsa31684a1.Add(mema31684a1)

	var csType_allocs *cgoAllocMap
	refa31684a1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa31684a1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa31684a1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa31684a1.Borrow(cpNext_allocs)

	var cattachment_allocs *cgoAllocMap
	refa31684a1.attachment, cattachment_allocs = (C.uint32_t)(x.Attachment), cgoAllocsUnknown
	allocsa31684a1.Borrow(cattachment_allocs)

	var clayout_allocs *cgoAllocMap
	refa31684a1.layout, clayout_allocs = (C.VkImageLayout)(x.Layout), cgoAllocsUnknown
	allocsa31684a1.Borrow(clayout_allocs)

	var caspectMask_allocs *cgoAllocMap
	refa31684a1.aspectMask, caspectMask_allocs = (C.VkImageAspectFlags)(x.AspectMask), cgoAllocsUnknown
	allocsa31684a1.Borrow(caspectMask_allocs)

	x.refa31684a1 = refa31684a1
	x.allocsa31684a1 = allocsa31684a1
	return refa31684a1, allocsa31684a1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentReference2) PassValue() (C.VkAttachmentReference2KHR, *cgoAllocMap) {
	if x.refa31684a1 != nil {
		return *x.refa31684a1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentReference2) Deref() {
	if x.refa31684a1 == nil {
		return
	}
	x.SType = (StructureType)(x.refa31684a1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa31684a1.pNext))
	x.Attachment = (uint32)(x.refa31684a1.attachment)
	x.Layout = (ImageLayout)(x.refa31684a1.layout)
	x.AspectMask = (ImageAspectFlags)(x.refa31684a1.aspectMask)
}

// allocSubpassDescription2Memory allocates memory for type C.VkSubpassDescription2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDescription2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDescription2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassDescription2Value = unsafe.Sizeof([1]C.VkSubpassDescription2KHR{})

// unpackSAttachmentReference2 transforms a sliced Go data structure into plain C format.
func unpackSAttachmentReference2(x []AttachmentReference2) (unpacked *C.VkAttachmentReference2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkAttachmentReference2KHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentReference2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentReference2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentReference2KHR)(h.Data)
	return
}

// packSAttachmentReference2 reads sliced Go data structure out from plain C format.
func packSAttachmentReference2(v []AttachmentReference2, ptr0 *C.VkAttachmentReference2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentReference2Value]C.VkAttachmentReference2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentReference2Ref(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassDescription2) Ref() *C.VkSubpassDescription2KHR {
	if x == nil {
		return nil
	}
	return x.ref89a293f3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassDescription2) Free() {
	if x != nil && x.allocs89a293f3 != nil {
		x.allocs89a293f3.(*cgoAllocMap).Free()
		x.ref89a293f3 = nil
	}
}

// NewSubpassDescription2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassDescription2Ref(ref unsafe.Pointer) *SubpassDescription2 {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDescription2)
	obj.ref89a293f3 = (*C.VkSubpassDescription2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassDescription2) PassRef() (*C.VkSubpassDescription2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref89a293f3 != nil {
		return x.ref89a293f3, nil
	}
	mem89a293f3 := allocSubpassDescription2Memory(1)
	ref89a293f3 := (*C.VkSubpassDescription2KHR)(mem89a293f3)
	allocs89a293f3 := new(cgoAllocMap)
	allocs89a293f3.Add(mem89a293f3)

	var csType_allocs *cgoAllocMap
	ref89a293f3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs89a293f3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref89a293f3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs89a293f3.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref89a293f3.flags, cflags_allocs = (C.VkSubpassDescriptionFlags)(x.Flags), cgoAllocsUnknown
	allocs89a293f3.Borrow(cflags_allocs)

	var cpipelineBindPoint_allocs *cgoAllocMap
	ref89a293f3.pipelineBindPoint, cpipelineBindPoint_allocs = (C.VkPipelineBindPoint)(x.PipelineBindPoint), cgoAllocsUnknown
	allocs89a293f3.Borrow(cpipelineBindPoint_allocs)

	var cviewMask_allocs *cgoAllocMap
	ref89a293f3.viewMask, cviewMask_allocs = (C.uint32_t)(x.ViewMask), cgoAllocsUnknown
	allocs89a293f3.Borrow(cviewMask_allocs)

	var cinputAttachmentCount_allocs *cgoAllocMap
	ref89a293f3.inputAttachmentCount, cinputAttachmentCount_allocs = (C.uint32_t)(x.InputAttachmentCount), cgoAllocsUnknown
	allocs89a293f3.Borrow(cinputAttachmentCount_allocs)

	var cpInputAttachments_allocs *cgoAllocMap
	ref89a293f3.pInputAttachments, cpInputAttachments_allocs = unpackSAttachmentReference2(x.PInputAttachments)
	allocs89a293f3.Borrow(cpInputAttachments_allocs)

	var ccolorAttachmentCount_allocs *cgoAllocMap
	ref89a293f3.colorAttachmentCount, ccolorAttachmentCount_allocs = (C.uint32_t)(x.ColorAttachmentCount), cgoAllocsUnknown
	allocs89a293f3.Borrow(ccolorAttachmentCount_allocs)

	var cpColorAttachments_allocs *cgoAllocMap
	ref89a293f3.pColorAttachments, cpColorAttachments_allocs = unpackSAttachmentReference2(x.PColorAttachments)
	allocs89a293f3.Borrow(cpColorAttachments_allocs)

	var cpResolveAttachments_allocs *cgoAllocMap
	ref89a293f3.pResolveAttachments, cpResolveAttachments_allocs = unpackSAttachmentReference2(x.PResolveAttachments)
	allocs89a293f3.Borrow(cpResolveAttachments_allocs)

	var cpDepthStencilAttachment_allocs *cgoAllocMap
	ref89a293f3.pDepthStencilAttachment, cpDepthStencilAttachment_allocs = unpackSAttachmentReference2(x.PDepthStencilAttachment)
	allocs89a293f3.Borrow(cpDepthStencilAttachment_allocs)

	var cpreserveAttachmentCount_allocs *cgoAllocMap
	ref89a293f3.preserveAttachmentCount, cpreserveAttachmentCount_allocs = (C.uint32_t)(x.PreserveAttachmentCount), cgoAllocsUnknown
	allocs89a293f3.Borrow(cpreserveAttachmentCount_allocs)

	var cpPreserveAttachments_allocs *cgoAllocMap
	ref89a293f3.pPreserveAttachments, cpPreserveAttachments_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments)).Data)), cgoAllocsUnknown
	allocs89a293f3.Borrow(cpPreserveAttachments_allocs)

	x.ref89a293f3 = ref89a293f3
	x.allocs89a293f3 = allocs89a293f3
	return ref89a293f3, allocs89a293f3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassDescription2) PassValue() (C.VkSubpassDescription2KHR, *cgoAllocMap) {
	if x.ref89a293f3 != nil {
		return *x.ref89a293f3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassDescription2) Deref() {
	if x.ref89a293f3 == nil {
		return
	}
	x.SType = (StructureType)(x.ref89a293f3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref89a293f3.pNext))
	x.Flags = (SubpassDescriptionFlags)(x.ref89a293f3.flags)
	x.PipelineBindPoint = (PipelineBindPoint)(x.ref89a293f3.pipelineBindPoint)
	x.ViewMask = (uint32)(x.ref89a293f3.viewMask)
	x.InputAttachmentCount = (uint32)(x.ref89a293f3.inputAttachmentCount)
	packSAttachmentReference2(x.PInputAttachments, x.ref89a293f3.pInputAttachments)
	x.ColorAttachmentCount = (uint32)(x.ref89a293f3.colorAttachmentCount)
	packSAttachmentReference2(x.PColorAttachments, x.ref89a293f3.pColorAttachments)
	packSAttachmentReference2(x.PResolveAttachments, x.ref89a293f3.pResolveAttachments)
	packSAttachmentReference2(x.PDepthStencilAttachment, x.ref89a293f3.pDepthStencilAttachment)
	x.PreserveAttachmentCount = (uint32)(x.ref89a293f3.preserveAttachmentCount)
	hxf09ea94 := (*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments))
	hxf09ea94.Data = unsafe.Pointer(x.ref89a293f3.pPreserveAttachments)
	hxf09ea94.Cap = 0x7fffffff
	// hxf09ea94.Len = ?

}

// allocSubpassDependency2Memory allocates memory for type C.VkSubpassDependency2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDependency2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDependency2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassDependency2Value = unsafe.Sizeof([1]C.VkSubpassDependency2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassDependency2) Ref() *C.VkSubpassDependency2KHR {
	if x == nil {
		return nil
	}
	return x.ref985e0998
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassDependency2) Free() {
	if x != nil && x.allocs985e0998 != nil {
		x.allocs985e0998.(*cgoAllocMap).Free()
		x.ref985e0998 = nil
	}
}

// NewSubpassDependency2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassDependency2Ref(ref unsafe.Pointer) *SubpassDependency2 {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDependency2)
	obj.ref985e0998 = (*C.VkSubpassDependency2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassDependency2) PassRef() (*C.VkSubpassDependency2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref985e0998 != nil {
		return x.ref985e0998, nil
	}
	mem985e0998 := allocSubpassDependency2Memory(1)
	ref985e0998 := (*C.VkSubpassDependency2KHR)(mem985e0998)
	allocs985e0998 := new(cgoAllocMap)
	allocs985e0998.Add(mem985e0998)

	var csType_allocs *cgoAllocMap
	ref985e0998.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs985e0998.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref985e0998.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs985e0998.Borrow(cpNext_allocs)

	var csrcSubpass_allocs *cgoAllocMap
	ref985e0998.srcSubpass, csrcSubpass_allocs = (C.uint32_t)(x.SrcSubpass), cgoAllocsUnknown
	allocs985e0998.Borrow(csrcSubpass_allocs)

	var cdstSubpass_allocs *cgoAllocMap
	ref985e0998.dstSubpass, cdstSubpass_allocs = (C.uint32_t)(x.DstSubpass), cgoAllocsUnknown
	allocs985e0998.Borrow(cdstSubpass_allocs)

	var csrcStageMask_allocs *cgoAllocMap
	ref985e0998.srcStageMask, csrcStageMask_allocs = (C.VkPipelineStageFlags)(x.SrcStageMask), cgoAllocsUnknown
	allocs985e0998.Borrow(csrcStageMask_allocs)

	var cdstStageMask_allocs *cgoAllocMap
	ref985e0998.dstStageMask, cdstStageMask_allocs = (C.VkPipelineStageFlags)(x.DstStageMask), cgoAllocsUnknown
	allocs985e0998.Borrow(cdstStageMask_allocs)

	var csrcAccessMask_allocs *cgoAllocMap
	ref985e0998.srcAccessMask, csrcAccessMask_allocs = (C.VkAccessFlags)(x.SrcAccessMask), cgoAllocsUnknown
	allocs985e0998.Borrow(csrcAccessMask_allocs)

	var cdstAccessMask_allocs *cgoAllocMap
	ref985e0998.dstAccessMask, cdstAccessMask_allocs = (C.VkAccessFlags)(x.DstAccessMask), cgoAllocsUnknown
	allocs985e0998.Borrow(cdstAccessMask_allocs)

	var cdependencyFlags_allocs *cgoAllocMap
	ref985e0998.dependencyFlags, cdependencyFlags_allocs = (C.VkDependencyFlags)(x.DependencyFlags), cgoAllocsUnknown
	allocs985e0998.Borrow(cdependencyFlags_allocs)

	var cviewOffset_allocs *cgoAllocMap
	ref985e0998.viewOffset, cviewOffset_allocs = (C.int32_t)(x.ViewOffset), cgoAllocsUnknown
	allocs985e0998.Borrow(cviewOffset_allocs)

	x.ref985e0998 = ref985e0998
	x.allocs985e0998 = allocs985e0998
	return ref985e0998, allocs985e0998

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassDependency2) PassValue() (C.VkSubpassDependency2KHR, *cgoAllocMap) {
	if x.ref985e0998 != nil {
		return *x.ref985e0998, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassDependency2) Deref() {
	if x.ref985e0998 == nil {
		return
	}
	x.SType = (StructureType)(x.ref985e0998.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref985e0998.pNext))
	x.SrcSubpass = (uint32)(x.ref985e0998.srcSubpass)
	x.DstSubpass = (uint32)(x.ref985e0998.dstSubpass)
	x.SrcStageMask = (PipelineStageFlags)(x.ref985e0998.srcStageMask)
	x.DstStageMask = (PipelineStageFlags)(x.ref985e0998.dstStageMask)
	x.SrcAccessMask = (AccessFlags)(x.ref985e0998.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.ref985e0998.dstAccessMask)
	x.DependencyFlags = (DependencyFlags)(x.ref985e0998.dependencyFlags)
	x.ViewOffset = (int32)(x.ref985e0998.viewOffset)
}

// allocRenderPassCreateInfo2Memory allocates memory for type C.VkRenderPassCreateInfo2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassCreateInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassCreateInfo2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderPassCreateInfo2Value = unsafe.Sizeof([1]C.VkRenderPassCreateInfo2KHR{})

// unpackSAttachmentDescription2 transforms a sliced Go data structure into plain C format.
func unpackSAttachmentDescription2(x []AttachmentDescription2) (unpacked *C.VkAttachmentDescription2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkAttachmentDescription2KHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentDescription2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentDescription2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentDescription2KHR)(h.Data)
	return
}

// unpackSSubpassDescription2 transforms a sliced Go data structure into plain C format.
func unpackSSubpassDescription2(x []SubpassDescription2) (unpacked *C.VkSubpassDescription2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubpassDescription2KHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDescription2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDescription2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDescription2KHR)(h.Data)
	return
}

// unpackSSubpassDependency2 transforms a sliced Go data structure into plain C format.
func unpackSSubpassDependency2(x []SubpassDependency2) (unpacked *C.VkSubpassDependency2KHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubpassDependency2KHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDependency2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDependency2KHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDependency2KHR)(h.Data)
	return
}

// packSAttachmentDescription2 reads sliced Go data structure out from plain C format.
func packSAttachmentDescription2(v []AttachmentDescription2, ptr0 *C.VkAttachmentDescription2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentDescription2Value]C.VkAttachmentDescription2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentDescription2Ref(unsafe.Pointer(&ptr1))
	}
}

// packSSubpassDescription2 reads sliced Go data structure out from plain C format.
func packSSubpassDescription2(v []SubpassDescription2, ptr0 *C.VkSubpassDescription2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDescription2Value]C.VkSubpassDescription2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDescription2Ref(unsafe.Pointer(&ptr1))
	}
}

// packSSubpassDependency2 reads sliced Go data structure out from plain C format.
func packSSubpassDependency2(v []SubpassDependency2, ptr0 *C.VkSubpassDependency2KHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDependency2Value]C.VkSubpassDependency2KHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDependency2Ref(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassCreateInfo2) Ref() *C.VkRenderPassCreateInfo2KHR {
	if x == nil {
		return nil
	}
	return x.ref1d4774de
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassCreateInfo2) Free() {
	if x != nil && x.allocs1d4774de != nil {
		x.allocs1d4774de.(*cgoAllocMap).Free()
		x.ref1d4774de = nil
	}
}

// NewRenderPassCreateInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassCreateInfo2Ref(ref unsafe.Pointer) *RenderPassCreateInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassCreateInfo2)
	obj.ref1d4774de = (*C.VkRenderPassCreateInfo2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassCreateInfo2) PassRef() (*C.VkRenderPassCreateInfo2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d4774de != nil {
		return x.ref1d4774de, nil
	}
	mem1d4774de := allocRenderPassCreateInfo2Memory(1)
	ref1d4774de := (*C.VkRenderPassCreateInfo2KHR)(mem1d4774de)
	allocs1d4774de := new(cgoAllocMap)
	allocs1d4774de.Add(mem1d4774de)

	var csType_allocs *cgoAllocMap
	ref1d4774de.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1d4774de.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1d4774de.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1d4774de.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref1d4774de.flags, cflags_allocs = (C.VkRenderPassCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs1d4774de.Borrow(cflags_allocs)

	var cattachmentCount_allocs *cgoAllocMap
	ref1d4774de.attachmentCount, cattachmentCount_allocs = (C.uint32_t)(x.AttachmentCount), cgoAllocsUnknown
	allocs1d4774de.Borrow(cattachmentCount_allocs)

	var cpAttachments_allocs *cgoAllocMap
	ref1d4774de.pAttachments, cpAttachments_allocs = unpackSAttachmentDescription2(x.PAttachments)
	allocs1d4774de.Borrow(cpAttachments_allocs)

	var csubpassCount_allocs *cgoAllocMap
	ref1d4774de.subpassCount, csubpassCount_allocs = (C.uint32_t)(x.SubpassCount), cgoAllocsUnknown
	allocs1d4774de.Borrow(csubpassCount_allocs)

	var cpSubpasses_allocs *cgoAllocMap
	ref1d4774de.pSubpasses, cpSubpasses_allocs = unpackSSubpassDescription2(x.PSubpasses)
	allocs1d4774de.Borrow(cpSubpasses_allocs)

	var cdependencyCount_allocs *cgoAllocMap
	ref1d4774de.dependencyCount, cdependencyCount_allocs = (C.uint32_t)(x.DependencyCount), cgoAllocsUnknown
	allocs1d4774de.Borrow(cdependencyCount_allocs)

	var cpDependencies_allocs *cgoAllocMap
	ref1d4774de.pDependencies, cpDependencies_allocs = unpackSSubpassDependency2(x.PDependencies)
	allocs1d4774de.Borrow(cpDependencies_allocs)

	var ccorrelatedViewMaskCount_allocs *cgoAllocMap
	ref1d4774de.correlatedViewMaskCount, ccorrelatedViewMaskCount_allocs = (C.uint32_t)(x.CorrelatedViewMaskCount), cgoAllocsUnknown
	allocs1d4774de.Borrow(ccorrelatedViewMaskCount_allocs)

	var cpCorrelatedViewMasks_allocs *cgoAllocMap
	ref1d4774de.pCorrelatedViewMasks, cpCorrelatedViewMasks_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCorrelatedViewMasks)).Data)), cgoAllocsUnknown
	allocs1d4774de.Borrow(cpCorrelatedViewMasks_allocs)

	x.ref1d4774de = ref1d4774de
	x.allocs1d4774de = allocs1d4774de
	return ref1d4774de, allocs1d4774de

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassCreateInfo2) PassValue() (C.VkRenderPassCreateInfo2KHR, *cgoAllocMap) {
	if x.ref1d4774de != nil {
		return *x.ref1d4774de, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassCreateInfo2) Deref() {
	if x.ref1d4774de == nil {
		return
	}
	x.SType = (StructureType)(x.ref1d4774de.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1d4774de.pNext))
	x.Flags = (RenderPassCreateFlags)(x.ref1d4774de.flags)
	x.AttachmentCount = (uint32)(x.ref1d4774de.attachmentCount)
	packSAttachmentDescription2(x.PAttachments, x.ref1d4774de.pAttachments)
	x.SubpassCount = (uint32)(x.ref1d4774de.subpassCount)
	packSSubpassDescription2(x.PSubpasses, x.ref1d4774de.pSubpasses)
	x.DependencyCount = (uint32)(x.ref1d4774de.dependencyCount)
	packSSubpassDependency2(x.PDependencies, x.ref1d4774de.pDependencies)
	x.CorrelatedViewMaskCount = (uint32)(x.ref1d4774de.correlatedViewMaskCount)
	hxfd687ee := (*sliceHeader)(unsafe.Pointer(&x.PCorrelatedViewMasks))
	hxfd687ee.Data = unsafe.Pointer(x.ref1d4774de.pCorrelatedViewMasks)
	hxfd687ee.Cap = 0x7fffffff
	// hxfd687ee.Len = ?

}

// allocSubpassBeginInfoMemory allocates memory for type C.VkSubpassBeginInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassBeginInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassBeginInfoValue = unsafe.Sizeof([1]C.VkSubpassBeginInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassBeginInfo) Ref() *C.VkSubpassBeginInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref7b9f19b8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassBeginInfo) Free() {
	if x != nil && x.allocs7b9f19b8 != nil {
		x.allocs7b9f19b8.(*cgoAllocMap).Free()
		x.ref7b9f19b8 = nil
	}
}

// NewSubpassBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassBeginInfoRef(ref unsafe.Pointer) *SubpassBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(SubpassBeginInfo)
	obj.ref7b9f19b8 = (*C.VkSubpassBeginInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassBeginInfo) PassRef() (*C.VkSubpassBeginInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7b9f19b8 != nil {
		return x.ref7b9f19b8, nil
	}
	mem7b9f19b8 := allocSubpassBeginInfoMemory(1)
	ref7b9f19b8 := (*C.VkSubpassBeginInfoKHR)(mem7b9f19b8)
	allocs7b9f19b8 := new(cgoAllocMap)
	allocs7b9f19b8.Add(mem7b9f19b8)

	var csType_allocs *cgoAllocMap
	ref7b9f19b8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7b9f19b8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7b9f19b8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7b9f19b8.Borrow(cpNext_allocs)

	var ccontents_allocs *cgoAllocMap
	ref7b9f19b8.contents, ccontents_allocs = (C.VkSubpassContents)(x.Contents), cgoAllocsUnknown
	allocs7b9f19b8.Borrow(ccontents_allocs)

	x.ref7b9f19b8 = ref7b9f19b8
	x.allocs7b9f19b8 = allocs7b9f19b8
	return ref7b9f19b8, allocs7b9f19b8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassBeginInfo) PassValue() (C.VkSubpassBeginInfoKHR, *cgoAllocMap) {
	if x.ref7b9f19b8 != nil {
		return *x.ref7b9f19b8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassBeginInfo) Deref() {
	if x.ref7b9f19b8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7b9f19b8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7b9f19b8.pNext))
	x.Contents = (SubpassContents)(x.ref7b9f19b8.contents)
}

// allocSubpassEndInfoMemory allocates memory for type C.VkSubpassEndInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassEndInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassEndInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassEndInfoValue = unsafe.Sizeof([1]C.VkSubpassEndInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassEndInfo) Ref() *C.VkSubpassEndInfoKHR {
	if x == nil {
		return nil
	}
	return x.refb755d027
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassEndInfo) Free() {
	if x != nil && x.allocsb755d027 != nil {
		x.allocsb755d027.(*cgoAllocMap).Free()
		x.refb755d027 = nil
	}
}

// NewSubpassEndInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassEndInfoRef(ref unsafe.Pointer) *SubpassEndInfo {
	if ref == nil {
		return nil
	}
	obj := new(SubpassEndInfo)
	obj.refb755d027 = (*C.VkSubpassEndInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassEndInfo) PassRef() (*C.VkSubpassEndInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb755d027 != nil {
		return x.refb755d027, nil
	}
	memb755d027 := allocSubpassEndInfoMemory(1)
	refb755d027 := (*C.VkSubpassEndInfoKHR)(memb755d027)
	allocsb755d027 := new(cgoAllocMap)
	allocsb755d027.Add(memb755d027)

	var csType_allocs *cgoAllocMap
	refb755d027.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb755d027.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb755d027.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb755d027.Borrow(cpNext_allocs)

	x.refb755d027 = refb755d027
	x.allocsb755d027 = allocsb755d027
	return refb755d027, allocsb755d027

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassEndInfo) PassValue() (C.VkSubpassEndInfoKHR, *cgoAllocMap) {
	if x.refb755d027 != nil {
		return *x.refb755d027, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassEndInfo) Deref() {
	if x.refb755d027 == nil {
		return
	}
	x.SType = (StructureType)(x.refb755d027.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb755d027.pNext))
}

// allocSharedPresentSurfaceCapabilitiesMemory allocates memory for type C.VkSharedPresentSurfaceCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSharedPresentSurfaceCapabilitiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSharedPresentSurfaceCapabilitiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSharedPresentSurfaceCapabilitiesValue = unsafe.Sizeof([1]C.VkSharedPresentSurfaceCapabilitiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SharedPresentSurfaceCapabilities) Ref() *C.VkSharedPresentSurfaceCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.ref3f98a814
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SharedPresentSurfaceCapabilities) Free() {
	if x != nil && x.allocs3f98a814 != nil {
		x.allocs3f98a814.(*cgoAllocMap).Free()
		x.ref3f98a814 = nil
	}
}

// NewSharedPresentSurfaceCapabilitiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSharedPresentSurfaceCapabilitiesRef(ref unsafe.Pointer) *SharedPresentSurfaceCapabilities {
	if ref == nil {
		return nil
	}
	obj := new(SharedPresentSurfaceCapabilities)
	obj.ref3f98a814 = (*C.VkSharedPresentSurfaceCapabilitiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SharedPresentSurfaceCapabilities) PassRef() (*C.VkSharedPresentSurfaceCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3f98a814 != nil {
		return x.ref3f98a814, nil
	}
	mem3f98a814 := allocSharedPresentSurfaceCapabilitiesMemory(1)
	ref3f98a814 := (*C.VkSharedPresentSurfaceCapabilitiesKHR)(mem3f98a814)
	allocs3f98a814 := new(cgoAllocMap)
	allocs3f98a814.Add(mem3f98a814)

	var csType_allocs *cgoAllocMap
	ref3f98a814.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3f98a814.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3f98a814.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3f98a814.Borrow(cpNext_allocs)

	var csharedPresentSupportedUsageFlags_allocs *cgoAllocMap
	ref3f98a814.sharedPresentSupportedUsageFlags, csharedPresentSupportedUsageFlags_allocs = (C.VkImageUsageFlags)(x.SharedPresentSupportedUsageFlags), cgoAllocsUnknown
	allocs3f98a814.Borrow(csharedPresentSupportedUsageFlags_allocs)

	x.ref3f98a814 = ref3f98a814
	x.allocs3f98a814 = allocs3f98a814
	return ref3f98a814, allocs3f98a814

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SharedPresentSurfaceCapabilities) PassValue() (C.VkSharedPresentSurfaceCapabilitiesKHR, *cgoAllocMap) {
	if x.ref3f98a814 != nil {
		return *x.ref3f98a814, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SharedPresentSurfaceCapabilities) Deref() {
	if x.ref3f98a814 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3f98a814.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3f98a814.pNext))
	x.SharedPresentSupportedUsageFlags = (ImageUsageFlags)(x.ref3f98a814.sharedPresentSupportedUsageFlags)
}

// allocImportFenceFdInfoMemory allocates memory for type C.VkImportFenceFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImportFenceFdInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImportFenceFdInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImportFenceFdInfoValue = unsafe.Sizeof([1]C.VkImportFenceFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImportFenceFdInfo) Ref() *C.VkImportFenceFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref86ebd28c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImportFenceFdInfo) Free() {
	if x != nil && x.allocs86ebd28c != nil {
		x.allocs86ebd28c.(*cgoAllocMap).Free()
		x.ref86ebd28c = nil
	}
}

// NewImportFenceFdInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImportFenceFdInfoRef(ref unsafe.Pointer) *ImportFenceFdInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImportFenceFdInfo)
	obj.ref86ebd28c = (*C.VkImportFenceFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImportFenceFdInfo) PassRef() (*C.VkImportFenceFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref86ebd28c != nil {
		return x.ref86ebd28c, nil
	}
	mem86ebd28c := allocImportFenceFdInfoMemory(1)
	ref86ebd28c := (*C.VkImportFenceFdInfoKHR)(mem86ebd28c)
	allocs86ebd28c := new(cgoAllocMap)
	allocs86ebd28c.Add(mem86ebd28c)

	var csType_allocs *cgoAllocMap
	ref86ebd28c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs86ebd28c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref86ebd28c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs86ebd28c.Borrow(cpNext_allocs)

	var cfence_allocs *cgoAllocMap
	ref86ebd28c.fence, cfence_allocs = *(*C.VkFence)(unsafe.Pointer(&x.Fence)), cgoAllocsUnknown
	allocs86ebd28c.Borrow(cfence_allocs)

	var cflags_allocs *cgoAllocMap
	ref86ebd28c.flags, cflags_allocs = (C.VkFenceImportFlags)(x.Flags), cgoAllocsUnknown
	allocs86ebd28c.Borrow(cflags_allocs)

	var chandleType_allocs *cgoAllocMap
	ref86ebd28c.handleType, chandleType_allocs = (C.VkExternalFenceHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocs86ebd28c.Borrow(chandleType_allocs)

	var cfd_allocs *cgoAllocMap
	ref86ebd28c.fd, cfd_allocs = (C.int)(x.Fd), cgoAllocsUnknown
	allocs86ebd28c.Borrow(cfd_allocs)

	x.ref86ebd28c = ref86ebd28c
	x.allocs86ebd28c = allocs86ebd28c
	return ref86ebd28c, allocs86ebd28c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImportFenceFdInfo) PassValue() (C.VkImportFenceFdInfoKHR, *cgoAllocMap) {
	if x.ref86ebd28c != nil {
		return *x.ref86ebd28c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImportFenceFdInfo) Deref() {
	if x.ref86ebd28c == nil {
		return
	}
	x.SType = (StructureType)(x.ref86ebd28c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref86ebd28c.pNext))
	x.Fence = *(*Fence)(unsafe.Pointer(&x.ref86ebd28c.fence))
	x.Flags = (FenceImportFlags)(x.ref86ebd28c.flags)
	x.HandleType = (ExternalFenceHandleTypeFlagBits)(x.ref86ebd28c.handleType)
	x.Fd = (int32)(x.ref86ebd28c.fd)
}

// allocFenceGetFdInfoMemory allocates memory for type C.VkFenceGetFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFenceGetFdInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFenceGetFdInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFenceGetFdInfoValue = unsafe.Sizeof([1]C.VkFenceGetFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FenceGetFdInfo) Ref() *C.VkFenceGetFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.refc2668bc3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FenceGetFdInfo) Free() {
	if x != nil && x.allocsc2668bc3 != nil {
		x.allocsc2668bc3.(*cgoAllocMap).Free()
		x.refc2668bc3 = nil
	}
}

// NewFenceGetFdInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFenceGetFdInfoRef(ref unsafe.Pointer) *FenceGetFdInfo {
	if ref == nil {
		return nil
	}
	obj := new(FenceGetFdInfo)
	obj.refc2668bc3 = (*C.VkFenceGetFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FenceGetFdInfo) PassRef() (*C.VkFenceGetFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc2668bc3 != nil {
		return x.refc2668bc3, nil
	}
	memc2668bc3 := allocFenceGetFdInfoMemory(1)
	refc2668bc3 := (*C.VkFenceGetFdInfoKHR)(memc2668bc3)
	allocsc2668bc3 := new(cgoAllocMap)
	allocsc2668bc3.Add(memc2668bc3)

	var csType_allocs *cgoAllocMap
	refc2668bc3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc2668bc3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc2668bc3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc2668bc3.Borrow(cpNext_allocs)

	var cfence_allocs *cgoAllocMap
	refc2668bc3.fence, cfence_allocs = *(*C.VkFence)(unsafe.Pointer(&x.Fence)), cgoAllocsUnknown
	allocsc2668bc3.Borrow(cfence_allocs)

	var chandleType_allocs *cgoAllocMap
	refc2668bc3.handleType, chandleType_allocs = (C.VkExternalFenceHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocsc2668bc3.Borrow(chandleType_allocs)

	x.refc2668bc3 = refc2668bc3
	x.allocsc2668bc3 = allocsc2668bc3
	return refc2668bc3, allocsc2668bc3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FenceGetFdInfo) PassValue() (C.VkFenceGetFdInfoKHR, *cgoAllocMap) {
	if x.refc2668bc3 != nil {
		return *x.refc2668bc3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FenceGetFdInfo) Deref() {
	if x.refc2668bc3 == nil {
		return
	}
	x.SType = (StructureType)(x.refc2668bc3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc2668bc3.pNext))
	x.Fence = *(*Fence)(unsafe.Pointer(&x.refc2668bc3.fence))
	x.HandleType = (ExternalFenceHandleTypeFlagBits)(x.refc2668bc3.handleType)
}

// allocPhysicalDeviceSurfaceInfo2Memory allocates memory for type C.VkPhysicalDeviceSurfaceInfo2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSurfaceInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSurfaceInfo2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceSurfaceInfo2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceSurfaceInfo2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSurfaceInfo2) Ref() *C.VkPhysicalDeviceSurfaceInfo2KHR {
	if x == nil {
		return nil
	}
	return x.refd22370ae
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSurfaceInfo2) Free() {
	if x != nil && x.allocsd22370ae != nil {
		x.allocsd22370ae.(*cgoAllocMap).Free()
		x.refd22370ae = nil
	}
}

// NewPhysicalDeviceSurfaceInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSurfaceInfo2Ref(ref unsafe.Pointer) *PhysicalDeviceSurfaceInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSurfaceInfo2)
	obj.refd22370ae = (*C.VkPhysicalDeviceSurfaceInfo2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSurfaceInfo2) PassRef() (*C.VkPhysicalDeviceSurfaceInfo2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd22370ae != nil {
		return x.refd22370ae, nil
	}
	memd22370ae := allocPhysicalDeviceSurfaceInfo2Memory(1)
	refd22370ae := (*C.VkPhysicalDeviceSurfaceInfo2KHR)(memd22370ae)
	allocsd22370ae := new(cgoAllocMap)
	allocsd22370ae.Add(memd22370ae)

	var csType_allocs *cgoAllocMap
	refd22370ae.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd22370ae.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd22370ae.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd22370ae.Borrow(cpNext_allocs)

	var csurface_allocs *cgoAllocMap
	refd22370ae.surface, csurface_allocs = *(*C.VkSurfaceKHR)(unsafe.Pointer(&x.Surface)), cgoAllocsUnknown
	allocsd22370ae.Borrow(csurface_allocs)

	x.refd22370ae = refd22370ae
	x.allocsd22370ae = allocsd22370ae
	return refd22370ae, allocsd22370ae

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSurfaceInfo2) PassValue() (C.VkPhysicalDeviceSurfaceInfo2KHR, *cgoAllocMap) {
	if x.refd22370ae != nil {
		return *x.refd22370ae, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSurfaceInfo2) Deref() {
	if x.refd22370ae == nil {
		return
	}
	x.SType = (StructureType)(x.refd22370ae.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd22370ae.pNext))
	x.Surface = *(*Surface)(unsafe.Pointer(&x.refd22370ae.surface))
}

// allocSurfaceCapabilities2Memory allocates memory for type C.VkSurfaceCapabilities2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceCapabilities2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceCapabilities2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSurfaceCapabilities2Value = unsafe.Sizeof([1]C.VkSurfaceCapabilities2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SurfaceCapabilities2) Ref() *C.VkSurfaceCapabilities2KHR {
	if x == nil {
		return nil
	}
	return x.refea469745
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SurfaceCapabilities2) Free() {
	if x != nil && x.allocsea469745 != nil {
		x.allocsea469745.(*cgoAllocMap).Free()
		x.refea469745 = nil
	}
}

// NewSurfaceCapabilities2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSurfaceCapabilities2Ref(ref unsafe.Pointer) *SurfaceCapabilities2 {
	if ref == nil {
		return nil
	}
	obj := new(SurfaceCapabilities2)
	obj.refea469745 = (*C.VkSurfaceCapabilities2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SurfaceCapabilities2) PassRef() (*C.VkSurfaceCapabilities2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refea469745 != nil {
		return x.refea469745, nil
	}
	memea469745 := allocSurfaceCapabilities2Memory(1)
	refea469745 := (*C.VkSurfaceCapabilities2KHR)(memea469745)
	allocsea469745 := new(cgoAllocMap)
	allocsea469745.Add(memea469745)

	var csType_allocs *cgoAllocMap
	refea469745.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsea469745.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refea469745.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsea469745.Borrow(cpNext_allocs)

	var csurfaceCapabilities_allocs *cgoAllocMap
	refea469745.surfaceCapabilities, csurfaceCapabilities_allocs = x.SurfaceCapabilities.PassValue()
	allocsea469745.Borrow(csurfaceCapabilities_allocs)

	x.refea469745 = refea469745
	x.allocsea469745 = allocsea469745
	return refea469745, allocsea469745

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SurfaceCapabilities2) PassValue() (C.VkSurfaceCapabilities2KHR, *cgoAllocMap) {
	if x.refea469745 != nil {
		return *x.refea469745, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SurfaceCapabilities2) Deref() {
	if x.refea469745 == nil {
		return
	}
	x.SType = (StructureType)(x.refea469745.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refea469745.pNext))
	x.SurfaceCapabilities = *NewSurfaceCapabilitiesRef(unsafe.Pointer(&x.refea469745.surfaceCapabilities))
}

// allocSurfaceFormat2Memory allocates memory for type C.VkSurfaceFormat2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceFormat2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceFormat2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSurfaceFormat2Value = unsafe.Sizeof([1]C.VkSurfaceFormat2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SurfaceFormat2) Ref() *C.VkSurfaceFormat2KHR {
	if x == nil {
		return nil
	}
	return x.ref8867f0ed
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SurfaceFormat2) Free() {
	if x != nil && x.allocs8867f0ed != nil {
		x.allocs8867f0ed.(*cgoAllocMap).Free()
		x.ref8867f0ed = nil
	}
}

// NewSurfaceFormat2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSurfaceFormat2Ref(ref unsafe.Pointer) *SurfaceFormat2 {
	if ref == nil {
		return nil
	}
	obj := new(SurfaceFormat2)
	obj.ref8867f0ed = (*C.VkSurfaceFormat2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SurfaceFormat2) PassRef() (*C.VkSurfaceFormat2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8867f0ed != nil {
		return x.ref8867f0ed, nil
	}
	mem8867f0ed := allocSurfaceFormat2Memory(1)
	ref8867f0ed := (*C.VkSurfaceFormat2KHR)(mem8867f0ed)
	allocs8867f0ed := new(cgoAllocMap)
	allocs8867f0ed.Add(mem8867f0ed)

	var csType_allocs *cgoAllocMap
	ref8867f0ed.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8867f0ed.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8867f0ed.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8867f0ed.Borrow(cpNext_allocs)

	var csurfaceFormat_allocs *cgoAllocMap
	ref8867f0ed.surfaceFormat, csurfaceFormat_allocs = x.SurfaceFormat.PassValue()
	allocs8867f0ed.Borrow(csurfaceFormat_allocs)

	x.ref8867f0ed = ref8867f0ed
	x.allocs8867f0ed = allocs8867f0ed
	return ref8867f0ed, allocs8867f0ed

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SurfaceFormat2) PassValue() (C.VkSurfaceFormat2KHR, *cgoAllocMap) {
	if x.ref8867f0ed != nil {
		return *x.ref8867f0ed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SurfaceFormat2) Deref() {
	if x.ref8867f0ed == nil {
		return
	}
	x.SType = (StructureType)(x.ref8867f0ed.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8867f0ed.pNext))
	x.SurfaceFormat = *NewSurfaceFormatRef(unsafe.Pointer(&x.ref8867f0ed.surfaceFormat))
}

// allocDisplayProperties2Memory allocates memory for type C.VkDisplayProperties2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayProperties2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayProperties2Value = unsafe.Sizeof([1]C.VkDisplayProperties2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayProperties2) Ref() *C.VkDisplayProperties2KHR {
	if x == nil {
		return nil
	}
	return x.ref80194833
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayProperties2) Free() {
	if x != nil && x.allocs80194833 != nil {
		x.allocs80194833.(*cgoAllocMap).Free()
		x.ref80194833 = nil
	}
}

// NewDisplayProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayProperties2Ref(ref unsafe.Pointer) *DisplayProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(DisplayProperties2)
	obj.ref80194833 = (*C.VkDisplayProperties2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayProperties2) PassRef() (*C.VkDisplayProperties2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref80194833 != nil {
		return x.ref80194833, nil
	}
	mem80194833 := allocDisplayProperties2Memory(1)
	ref80194833 := (*C.VkDisplayProperties2KHR)(mem80194833)
	allocs80194833 := new(cgoAllocMap)
	allocs80194833.Add(mem80194833)

	var csType_allocs *cgoAllocMap
	ref80194833.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs80194833.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref80194833.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs80194833.Borrow(cpNext_allocs)

	var cdisplayProperties_allocs *cgoAllocMap
	ref80194833.displayProperties, cdisplayProperties_allocs = x.DisplayProperties.PassValue()
	allocs80194833.Borrow(cdisplayProperties_allocs)

	x.ref80194833 = ref80194833
	x.allocs80194833 = allocs80194833
	return ref80194833, allocs80194833

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayProperties2) PassValue() (C.VkDisplayProperties2KHR, *cgoAllocMap) {
	if x.ref80194833 != nil {
		return *x.ref80194833, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayProperties2) Deref() {
	if x.ref80194833 == nil {
		return
	}
	x.SType = (StructureType)(x.ref80194833.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref80194833.pNext))
	x.DisplayProperties = *NewDisplayPropertiesRef(unsafe.Pointer(&x.ref80194833.displayProperties))
}

// allocDisplayPlaneProperties2Memory allocates memory for type C.VkDisplayPlaneProperties2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlaneProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlaneProperties2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPlaneProperties2Value = unsafe.Sizeof([1]C.VkDisplayPlaneProperties2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlaneProperties2) Ref() *C.VkDisplayPlaneProperties2KHR {
	if x == nil {
		return nil
	}
	return x.refa72b1e5b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlaneProperties2) Free() {
	if x != nil && x.allocsa72b1e5b != nil {
		x.allocsa72b1e5b.(*cgoAllocMap).Free()
		x.refa72b1e5b = nil
	}
}

// NewDisplayPlaneProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlaneProperties2Ref(ref unsafe.Pointer) *DisplayPlaneProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneProperties2)
	obj.refa72b1e5b = (*C.VkDisplayPlaneProperties2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlaneProperties2) PassRef() (*C.VkDisplayPlaneProperties2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa72b1e5b != nil {
		return x.refa72b1e5b, nil
	}
	mema72b1e5b := allocDisplayPlaneProperties2Memory(1)
	refa72b1e5b := (*C.VkDisplayPlaneProperties2KHR)(mema72b1e5b)
	allocsa72b1e5b := new(cgoAllocMap)
	allocsa72b1e5b.Add(mema72b1e5b)

	var csType_allocs *cgoAllocMap
	refa72b1e5b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa72b1e5b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa72b1e5b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa72b1e5b.Borrow(cpNext_allocs)

	var cdisplayPlaneProperties_allocs *cgoAllocMap
	refa72b1e5b.displayPlaneProperties, cdisplayPlaneProperties_allocs = x.DisplayPlaneProperties.PassValue()
	allocsa72b1e5b.Borrow(cdisplayPlaneProperties_allocs)

	x.refa72b1e5b = refa72b1e5b
	x.allocsa72b1e5b = allocsa72b1e5b
	return refa72b1e5b, allocsa72b1e5b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlaneProperties2) PassValue() (C.VkDisplayPlaneProperties2KHR, *cgoAllocMap) {
	if x.refa72b1e5b != nil {
		return *x.refa72b1e5b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlaneProperties2) Deref() {
	if x.refa72b1e5b == nil {
		return
	}
	x.SType = (StructureType)(x.refa72b1e5b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa72b1e5b.pNext))
	x.DisplayPlaneProperties = *NewDisplayPlanePropertiesRef(unsafe.Pointer(&x.refa72b1e5b.displayPlaneProperties))
}

// allocDisplayModeProperties2Memory allocates memory for type C.VkDisplayModeProperties2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModeProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModeProperties2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayModeProperties2Value = unsafe.Sizeof([1]C.VkDisplayModeProperties2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayModeProperties2) Ref() *C.VkDisplayModeProperties2KHR {
	if x == nil {
		return nil
	}
	return x.refc566048d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayModeProperties2) Free() {
	if x != nil && x.allocsc566048d != nil {
		x.allocsc566048d.(*cgoAllocMap).Free()
		x.refc566048d = nil
	}
}

// NewDisplayModeProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayModeProperties2Ref(ref unsafe.Pointer) *DisplayModeProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(DisplayModeProperties2)
	obj.refc566048d = (*C.VkDisplayModeProperties2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayModeProperties2) PassRef() (*C.VkDisplayModeProperties2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc566048d != nil {
		return x.refc566048d, nil
	}
	memc566048d := allocDisplayModeProperties2Memory(1)
	refc566048d := (*C.VkDisplayModeProperties2KHR)(memc566048d)
	allocsc566048d := new(cgoAllocMap)
	allocsc566048d.Add(memc566048d)

	var csType_allocs *cgoAllocMap
	refc566048d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc566048d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc566048d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc566048d.Borrow(cpNext_allocs)

	var cdisplayModeProperties_allocs *cgoAllocMap
	refc566048d.displayModeProperties, cdisplayModeProperties_allocs = x.DisplayModeProperties.PassValue()
	allocsc566048d.Borrow(cdisplayModeProperties_allocs)

	x.refc566048d = refc566048d
	x.allocsc566048d = allocsc566048d
	return refc566048d, allocsc566048d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayModeProperties2) PassValue() (C.VkDisplayModeProperties2KHR, *cgoAllocMap) {
	if x.refc566048d != nil {
		return *x.refc566048d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayModeProperties2) Deref() {
	if x.refc566048d == nil {
		return
	}
	x.SType = (StructureType)(x.refc566048d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc566048d.pNext))
	x.DisplayModeProperties = *NewDisplayModePropertiesRef(unsafe.Pointer(&x.refc566048d.displayModeProperties))
}

// allocDisplayPlaneInfo2Memory allocates memory for type C.VkDisplayPlaneInfo2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlaneInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlaneInfo2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPlaneInfo2Value = unsafe.Sizeof([1]C.VkDisplayPlaneInfo2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlaneInfo2) Ref() *C.VkDisplayPlaneInfo2KHR {
	if x == nil {
		return nil
	}
	return x.reff355ccbf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlaneInfo2) Free() {
	if x != nil && x.allocsf355ccbf != nil {
		x.allocsf355ccbf.(*cgoAllocMap).Free()
		x.reff355ccbf = nil
	}
}

// NewDisplayPlaneInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlaneInfo2Ref(ref unsafe.Pointer) *DisplayPlaneInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneInfo2)
	obj.reff355ccbf = (*C.VkDisplayPlaneInfo2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlaneInfo2) PassRef() (*C.VkDisplayPlaneInfo2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff355ccbf != nil {
		return x.reff355ccbf, nil
	}
	memf355ccbf := allocDisplayPlaneInfo2Memory(1)
	reff355ccbf := (*C.VkDisplayPlaneInfo2KHR)(memf355ccbf)
	allocsf355ccbf := new(cgoAllocMap)
	allocsf355ccbf.Add(memf355ccbf)

	var csType_allocs *cgoAllocMap
	reff355ccbf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf355ccbf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff355ccbf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf355ccbf.Borrow(cpNext_allocs)

	var cmode_allocs *cgoAllocMap
	reff355ccbf.mode, cmode_allocs = *(*C.VkDisplayModeKHR)(unsafe.Pointer(&x.Mode)), cgoAllocsUnknown
	allocsf355ccbf.Borrow(cmode_allocs)

	var cplaneIndex_allocs *cgoAllocMap
	reff355ccbf.planeIndex, cplaneIndex_allocs = (C.uint32_t)(x.PlaneIndex), cgoAllocsUnknown
	allocsf355ccbf.Borrow(cplaneIndex_allocs)

	x.reff355ccbf = reff355ccbf
	x.allocsf355ccbf = allocsf355ccbf
	return reff355ccbf, allocsf355ccbf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlaneInfo2) PassValue() (C.VkDisplayPlaneInfo2KHR, *cgoAllocMap) {
	if x.reff355ccbf != nil {
		return *x.reff355ccbf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlaneInfo2) Deref() {
	if x.reff355ccbf == nil {
		return
	}
	x.SType = (StructureType)(x.reff355ccbf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff355ccbf.pNext))
	x.Mode = *(*DisplayMode)(unsafe.Pointer(&x.reff355ccbf.mode))
	x.PlaneIndex = (uint32)(x.reff355ccbf.planeIndex)
}

// allocDisplayPlaneCapabilities2Memory allocates memory for type C.VkDisplayPlaneCapabilities2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlaneCapabilities2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlaneCapabilities2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPlaneCapabilities2Value = unsafe.Sizeof([1]C.VkDisplayPlaneCapabilities2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlaneCapabilities2) Ref() *C.VkDisplayPlaneCapabilities2KHR {
	if x == nil {
		return nil
	}
	return x.refb53dfb44
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlaneCapabilities2) Free() {
	if x != nil && x.allocsb53dfb44 != nil {
		x.allocsb53dfb44.(*cgoAllocMap).Free()
		x.refb53dfb44 = nil
	}
}

// NewDisplayPlaneCapabilities2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlaneCapabilities2Ref(ref unsafe.Pointer) *DisplayPlaneCapabilities2 {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneCapabilities2)
	obj.refb53dfb44 = (*C.VkDisplayPlaneCapabilities2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlaneCapabilities2) PassRef() (*C.VkDisplayPlaneCapabilities2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb53dfb44 != nil {
		return x.refb53dfb44, nil
	}
	memb53dfb44 := allocDisplayPlaneCapabilities2Memory(1)
	refb53dfb44 := (*C.VkDisplayPlaneCapabilities2KHR)(memb53dfb44)
	allocsb53dfb44 := new(cgoAllocMap)
	allocsb53dfb44.Add(memb53dfb44)

	var csType_allocs *cgoAllocMap
	refb53dfb44.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb53dfb44.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb53dfb44.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb53dfb44.Borrow(cpNext_allocs)

	var ccapabilities_allocs *cgoAllocMap
	refb53dfb44.capabilities, ccapabilities_allocs = x.Capabilities.PassValue()
	allocsb53dfb44.Borrow(ccapabilities_allocs)

	x.refb53dfb44 = refb53dfb44
	x.allocsb53dfb44 = allocsb53dfb44
	return refb53dfb44, allocsb53dfb44

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlaneCapabilities2) PassValue() (C.VkDisplayPlaneCapabilities2KHR, *cgoAllocMap) {
	if x.refb53dfb44 != nil {
		return *x.refb53dfb44, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlaneCapabilities2) Deref() {
	if x.refb53dfb44 == nil {
		return
	}
	x.SType = (StructureType)(x.refb53dfb44.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb53dfb44.pNext))
	x.Capabilities = *NewDisplayPlaneCapabilitiesRef(unsafe.Pointer(&x.refb53dfb44.capabilities))
}

// allocImageFormatListCreateInfoMemory allocates memory for type C.VkImageFormatListCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageFormatListCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageFormatListCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageFormatListCreateInfoValue = unsafe.Sizeof([1]C.VkImageFormatListCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageFormatListCreateInfo) Ref() *C.VkImageFormatListCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref815daf8c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageFormatListCreateInfo) Free() {
	if x != nil && x.allocs815daf8c != nil {
		x.allocs815daf8c.(*cgoAllocMap).Free()
		x.ref815daf8c = nil
	}
}

// NewImageFormatListCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageFormatListCreateInfoRef(ref unsafe.Pointer) *ImageFormatListCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageFormatListCreateInfo)
	obj.ref815daf8c = (*C.VkImageFormatListCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageFormatListCreateInfo) PassRef() (*C.VkImageFormatListCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref815daf8c != nil {
		return x.ref815daf8c, nil
	}
	mem815daf8c := allocImageFormatListCreateInfoMemory(1)
	ref815daf8c := (*C.VkImageFormatListCreateInfoKHR)(mem815daf8c)
	allocs815daf8c := new(cgoAllocMap)
	allocs815daf8c.Add(mem815daf8c)

	var csType_allocs *cgoAllocMap
	ref815daf8c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs815daf8c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref815daf8c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs815daf8c.Borrow(cpNext_allocs)

	var cviewFormatCount_allocs *cgoAllocMap
	ref815daf8c.viewFormatCount, cviewFormatCount_allocs = (C.uint32_t)(x.ViewFormatCount), cgoAllocsUnknown
	allocs815daf8c.Borrow(cviewFormatCount_allocs)

	var cpViewFormats_allocs *cgoAllocMap
	ref815daf8c.pViewFormats, cpViewFormats_allocs = (*C.VkFormat)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PViewFormats)).Data)), cgoAllocsUnknown
	allocs815daf8c.Borrow(cpViewFormats_allocs)

	x.ref815daf8c = ref815daf8c
	x.allocs815daf8c = allocs815daf8c
	return ref815daf8c, allocs815daf8c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageFormatListCreateInfo) PassValue() (C.VkImageFormatListCreateInfoKHR, *cgoAllocMap) {
	if x.ref815daf8c != nil {
		return *x.ref815daf8c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageFormatListCreateInfo) Deref() {
	if x.ref815daf8c == nil {
		return
	}
	x.SType = (StructureType)(x.ref815daf8c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref815daf8c.pNext))
	x.ViewFormatCount = (uint32)(x.ref815daf8c.viewFormatCount)
	hxf15a567 := (*sliceHeader)(unsafe.Pointer(&x.PViewFormats))
	hxf15a567.Data = unsafe.Pointer(x.ref815daf8c.pViewFormats)
	hxf15a567.Cap = 0x7fffffff
	// hxf15a567.Len = ?

}

// allocPhysicalDevice8BitStorageFeaturesMemory allocates memory for type C.VkPhysicalDevice8BitStorageFeaturesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevice8BitStorageFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevice8BitStorageFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDevice8BitStorageFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDevice8BitStorageFeaturesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevice8BitStorageFeatures) Ref() *C.VkPhysicalDevice8BitStorageFeaturesKHR {
	if x == nil {
		return nil
	}
	return x.ref906ef48e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevice8BitStorageFeatures) Free() {
	if x != nil && x.allocs906ef48e != nil {
		x.allocs906ef48e.(*cgoAllocMap).Free()
		x.ref906ef48e = nil
	}
}

// NewPhysicalDevice8BitStorageFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevice8BitStorageFeaturesRef(ref unsafe.Pointer) *PhysicalDevice8BitStorageFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevice8BitStorageFeatures)
	obj.ref906ef48e = (*C.VkPhysicalDevice8BitStorageFeaturesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevice8BitStorageFeatures) PassRef() (*C.VkPhysicalDevice8BitStorageFeaturesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref906ef48e != nil {
		return x.ref906ef48e, nil
	}
	mem906ef48e := allocPhysicalDevice8BitStorageFeaturesMemory(1)
	ref906ef48e := (*C.VkPhysicalDevice8BitStorageFeaturesKHR)(mem906ef48e)
	allocs906ef48e := new(cgoAllocMap)
	allocs906ef48e.Add(mem906ef48e)

	var csType_allocs *cgoAllocMap
	ref906ef48e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs906ef48e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref906ef48e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs906ef48e.Borrow(cpNext_allocs)

	var cstorageBuffer8BitAccess_allocs *cgoAllocMap
	ref906ef48e.storageBuffer8BitAccess, cstorageBuffer8BitAccess_allocs = (C.VkBool32)(x.StorageBuffer8BitAccess), cgoAllocsUnknown
	allocs906ef48e.Borrow(cstorageBuffer8BitAccess_allocs)

	var cuniformAndStorageBuffer8BitAccess_allocs *cgoAllocMap
	ref906ef48e.uniformAndStorageBuffer8BitAccess, cuniformAndStorageBuffer8BitAccess_allocs = (C.VkBool32)(x.UniformAndStorageBuffer8BitAccess), cgoAllocsUnknown
	allocs906ef48e.Borrow(cuniformAndStorageBuffer8BitAccess_allocs)

	var cstoragePushConstant8_allocs *cgoAllocMap
	ref906ef48e.storagePushConstant8, cstoragePushConstant8_allocs = (C.VkBool32)(x.StoragePushConstant8), cgoAllocsUnknown
	allocs906ef48e.Borrow(cstoragePushConstant8_allocs)

	x.ref906ef48e = ref906ef48e
	x.allocs906ef48e = allocs906ef48e
	return ref906ef48e, allocs906ef48e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevice8BitStorageFeatures) PassValue() (C.VkPhysicalDevice8BitStorageFeaturesKHR, *cgoAllocMap) {
	if x.ref906ef48e != nil {
		return *x.ref906ef48e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevice8BitStorageFeatures) Deref() {
	if x.ref906ef48e == nil {
		return
	}
	x.SType = (StructureType)(x.ref906ef48e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref906ef48e.pNext))
	x.StorageBuffer8BitAccess = (Bool32)(x.ref906ef48e.storageBuffer8BitAccess)
	x.UniformAndStorageBuffer8BitAccess = (Bool32)(x.ref906ef48e.uniformAndStorageBuffer8BitAccess)
	x.StoragePushConstant8 = (Bool32)(x.ref906ef48e.storagePushConstant8)
}

// allocPhysicalDeviceShaderAtomicInt64FeaturesMemory allocates memory for type C.VkPhysicalDeviceShaderAtomicInt64FeaturesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderAtomicInt64FeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderAtomicInt64FeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceShaderAtomicInt64FeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderAtomicInt64FeaturesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderAtomicInt64Features) Ref() *C.VkPhysicalDeviceShaderAtomicInt64FeaturesKHR {
	if x == nil {
		return nil
	}
	return x.ref51c409c6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderAtomicInt64Features) Free() {
	if x != nil && x.allocs51c409c6 != nil {
		x.allocs51c409c6.(*cgoAllocMap).Free()
		x.ref51c409c6 = nil
	}
}

// NewPhysicalDeviceShaderAtomicInt64FeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderAtomicInt64FeaturesRef(ref unsafe.Pointer) *PhysicalDeviceShaderAtomicInt64Features {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderAtomicInt64Features)
	obj.ref51c409c6 = (*C.VkPhysicalDeviceShaderAtomicInt64FeaturesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderAtomicInt64Features) PassRef() (*C.VkPhysicalDeviceShaderAtomicInt64FeaturesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref51c409c6 != nil {
		return x.ref51c409c6, nil
	}
	mem51c409c6 := allocPhysicalDeviceShaderAtomicInt64FeaturesMemory(1)
	ref51c409c6 := (*C.VkPhysicalDeviceShaderAtomicInt64FeaturesKHR)(mem51c409c6)
	allocs51c409c6 := new(cgoAllocMap)
	allocs51c409c6.Add(mem51c409c6)

	var csType_allocs *cgoAllocMap
	ref51c409c6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs51c409c6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref51c409c6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs51c409c6.Borrow(cpNext_allocs)

	var cshaderBufferInt64Atomics_allocs *cgoAllocMap
	ref51c409c6.shaderBufferInt64Atomics, cshaderBufferInt64Atomics_allocs = (C.VkBool32)(x.ShaderBufferInt64Atomics), cgoAllocsUnknown
	allocs51c409c6.Borrow(cshaderBufferInt64Atomics_allocs)

	var cshaderSharedInt64Atomics_allocs *cgoAllocMap
	ref51c409c6.shaderSharedInt64Atomics, cshaderSharedInt64Atomics_allocs = (C.VkBool32)(x.ShaderSharedInt64Atomics), cgoAllocsUnknown
	allocs51c409c6.Borrow(cshaderSharedInt64Atomics_allocs)

	x.ref51c409c6 = ref51c409c6
	x.allocs51c409c6 = allocs51c409c6
	return ref51c409c6, allocs51c409c6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderAtomicInt64Features) PassValue() (C.VkPhysicalDeviceShaderAtomicInt64FeaturesKHR, *cgoAllocMap) {
	if x.ref51c409c6 != nil {
		return *x.ref51c409c6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderAtomicInt64Features) Deref() {
	if x.ref51c409c6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref51c409c6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref51c409c6.pNext))
	x.ShaderBufferInt64Atomics = (Bool32)(x.ref51c409c6.shaderBufferInt64Atomics)
	x.ShaderSharedInt64Atomics = (Bool32)(x.ref51c409c6.shaderSharedInt64Atomics)
}

// allocConformanceVersionMemory allocates memory for type C.VkConformanceVersionKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocConformanceVersionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfConformanceVersionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfConformanceVersionValue = unsafe.Sizeof([1]C.VkConformanceVersionKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConformanceVersion) Ref() *C.VkConformanceVersionKHR {
	if x == nil {
		return nil
	}
	return x.refe4627a5f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConformanceVersion) Free() {
	if x != nil && x.allocse4627a5f != nil {
		x.allocse4627a5f.(*cgoAllocMap).Free()
		x.refe4627a5f = nil
	}
}

// NewConformanceVersionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConformanceVersionRef(ref unsafe.Pointer) *ConformanceVersion {
	if ref == nil {
		return nil
	}
	obj := new(ConformanceVersion)
	obj.refe4627a5f = (*C.VkConformanceVersionKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConformanceVersion) PassRef() (*C.VkConformanceVersionKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe4627a5f != nil {
		return x.refe4627a5f, nil
	}
	meme4627a5f := allocConformanceVersionMemory(1)
	refe4627a5f := (*C.VkConformanceVersionKHR)(meme4627a5f)
	allocse4627a5f := new(cgoAllocMap)
	allocse4627a5f.Add(meme4627a5f)

	var cmajor_allocs *cgoAllocMap
	refe4627a5f.major, cmajor_allocs = (C.uint8_t)(x.Major), cgoAllocsUnknown
	allocse4627a5f.Borrow(cmajor_allocs)

	var cminor_allocs *cgoAllocMap
	refe4627a5f.minor, cminor_allocs = (C.uint8_t)(x.Minor), cgoAllocsUnknown
	allocse4627a5f.Borrow(cminor_allocs)

	var csubminor_allocs *cgoAllocMap
	refe4627a5f.subminor, csubminor_allocs = (C.uint8_t)(x.Subminor), cgoAllocsUnknown
	allocse4627a5f.Borrow(csubminor_allocs)

	var cpatch_allocs *cgoAllocMap
	refe4627a5f.patch, cpatch_allocs = (C.uint8_t)(x.Patch), cgoAllocsUnknown
	allocse4627a5f.Borrow(cpatch_allocs)

	x.refe4627a5f = refe4627a5f
	x.allocse4627a5f = allocse4627a5f
	return refe4627a5f, allocse4627a5f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConformanceVersion) PassValue() (C.VkConformanceVersionKHR, *cgoAllocMap) {
	if x.refe4627a5f != nil {
		return *x.refe4627a5f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConformanceVersion) Deref() {
	if x.refe4627a5f == nil {
		return
	}
	x.Major = (byte)(x.refe4627a5f.major)
	x.Minor = (byte)(x.refe4627a5f.minor)
	x.Subminor = (byte)(x.refe4627a5f.subminor)
	x.Patch = (byte)(x.refe4627a5f.patch)
}

// allocPhysicalDeviceDriverPropertiesMemory allocates memory for type C.VkPhysicalDeviceDriverPropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDriverPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDriverPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceDriverPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDriverPropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDriverProperties) Ref() *C.VkPhysicalDeviceDriverPropertiesKHR {
	if x == nil {
		return nil
	}
	return x.ref9220f954
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDriverProperties) Free() {
	if x != nil && x.allocs9220f954 != nil {
		x.allocs9220f954.(*cgoAllocMap).Free()
		x.ref9220f954 = nil
	}
}

// NewPhysicalDeviceDriverPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDriverPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceDriverProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDriverProperties)
	obj.ref9220f954 = (*C.VkPhysicalDeviceDriverPropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDriverProperties) PassRef() (*C.VkPhysicalDeviceDriverPropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9220f954 != nil {
		return x.ref9220f954, nil
	}
	mem9220f954 := allocPhysicalDeviceDriverPropertiesMemory(1)
	ref9220f954 := (*C.VkPhysicalDeviceDriverPropertiesKHR)(mem9220f954)
	allocs9220f954 := new(cgoAllocMap)
	allocs9220f954.Add(mem9220f954)

	var csType_allocs *cgoAllocMap
	ref9220f954.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9220f954.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9220f954.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9220f954.Borrow(cpNext_allocs)

	var cdriverID_allocs *cgoAllocMap
	ref9220f954.driverID, cdriverID_allocs = (C.VkDriverIdKHR)(x.DriverID), cgoAllocsUnknown
	allocs9220f954.Borrow(cdriverID_allocs)

	var cdriverName_allocs *cgoAllocMap
	ref9220f954.driverName, cdriverName_allocs = *(*[256]C.char)(unsafe.Pointer(&x.DriverName)), cgoAllocsUnknown
	allocs9220f954.Borrow(cdriverName_allocs)

	var cdriverInfo_allocs *cgoAllocMap
	ref9220f954.driverInfo, cdriverInfo_allocs = *(*[256]C.char)(unsafe.Pointer(&x.DriverInfo)), cgoAllocsUnknown
	allocs9220f954.Borrow(cdriverInfo_allocs)

	var cconformanceVersion_allocs *cgoAllocMap
	ref9220f954.conformanceVersion, cconformanceVersion_allocs = x.ConformanceVersion.PassValue()
	allocs9220f954.Borrow(cconformanceVersion_allocs)

	x.ref9220f954 = ref9220f954
	x.allocs9220f954 = allocs9220f954
	return ref9220f954, allocs9220f954

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDriverProperties) PassValue() (C.VkPhysicalDeviceDriverPropertiesKHR, *cgoAllocMap) {
	if x.ref9220f954 != nil {
		return *x.ref9220f954, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDriverProperties) Deref() {
	if x.ref9220f954 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9220f954.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9220f954.pNext))
	x.DriverID = (DriverId)(x.ref9220f954.driverID)
	x.DriverName = *(*[256]byte)(unsafe.Pointer(&x.ref9220f954.driverName))
	x.DriverInfo = *(*[256]byte)(unsafe.Pointer(&x.ref9220f954.driverInfo))
	x.ConformanceVersion = *NewConformanceVersionRef(unsafe.Pointer(&x.ref9220f954.conformanceVersion))
}

// allocPhysicalDeviceVulkanMemoryModelFeaturesMemory allocates memory for type C.VkPhysicalDeviceVulkanMemoryModelFeaturesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceVulkanMemoryModelFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceVulkanMemoryModelFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceVulkanMemoryModelFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceVulkanMemoryModelFeaturesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVulkanMemoryModelFeatures) Ref() *C.VkPhysicalDeviceVulkanMemoryModelFeaturesKHR {
	if x == nil {
		return nil
	}
	return x.ref2b17642b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVulkanMemoryModelFeatures) Free() {
	if x != nil && x.allocs2b17642b != nil {
		x.allocs2b17642b.(*cgoAllocMap).Free()
		x.ref2b17642b = nil
	}
}

// NewPhysicalDeviceVulkanMemoryModelFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVulkanMemoryModelFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceVulkanMemoryModelFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVulkanMemoryModelFeatures)
	obj.ref2b17642b = (*C.VkPhysicalDeviceVulkanMemoryModelFeaturesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVulkanMemoryModelFeatures) PassRef() (*C.VkPhysicalDeviceVulkanMemoryModelFeaturesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2b17642b != nil {
		return x.ref2b17642b, nil
	}
	mem2b17642b := allocPhysicalDeviceVulkanMemoryModelFeaturesMemory(1)
	ref2b17642b := (*C.VkPhysicalDeviceVulkanMemoryModelFeaturesKHR)(mem2b17642b)
	allocs2b17642b := new(cgoAllocMap)
	allocs2b17642b.Add(mem2b17642b)

	var csType_allocs *cgoAllocMap
	ref2b17642b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2b17642b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2b17642b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2b17642b.Borrow(cpNext_allocs)

	var cvulkanMemoryModel_allocs *cgoAllocMap
	ref2b17642b.vulkanMemoryModel, cvulkanMemoryModel_allocs = (C.VkBool32)(x.VulkanMemoryModel), cgoAllocsUnknown
	allocs2b17642b.Borrow(cvulkanMemoryModel_allocs)

	var cvulkanMemoryModelDeviceScope_allocs *cgoAllocMap
	ref2b17642b.vulkanMemoryModelDeviceScope, cvulkanMemoryModelDeviceScope_allocs = (C.VkBool32)(x.VulkanMemoryModelDeviceScope), cgoAllocsUnknown
	allocs2b17642b.Borrow(cvulkanMemoryModelDeviceScope_allocs)

	x.ref2b17642b = ref2b17642b
	x.allocs2b17642b = allocs2b17642b
	return ref2b17642b, allocs2b17642b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVulkanMemoryModelFeatures) PassValue() (C.VkPhysicalDeviceVulkanMemoryModelFeaturesKHR, *cgoAllocMap) {
	if x.ref2b17642b != nil {
		return *x.ref2b17642b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVulkanMemoryModelFeatures) Deref() {
	if x.ref2b17642b == nil {
		return
	}
	x.SType = (StructureType)(x.ref2b17642b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2b17642b.pNext))
	x.VulkanMemoryModel = (Bool32)(x.ref2b17642b.vulkanMemoryModel)
	x.VulkanMemoryModelDeviceScope = (Bool32)(x.ref2b17642b.vulkanMemoryModelDeviceScope)
}

func (x DebugReportCallbackFunc) PassRef() (ref *C.PFN_vkDebugReportCallbackEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if debugReportCallbackFuncC918AAC4Func == nil {
		debugReportCallbackFuncC918AAC4Func = x
	}
	return (*C.PFN_vkDebugReportCallbackEXT)(C.PFN_vkDebugReportCallbackEXT_c918aac4), nil
}

func (x DebugReportCallbackFunc) PassValue() (ref C.PFN_vkDebugReportCallbackEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if debugReportCallbackFuncC918AAC4Func == nil {
		debugReportCallbackFuncC918AAC4Func = x
	}
	return (C.PFN_vkDebugReportCallbackEXT)(C.PFN_vkDebugReportCallbackEXT_c918aac4), nil
}

func NewDebugReportCallbackFuncRef(ref unsafe.Pointer) *DebugReportCallbackFunc {
	return (*DebugReportCallbackFunc)(ref)
}

//export debugReportCallbackFuncC918AAC4
func debugReportCallbackFuncC918AAC4(cflags C.VkDebugReportFlagsEXT, cobjectType C.VkDebugReportObjectTypeEXT, cobject C.uint64_t, clocation C.size_t, cmessageCode C.int32_t, cpLayerPrefix *C.char, cpMessage *C.char, cpUserData unsafe.Pointer) C.VkBool32 {
	if debugReportCallbackFuncC918AAC4Func != nil {
		flagsc918aac4 := (DebugReportFlags)(cflags)
		objectTypec918aac4 := (DebugReportObjectType)(cobjectType)
		objectc918aac4 := (uint64)(cobject)
		locationc918aac4 := (uint64)(clocation)
		messageCodec918aac4 := (int32)(cmessageCode)
		pLayerPrefixc918aac4 := packPCharString(cpLayerPrefix)
		pMessagec918aac4 := packPCharString(cpMessage)
		pUserDatac918aac4 := (unsafe.Pointer)(unsafe.Pointer(cpUserData))
		retc918aac4 := debugReportCallbackFuncC918AAC4Func(flagsc918aac4, objectTypec918aac4, objectc918aac4, locationc918aac4, messageCodec918aac4, pLayerPrefixc918aac4, pMessagec918aac4, pUserDatac918aac4)
		ret, _ := (C.VkBool32)(retc918aac4), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var debugReportCallbackFuncC918AAC4Func DebugReportCallbackFunc

// allocDebugReportCallbackCreateInfoMemory allocates memory for type C.VkDebugReportCallbackCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugReportCallbackCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugReportCallbackCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugReportCallbackCreateInfoValue = unsafe.Sizeof([1]C.VkDebugReportCallbackCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugReportCallbackCreateInfo) Ref() *C.VkDebugReportCallbackCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refc8238563
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugReportCallbackCreateInfo) Free() {
	if x != nil && x.allocsc8238563 != nil {
		x.allocsc8238563.(*cgoAllocMap).Free()
		x.refc8238563 = nil
	}
}

// NewDebugReportCallbackCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugReportCallbackCreateInfoRef(ref unsafe.Pointer) *DebugReportCallbackCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DebugReportCallbackCreateInfo)
	obj.refc8238563 = (*C.VkDebugReportCallbackCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugReportCallbackCreateInfo) PassRef() (*C.VkDebugReportCallbackCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc8238563 != nil {
		return x.refc8238563, nil
	}
	memc8238563 := allocDebugReportCallbackCreateInfoMemory(1)
	refc8238563 := (*C.VkDebugReportCallbackCreateInfoEXT)(memc8238563)
	allocsc8238563 := new(cgoAllocMap)
	allocsc8238563.Add(memc8238563)

	var csType_allocs *cgoAllocMap
	refc8238563.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc8238563.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc8238563.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc8238563.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refc8238563.flags, cflags_allocs = (C.VkDebugReportFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocsc8238563.Borrow(cflags_allocs)

	var cpfnCallback_allocs *cgoAllocMap
	refc8238563.pfnCallback, cpfnCallback_allocs = x.PfnCallback.PassValue()
	allocsc8238563.Borrow(cpfnCallback_allocs)

	var cpUserData_allocs *cgoAllocMap
	refc8238563.pUserData, cpUserData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PUserData)), cgoAllocsUnknown
	allocsc8238563.Borrow(cpUserData_allocs)

	x.refc8238563 = refc8238563
	x.allocsc8238563 = allocsc8238563
	return refc8238563, allocsc8238563

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugReportCallbackCreateInfo) PassValue() (C.VkDebugReportCallbackCreateInfoEXT, *cgoAllocMap) {
	if x.refc8238563 != nil {
		return *x.refc8238563, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugReportCallbackCreateInfo) Deref() {
	if x.refc8238563 == nil {
		return
	}
	x.SType = (StructureType)(x.refc8238563.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc8238563.pNext))
	x.Flags = (DebugReportFlags)(x.refc8238563.flags)
	x.PfnCallback = *NewDebugReportCallbackFuncRef(unsafe.Pointer(&x.refc8238563.pfnCallback))
	x.PUserData = (unsafe.Pointer)(unsafe.Pointer(x.refc8238563.pUserData))
}

// allocPipelineRasterizationStateRasterizationOrderAMDMemory allocates memory for type C.VkPipelineRasterizationStateRasterizationOrderAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationStateRasterizationOrderAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationStateRasterizationOrderAMDValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineRasterizationStateRasterizationOrderAMDValue = unsafe.Sizeof([1]C.VkPipelineRasterizationStateRasterizationOrderAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineRasterizationStateRasterizationOrderAMD) Ref() *C.VkPipelineRasterizationStateRasterizationOrderAMD {
	if x == nil {
		return nil
	}
	return x.ref5098cf82
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineRasterizationStateRasterizationOrderAMD) Free() {
	if x != nil && x.allocs5098cf82 != nil {
		x.allocs5098cf82.(*cgoAllocMap).Free()
		x.ref5098cf82 = nil
	}
}

// NewPipelineRasterizationStateRasterizationOrderAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineRasterizationStateRasterizationOrderAMDRef(ref unsafe.Pointer) *PipelineRasterizationStateRasterizationOrderAMD {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRasterizationStateRasterizationOrderAMD)
	obj.ref5098cf82 = (*C.VkPipelineRasterizationStateRasterizationOrderAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineRasterizationStateRasterizationOrderAMD) PassRef() (*C.VkPipelineRasterizationStateRasterizationOrderAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5098cf82 != nil {
		return x.ref5098cf82, nil
	}
	mem5098cf82 := allocPipelineRasterizationStateRasterizationOrderAMDMemory(1)
	ref5098cf82 := (*C.VkPipelineRasterizationStateRasterizationOrderAMD)(mem5098cf82)
	allocs5098cf82 := new(cgoAllocMap)
	allocs5098cf82.Add(mem5098cf82)

	var csType_allocs *cgoAllocMap
	ref5098cf82.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5098cf82.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5098cf82.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5098cf82.Borrow(cpNext_allocs)

	var crasterizationOrder_allocs *cgoAllocMap
	ref5098cf82.rasterizationOrder, crasterizationOrder_allocs = (C.VkRasterizationOrderAMD)(x.RasterizationOrder), cgoAllocsUnknown
	allocs5098cf82.Borrow(crasterizationOrder_allocs)

	x.ref5098cf82 = ref5098cf82
	x.allocs5098cf82 = allocs5098cf82
	return ref5098cf82, allocs5098cf82

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineRasterizationStateRasterizationOrderAMD) PassValue() (C.VkPipelineRasterizationStateRasterizationOrderAMD, *cgoAllocMap) {
	if x.ref5098cf82 != nil {
		return *x.ref5098cf82, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineRasterizationStateRasterizationOrderAMD) Deref() {
	if x.ref5098cf82 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5098cf82.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5098cf82.pNext))
	x.RasterizationOrder = (RasterizationOrderAMD)(x.ref5098cf82.rasterizationOrder)
}

// allocDebugMarkerObjectNameInfoMemory allocates memory for type C.VkDebugMarkerObjectNameInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugMarkerObjectNameInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugMarkerObjectNameInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugMarkerObjectNameInfoValue = unsafe.Sizeof([1]C.VkDebugMarkerObjectNameInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugMarkerObjectNameInfo) Ref() *C.VkDebugMarkerObjectNameInfoEXT {
	if x == nil {
		return nil
	}
	return x.refe4983fab
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugMarkerObjectNameInfo) Free() {
	if x != nil && x.allocse4983fab != nil {
		x.allocse4983fab.(*cgoAllocMap).Free()
		x.refe4983fab = nil
	}
}

// NewDebugMarkerObjectNameInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugMarkerObjectNameInfoRef(ref unsafe.Pointer) *DebugMarkerObjectNameInfo {
	if ref == nil {
		return nil
	}
	obj := new(DebugMarkerObjectNameInfo)
	obj.refe4983fab = (*C.VkDebugMarkerObjectNameInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugMarkerObjectNameInfo) PassRef() (*C.VkDebugMarkerObjectNameInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe4983fab != nil {
		return x.refe4983fab, nil
	}
	meme4983fab := allocDebugMarkerObjectNameInfoMemory(1)
	refe4983fab := (*C.VkDebugMarkerObjectNameInfoEXT)(meme4983fab)
	allocse4983fab := new(cgoAllocMap)
	allocse4983fab.Add(meme4983fab)

	var csType_allocs *cgoAllocMap
	refe4983fab.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse4983fab.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe4983fab.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse4983fab.Borrow(cpNext_allocs)

	var cobjectType_allocs *cgoAllocMap
	refe4983fab.objectType, cobjectType_allocs = (C.VkDebugReportObjectTypeEXT)(x.ObjectType), cgoAllocsUnknown
	allocse4983fab.Borrow(cobjectType_allocs)

	var cobject_allocs *cgoAllocMap
	refe4983fab.object, cobject_allocs = (C.uint64_t)(x.Object), cgoAllocsUnknown
	allocse4983fab.Borrow(cobject_allocs)

	var cpObjectName_allocs *cgoAllocMap
	refe4983fab.pObjectName, cpObjectName_allocs = unpackPCharString(x.PObjectName)
	allocse4983fab.Borrow(cpObjectName_allocs)

	x.refe4983fab = refe4983fab
	x.allocse4983fab = allocse4983fab
	return refe4983fab, allocse4983fab

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugMarkerObjectNameInfo) PassValue() (C.VkDebugMarkerObjectNameInfoEXT, *cgoAllocMap) {
	if x.refe4983fab != nil {
		return *x.refe4983fab, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugMarkerObjectNameInfo) Deref() {
	if x.refe4983fab == nil {
		return
	}
	x.SType = (StructureType)(x.refe4983fab.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe4983fab.pNext))
	x.ObjectType = (DebugReportObjectType)(x.refe4983fab.objectType)
	x.Object = (uint64)(x.refe4983fab.object)
	x.PObjectName = packPCharString(x.refe4983fab.pObjectName)
}

// allocDebugMarkerObjectTagInfoMemory allocates memory for type C.VkDebugMarkerObjectTagInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugMarkerObjectTagInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugMarkerObjectTagInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugMarkerObjectTagInfoValue = unsafe.Sizeof([1]C.VkDebugMarkerObjectTagInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugMarkerObjectTagInfo) Ref() *C.VkDebugMarkerObjectTagInfoEXT {
	if x == nil {
		return nil
	}
	return x.refa41a5c3b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugMarkerObjectTagInfo) Free() {
	if x != nil && x.allocsa41a5c3b != nil {
		x.allocsa41a5c3b.(*cgoAllocMap).Free()
		x.refa41a5c3b = nil
	}
}

// NewDebugMarkerObjectTagInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugMarkerObjectTagInfoRef(ref unsafe.Pointer) *DebugMarkerObjectTagInfo {
	if ref == nil {
		return nil
	}
	obj := new(DebugMarkerObjectTagInfo)
	obj.refa41a5c3b = (*C.VkDebugMarkerObjectTagInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugMarkerObjectTagInfo) PassRef() (*C.VkDebugMarkerObjectTagInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa41a5c3b != nil {
		return x.refa41a5c3b, nil
	}
	mema41a5c3b := allocDebugMarkerObjectTagInfoMemory(1)
	refa41a5c3b := (*C.VkDebugMarkerObjectTagInfoEXT)(mema41a5c3b)
	allocsa41a5c3b := new(cgoAllocMap)
	allocsa41a5c3b.Add(mema41a5c3b)

	var csType_allocs *cgoAllocMap
	refa41a5c3b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa41a5c3b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cpNext_allocs)

	var cobjectType_allocs *cgoAllocMap
	refa41a5c3b.objectType, cobjectType_allocs = (C.VkDebugReportObjectTypeEXT)(x.ObjectType), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cobjectType_allocs)

	var cobject_allocs *cgoAllocMap
	refa41a5c3b.object, cobject_allocs = (C.uint64_t)(x.Object), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cobject_allocs)

	var ctagName_allocs *cgoAllocMap
	refa41a5c3b.tagName, ctagName_allocs = (C.uint64_t)(x.TagName), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(ctagName_allocs)

	var ctagSize_allocs *cgoAllocMap
	refa41a5c3b.tagSize, ctagSize_allocs = (C.size_t)(x.TagSize), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(ctagSize_allocs)

	var cpTag_allocs *cgoAllocMap
	refa41a5c3b.pTag, cpTag_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PTag)), cgoAllocsUnknown
	allocsa41a5c3b.Borrow(cpTag_allocs)

	x.refa41a5c3b = refa41a5c3b
	x.allocsa41a5c3b = allocsa41a5c3b
	return refa41a5c3b, allocsa41a5c3b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugMarkerObjectTagInfo) PassValue() (C.VkDebugMarkerObjectTagInfoEXT, *cgoAllocMap) {
	if x.refa41a5c3b != nil {
		return *x.refa41a5c3b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugMarkerObjectTagInfo) Deref() {
	if x.refa41a5c3b == nil {
		return
	}
	x.SType = (StructureType)(x.refa41a5c3b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa41a5c3b.pNext))
	x.ObjectType = (DebugReportObjectType)(x.refa41a5c3b.objectType)
	x.Object = (uint64)(x.refa41a5c3b.object)
	x.TagName = (uint64)(x.refa41a5c3b.tagName)
	x.TagSize = (uint64)(x.refa41a5c3b.tagSize)
	x.PTag = (unsafe.Pointer)(unsafe.Pointer(x.refa41a5c3b.pTag))
}

// allocDebugMarkerMarkerInfoMemory allocates memory for type C.VkDebugMarkerMarkerInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugMarkerMarkerInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugMarkerMarkerInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugMarkerMarkerInfoValue = unsafe.Sizeof([1]C.VkDebugMarkerMarkerInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugMarkerMarkerInfo) Ref() *C.VkDebugMarkerMarkerInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref234b91fd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugMarkerMarkerInfo) Free() {
	if x != nil && x.allocs234b91fd != nil {
		x.allocs234b91fd.(*cgoAllocMap).Free()
		x.ref234b91fd = nil
	}
}

// NewDebugMarkerMarkerInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugMarkerMarkerInfoRef(ref unsafe.Pointer) *DebugMarkerMarkerInfo {
	if ref == nil {
		return nil
	}
	obj := new(DebugMarkerMarkerInfo)
	obj.ref234b91fd = (*C.VkDebugMarkerMarkerInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugMarkerMarkerInfo) PassRef() (*C.VkDebugMarkerMarkerInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref234b91fd != nil {
		return x.ref234b91fd, nil
	}
	mem234b91fd := allocDebugMarkerMarkerInfoMemory(1)
	ref234b91fd := (*C.VkDebugMarkerMarkerInfoEXT)(mem234b91fd)
	allocs234b91fd := new(cgoAllocMap)
	allocs234b91fd.Add(mem234b91fd)

	var csType_allocs *cgoAllocMap
	ref234b91fd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs234b91fd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref234b91fd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs234b91fd.Borrow(cpNext_allocs)

	var cpMarkerName_allocs *cgoAllocMap
	ref234b91fd.pMarkerName, cpMarkerName_allocs = unpackPCharString(x.PMarkerName)
	allocs234b91fd.Borrow(cpMarkerName_allocs)

	var ccolor_allocs *cgoAllocMap
	ref234b91fd.color, ccolor_allocs = *(*[4]C.float)(unsafe.Pointer(&x.Color)), cgoAllocsUnknown
	allocs234b91fd.Borrow(ccolor_allocs)

	x.ref234b91fd = ref234b91fd
	x.allocs234b91fd = allocs234b91fd
	return ref234b91fd, allocs234b91fd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugMarkerMarkerInfo) PassValue() (C.VkDebugMarkerMarkerInfoEXT, *cgoAllocMap) {
	if x.ref234b91fd != nil {
		return *x.ref234b91fd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugMarkerMarkerInfo) Deref() {
	if x.ref234b91fd == nil {
		return
	}
	x.SType = (StructureType)(x.ref234b91fd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref234b91fd.pNext))
	x.PMarkerName = packPCharString(x.ref234b91fd.pMarkerName)
	x.Color = *(*[4]float32)(unsafe.Pointer(&x.ref234b91fd.color))
}

// allocDedicatedAllocationImageCreateInfoNVMemory allocates memory for type C.VkDedicatedAllocationImageCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDedicatedAllocationImageCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDedicatedAllocationImageCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDedicatedAllocationImageCreateInfoNVValue = unsafe.Sizeof([1]C.VkDedicatedAllocationImageCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DedicatedAllocationImageCreateInfoNV) Ref() *C.VkDedicatedAllocationImageCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref685d878b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DedicatedAllocationImageCreateInfoNV) Free() {
	if x != nil && x.allocs685d878b != nil {
		x.allocs685d878b.(*cgoAllocMap).Free()
		x.ref685d878b = nil
	}
}

// NewDedicatedAllocationImageCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDedicatedAllocationImageCreateInfoNVRef(ref unsafe.Pointer) *DedicatedAllocationImageCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(DedicatedAllocationImageCreateInfoNV)
	obj.ref685d878b = (*C.VkDedicatedAllocationImageCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DedicatedAllocationImageCreateInfoNV) PassRef() (*C.VkDedicatedAllocationImageCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref685d878b != nil {
		return x.ref685d878b, nil
	}
	mem685d878b := allocDedicatedAllocationImageCreateInfoNVMemory(1)
	ref685d878b := (*C.VkDedicatedAllocationImageCreateInfoNV)(mem685d878b)
	allocs685d878b := new(cgoAllocMap)
	allocs685d878b.Add(mem685d878b)

	var csType_allocs *cgoAllocMap
	ref685d878b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs685d878b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref685d878b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs685d878b.Borrow(cpNext_allocs)

	var cdedicatedAllocation_allocs *cgoAllocMap
	ref685d878b.dedicatedAllocation, cdedicatedAllocation_allocs = (C.VkBool32)(x.DedicatedAllocation), cgoAllocsUnknown
	allocs685d878b.Borrow(cdedicatedAllocation_allocs)

	x.ref685d878b = ref685d878b
	x.allocs685d878b = allocs685d878b
	return ref685d878b, allocs685d878b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DedicatedAllocationImageCreateInfoNV) PassValue() (C.VkDedicatedAllocationImageCreateInfoNV, *cgoAllocMap) {
	if x.ref685d878b != nil {
		return *x.ref685d878b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DedicatedAllocationImageCreateInfoNV) Deref() {
	if x.ref685d878b == nil {
		return
	}
	x.SType = (StructureType)(x.ref685d878b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref685d878b.pNext))
	x.DedicatedAllocation = (Bool32)(x.ref685d878b.dedicatedAllocation)
}

// allocDedicatedAllocationBufferCreateInfoNVMemory allocates memory for type C.VkDedicatedAllocationBufferCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDedicatedAllocationBufferCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDedicatedAllocationBufferCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDedicatedAllocationBufferCreateInfoNVValue = unsafe.Sizeof([1]C.VkDedicatedAllocationBufferCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DedicatedAllocationBufferCreateInfoNV) Ref() *C.VkDedicatedAllocationBufferCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refbc745a8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DedicatedAllocationBufferCreateInfoNV) Free() {
	if x != nil && x.allocsbc745a8 != nil {
		x.allocsbc745a8.(*cgoAllocMap).Free()
		x.refbc745a8 = nil
	}
}

// NewDedicatedAllocationBufferCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDedicatedAllocationBufferCreateInfoNVRef(ref unsafe.Pointer) *DedicatedAllocationBufferCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(DedicatedAllocationBufferCreateInfoNV)
	obj.refbc745a8 = (*C.VkDedicatedAllocationBufferCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DedicatedAllocationBufferCreateInfoNV) PassRef() (*C.VkDedicatedAllocationBufferCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbc745a8 != nil {
		return x.refbc745a8, nil
	}
	membc745a8 := allocDedicatedAllocationBufferCreateInfoNVMemory(1)
	refbc745a8 := (*C.VkDedicatedAllocationBufferCreateInfoNV)(membc745a8)
	allocsbc745a8 := new(cgoAllocMap)
	allocsbc745a8.Add(membc745a8)

	var csType_allocs *cgoAllocMap
	refbc745a8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbc745a8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbc745a8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbc745a8.Borrow(cpNext_allocs)

	var cdedicatedAllocation_allocs *cgoAllocMap
	refbc745a8.dedicatedAllocation, cdedicatedAllocation_allocs = (C.VkBool32)(x.DedicatedAllocation), cgoAllocsUnknown
	allocsbc745a8.Borrow(cdedicatedAllocation_allocs)

	x.refbc745a8 = refbc745a8
	x.allocsbc745a8 = allocsbc745a8
	return refbc745a8, allocsbc745a8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DedicatedAllocationBufferCreateInfoNV) PassValue() (C.VkDedicatedAllocationBufferCreateInfoNV, *cgoAllocMap) {
	if x.refbc745a8 != nil {
		return *x.refbc745a8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DedicatedAllocationBufferCreateInfoNV) Deref() {
	if x.refbc745a8 == nil {
		return
	}
	x.SType = (StructureType)(x.refbc745a8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbc745a8.pNext))
	x.DedicatedAllocation = (Bool32)(x.refbc745a8.dedicatedAllocation)
}

// allocDedicatedAllocationMemoryAllocateInfoNVMemory allocates memory for type C.VkDedicatedAllocationMemoryAllocateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDedicatedAllocationMemoryAllocateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDedicatedAllocationMemoryAllocateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDedicatedAllocationMemoryAllocateInfoNVValue = unsafe.Sizeof([1]C.VkDedicatedAllocationMemoryAllocateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DedicatedAllocationMemoryAllocateInfoNV) Ref() *C.VkDedicatedAllocationMemoryAllocateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref9a72b107
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DedicatedAllocationMemoryAllocateInfoNV) Free() {
	if x != nil && x.allocs9a72b107 != nil {
		x.allocs9a72b107.(*cgoAllocMap).Free()
		x.ref9a72b107 = nil
	}
}

// NewDedicatedAllocationMemoryAllocateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDedicatedAllocationMemoryAllocateInfoNVRef(ref unsafe.Pointer) *DedicatedAllocationMemoryAllocateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(DedicatedAllocationMemoryAllocateInfoNV)
	obj.ref9a72b107 = (*C.VkDedicatedAllocationMemoryAllocateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DedicatedAllocationMemoryAllocateInfoNV) PassRef() (*C.VkDedicatedAllocationMemoryAllocateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9a72b107 != nil {
		return x.ref9a72b107, nil
	}
	mem9a72b107 := allocDedicatedAllocationMemoryAllocateInfoNVMemory(1)
	ref9a72b107 := (*C.VkDedicatedAllocationMemoryAllocateInfoNV)(mem9a72b107)
	allocs9a72b107 := new(cgoAllocMap)
	allocs9a72b107.Add(mem9a72b107)

	var csType_allocs *cgoAllocMap
	ref9a72b107.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9a72b107.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9a72b107.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9a72b107.Borrow(cpNext_allocs)

	var cimage_allocs *cgoAllocMap
	ref9a72b107.image, cimage_allocs = *(*C.VkImage)(unsafe.Pointer(&x.Image)), cgoAllocsUnknown
	allocs9a72b107.Borrow(cimage_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref9a72b107.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs9a72b107.Borrow(cbuffer_allocs)

	x.ref9a72b107 = ref9a72b107
	x.allocs9a72b107 = allocs9a72b107
	return ref9a72b107, allocs9a72b107

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DedicatedAllocationMemoryAllocateInfoNV) PassValue() (C.VkDedicatedAllocationMemoryAllocateInfoNV, *cgoAllocMap) {
	if x.ref9a72b107 != nil {
		return *x.ref9a72b107, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DedicatedAllocationMemoryAllocateInfoNV) Deref() {
	if x.ref9a72b107 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9a72b107.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9a72b107.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref9a72b107.image))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref9a72b107.buffer))
}

// allocPhysicalDeviceTransformFeedbackFeaturesMemory allocates memory for type C.VkPhysicalDeviceTransformFeedbackFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceTransformFeedbackFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceTransformFeedbackFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceTransformFeedbackFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceTransformFeedbackFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceTransformFeedbackFeatures) Ref() *C.VkPhysicalDeviceTransformFeedbackFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref64b2a913
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceTransformFeedbackFeatures) Free() {
	if x != nil && x.allocs64b2a913 != nil {
		x.allocs64b2a913.(*cgoAllocMap).Free()
		x.ref64b2a913 = nil
	}
}

// NewPhysicalDeviceTransformFeedbackFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceTransformFeedbackFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceTransformFeedbackFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceTransformFeedbackFeatures)
	obj.ref64b2a913 = (*C.VkPhysicalDeviceTransformFeedbackFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceTransformFeedbackFeatures) PassRef() (*C.VkPhysicalDeviceTransformFeedbackFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref64b2a913 != nil {
		return x.ref64b2a913, nil
	}
	mem64b2a913 := allocPhysicalDeviceTransformFeedbackFeaturesMemory(1)
	ref64b2a913 := (*C.VkPhysicalDeviceTransformFeedbackFeaturesEXT)(mem64b2a913)
	allocs64b2a913 := new(cgoAllocMap)
	allocs64b2a913.Add(mem64b2a913)

	var csType_allocs *cgoAllocMap
	ref64b2a913.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs64b2a913.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref64b2a913.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs64b2a913.Borrow(cpNext_allocs)

	var ctransformFeedback_allocs *cgoAllocMap
	ref64b2a913.transformFeedback, ctransformFeedback_allocs = (C.VkBool32)(x.TransformFeedback), cgoAllocsUnknown
	allocs64b2a913.Borrow(ctransformFeedback_allocs)

	var cgeometryStreams_allocs *cgoAllocMap
	ref64b2a913.geometryStreams, cgeometryStreams_allocs = (C.VkBool32)(x.GeometryStreams), cgoAllocsUnknown
	allocs64b2a913.Borrow(cgeometryStreams_allocs)

	x.ref64b2a913 = ref64b2a913
	x.allocs64b2a913 = allocs64b2a913
	return ref64b2a913, allocs64b2a913

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceTransformFeedbackFeatures) PassValue() (C.VkPhysicalDeviceTransformFeedbackFeaturesEXT, *cgoAllocMap) {
	if x.ref64b2a913 != nil {
		return *x.ref64b2a913, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceTransformFeedbackFeatures) Deref() {
	if x.ref64b2a913 == nil {
		return
	}
	x.SType = (StructureType)(x.ref64b2a913.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref64b2a913.pNext))
	x.TransformFeedback = (Bool32)(x.ref64b2a913.transformFeedback)
	x.GeometryStreams = (Bool32)(x.ref64b2a913.geometryStreams)
}

// allocPhysicalDeviceTransformFeedbackPropertiesMemory allocates memory for type C.VkPhysicalDeviceTransformFeedbackPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceTransformFeedbackPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceTransformFeedbackPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceTransformFeedbackPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceTransformFeedbackPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceTransformFeedbackProperties) Ref() *C.VkPhysicalDeviceTransformFeedbackPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refc295a2a0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceTransformFeedbackProperties) Free() {
	if x != nil && x.allocsc295a2a0 != nil {
		x.allocsc295a2a0.(*cgoAllocMap).Free()
		x.refc295a2a0 = nil
	}
}

// NewPhysicalDeviceTransformFeedbackPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceTransformFeedbackPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceTransformFeedbackProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceTransformFeedbackProperties)
	obj.refc295a2a0 = (*C.VkPhysicalDeviceTransformFeedbackPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceTransformFeedbackProperties) PassRef() (*C.VkPhysicalDeviceTransformFeedbackPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc295a2a0 != nil {
		return x.refc295a2a0, nil
	}
	memc295a2a0 := allocPhysicalDeviceTransformFeedbackPropertiesMemory(1)
	refc295a2a0 := (*C.VkPhysicalDeviceTransformFeedbackPropertiesEXT)(memc295a2a0)
	allocsc295a2a0 := new(cgoAllocMap)
	allocsc295a2a0.Add(memc295a2a0)

	var csType_allocs *cgoAllocMap
	refc295a2a0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsc295a2a0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refc295a2a0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsc295a2a0.Borrow(cpNext_allocs)

	var cmaxTransformFeedbackStreams_allocs *cgoAllocMap
	refc295a2a0.maxTransformFeedbackStreams, cmaxTransformFeedbackStreams_allocs = (C.uint32_t)(x.MaxTransformFeedbackStreams), cgoAllocsUnknown
	allocsc295a2a0.Borrow(cmaxTransformFeedbackStreams_allocs)

	var cmaxTransformFeedbackBuffers_allocs *cgoAllocMap
	refc295a2a0.maxTransformFeedbackBuffers, cmaxTransformFeedbackBuffers_allocs = (C.uint32_t)(x.MaxTransformFeedbackBuffers), cgoAllocsUnknown
	allocsc295a2a0.Borrow(cmaxTransformFeedbackBuffers_allocs)

	var cmaxTransformFeedbackBufferSize_allocs *cgoAllocMap
	refc295a2a0.maxTransformFeedbackBufferSize, cmaxTransformFeedbackBufferSize_allocs = (C.VkDeviceSize)(x.MaxTransformFeedbackBufferSize), cgoAllocsUnknown
	allocsc295a2a0.Borrow(cmaxTransformFeedbackBufferSize_allocs)

	var cmaxTransformFeedbackStreamDataSize_allocs *cgoAllocMap
	refc295a2a0.maxTransformFeedbackStreamDataSize, cmaxTransformFeedbackStreamDataSize_allocs = (C.uint32_t)(x.MaxTransformFeedbackStreamDataSize), cgoAllocsUnknown
	allocsc295a2a0.Borrow(cmaxTransformFeedbackStreamDataSize_allocs)

	var cmaxTransformFeedbackBufferDataSize_allocs *cgoAllocMap
	refc295a2a0.maxTransformFeedbackBufferDataSize, cmaxTransformFeedbackBufferDataSize_allocs = (C.uint32_t)(x.MaxTransformFeedbackBufferDataSize), cgoAllocsUnknown
	allocsc295a2a0.Borrow(cmaxTransformFeedbackBufferDataSize_allocs)

	var cmaxTransformFeedbackBufferDataStride_allocs *cgoAllocMap
	refc295a2a0.maxTransformFeedbackBufferDataStride, cmaxTransformFeedbackBufferDataStride_allocs = (C.uint32_t)(x.MaxTransformFeedbackBufferDataStride), cgoAllocsUnknown
	allocsc295a2a0.Borrow(cmaxTransformFeedbackBufferDataStride_allocs)

	var ctransformFeedbackQueries_allocs *cgoAllocMap
	refc295a2a0.transformFeedbackQueries, ctransformFeedbackQueries_allocs = (C.VkBool32)(x.TransformFeedbackQueries), cgoAllocsUnknown
	allocsc295a2a0.Borrow(ctransformFeedbackQueries_allocs)

	var ctransformFeedbackStreamsLinesTriangles_allocs *cgoAllocMap
	refc295a2a0.transformFeedbackStreamsLinesTriangles, ctransformFeedbackStreamsLinesTriangles_allocs = (C.VkBool32)(x.TransformFeedbackStreamsLinesTriangles), cgoAllocsUnknown
	allocsc295a2a0.Borrow(ctransformFeedbackStreamsLinesTriangles_allocs)

	var ctransformFeedbackRasterizationStreamSelect_allocs *cgoAllocMap
	refc295a2a0.transformFeedbackRasterizationStreamSelect, ctransformFeedbackRasterizationStreamSelect_allocs = (C.VkBool32)(x.TransformFeedbackRasterizationStreamSelect), cgoAllocsUnknown
	allocsc295a2a0.Borrow(ctransformFeedbackRasterizationStreamSelect_allocs)

	var ctransformFeedbackDraw_allocs *cgoAllocMap
	refc295a2a0.transformFeedbackDraw, ctransformFeedbackDraw_allocs = (C.VkBool32)(x.TransformFeedbackDraw), cgoAllocsUnknown
	allocsc295a2a0.Borrow(ctransformFeedbackDraw_allocs)

	x.refc295a2a0 = refc295a2a0
	x.allocsc295a2a0 = allocsc295a2a0
	return refc295a2a0, allocsc295a2a0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceTransformFeedbackProperties) PassValue() (C.VkPhysicalDeviceTransformFeedbackPropertiesEXT, *cgoAllocMap) {
	if x.refc295a2a0 != nil {
		return *x.refc295a2a0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceTransformFeedbackProperties) Deref() {
	if x.refc295a2a0 == nil {
		return
	}
	x.SType = (StructureType)(x.refc295a2a0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc295a2a0.pNext))
	x.MaxTransformFeedbackStreams = (uint32)(x.refc295a2a0.maxTransformFeedbackStreams)
	x.MaxTransformFeedbackBuffers = (uint32)(x.refc295a2a0.maxTransformFeedbackBuffers)
	x.MaxTransformFeedbackBufferSize = (DeviceSize)(x.refc295a2a0.maxTransformFeedbackBufferSize)
	x.MaxTransformFeedbackStreamDataSize = (uint32)(x.refc295a2a0.maxTransformFeedbackStreamDataSize)
	x.MaxTransformFeedbackBufferDataSize = (uint32)(x.refc295a2a0.maxTransformFeedbackBufferDataSize)
	x.MaxTransformFeedbackBufferDataStride = (uint32)(x.refc295a2a0.maxTransformFeedbackBufferDataStride)
	x.TransformFeedbackQueries = (Bool32)(x.refc295a2a0.transformFeedbackQueries)
	x.TransformFeedbackStreamsLinesTriangles = (Bool32)(x.refc295a2a0.transformFeedbackStreamsLinesTriangles)
	x.TransformFeedbackRasterizationStreamSelect = (Bool32)(x.refc295a2a0.transformFeedbackRasterizationStreamSelect)
	x.TransformFeedbackDraw = (Bool32)(x.refc295a2a0.transformFeedbackDraw)
}

// allocPipelineRasterizationStateStreamCreateInfoMemory allocates memory for type C.VkPipelineRasterizationStateStreamCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationStateStreamCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationStateStreamCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineRasterizationStateStreamCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineRasterizationStateStreamCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineRasterizationStateStreamCreateInfo) Ref() *C.VkPipelineRasterizationStateStreamCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refed6e1fb9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineRasterizationStateStreamCreateInfo) Free() {
	if x != nil && x.allocsed6e1fb9 != nil {
		x.allocsed6e1fb9.(*cgoAllocMap).Free()
		x.refed6e1fb9 = nil
	}
}

// NewPipelineRasterizationStateStreamCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineRasterizationStateStreamCreateInfoRef(ref unsafe.Pointer) *PipelineRasterizationStateStreamCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRasterizationStateStreamCreateInfo)
	obj.refed6e1fb9 = (*C.VkPipelineRasterizationStateStreamCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineRasterizationStateStreamCreateInfo) PassRef() (*C.VkPipelineRasterizationStateStreamCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refed6e1fb9 != nil {
		return x.refed6e1fb9, nil
	}
	memed6e1fb9 := allocPipelineRasterizationStateStreamCreateInfoMemory(1)
	refed6e1fb9 := (*C.VkPipelineRasterizationStateStreamCreateInfoEXT)(memed6e1fb9)
	allocsed6e1fb9 := new(cgoAllocMap)
	allocsed6e1fb9.Add(memed6e1fb9)

	var csType_allocs *cgoAllocMap
	refed6e1fb9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsed6e1fb9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refed6e1fb9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsed6e1fb9.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refed6e1fb9.flags, cflags_allocs = (C.VkPipelineRasterizationStateStreamCreateFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocsed6e1fb9.Borrow(cflags_allocs)

	var crasterizationStream_allocs *cgoAllocMap
	refed6e1fb9.rasterizationStream, crasterizationStream_allocs = (C.uint32_t)(x.RasterizationStream), cgoAllocsUnknown
	allocsed6e1fb9.Borrow(crasterizationStream_allocs)

	x.refed6e1fb9 = refed6e1fb9
	x.allocsed6e1fb9 = allocsed6e1fb9
	return refed6e1fb9, allocsed6e1fb9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineRasterizationStateStreamCreateInfo) PassValue() (C.VkPipelineRasterizationStateStreamCreateInfoEXT, *cgoAllocMap) {
	if x.refed6e1fb9 != nil {
		return *x.refed6e1fb9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineRasterizationStateStreamCreateInfo) Deref() {
	if x.refed6e1fb9 == nil {
		return
	}
	x.SType = (StructureType)(x.refed6e1fb9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refed6e1fb9.pNext))
	x.Flags = (PipelineRasterizationStateStreamCreateFlags)(x.refed6e1fb9.flags)
	x.RasterizationStream = (uint32)(x.refed6e1fb9.rasterizationStream)
}

// allocTextureLODGatherFormatPropertiesAMDMemory allocates memory for type C.VkTextureLODGatherFormatPropertiesAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTextureLODGatherFormatPropertiesAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTextureLODGatherFormatPropertiesAMDValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTextureLODGatherFormatPropertiesAMDValue = unsafe.Sizeof([1]C.VkTextureLODGatherFormatPropertiesAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TextureLODGatherFormatPropertiesAMD) Ref() *C.VkTextureLODGatherFormatPropertiesAMD {
	if x == nil {
		return nil
	}
	return x.ref519ba3a9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TextureLODGatherFormatPropertiesAMD) Free() {
	if x != nil && x.allocs519ba3a9 != nil {
		x.allocs519ba3a9.(*cgoAllocMap).Free()
		x.ref519ba3a9 = nil
	}
}

// NewTextureLODGatherFormatPropertiesAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextureLODGatherFormatPropertiesAMDRef(ref unsafe.Pointer) *TextureLODGatherFormatPropertiesAMD {
	if ref == nil {
		return nil
	}
	obj := new(TextureLODGatherFormatPropertiesAMD)
	obj.ref519ba3a9 = (*C.VkTextureLODGatherFormatPropertiesAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TextureLODGatherFormatPropertiesAMD) PassRef() (*C.VkTextureLODGatherFormatPropertiesAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref519ba3a9 != nil {
		return x.ref519ba3a9, nil
	}
	mem519ba3a9 := allocTextureLODGatherFormatPropertiesAMDMemory(1)
	ref519ba3a9 := (*C.VkTextureLODGatherFormatPropertiesAMD)(mem519ba3a9)
	allocs519ba3a9 := new(cgoAllocMap)
	allocs519ba3a9.Add(mem519ba3a9)

	var csType_allocs *cgoAllocMap
	ref519ba3a9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs519ba3a9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref519ba3a9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs519ba3a9.Borrow(cpNext_allocs)

	var csupportsTextureGatherLODBiasAMD_allocs *cgoAllocMap
	ref519ba3a9.supportsTextureGatherLODBiasAMD, csupportsTextureGatherLODBiasAMD_allocs = (C.VkBool32)(x.SupportsTextureGatherLODBiasAMD), cgoAllocsUnknown
	allocs519ba3a9.Borrow(csupportsTextureGatherLODBiasAMD_allocs)

	x.ref519ba3a9 = ref519ba3a9
	x.allocs519ba3a9 = allocs519ba3a9
	return ref519ba3a9, allocs519ba3a9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TextureLODGatherFormatPropertiesAMD) PassValue() (C.VkTextureLODGatherFormatPropertiesAMD, *cgoAllocMap) {
	if x.ref519ba3a9 != nil {
		return *x.ref519ba3a9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TextureLODGatherFormatPropertiesAMD) Deref() {
	if x.ref519ba3a9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref519ba3a9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref519ba3a9.pNext))
	x.SupportsTextureGatherLODBiasAMD = (Bool32)(x.ref519ba3a9.supportsTextureGatherLODBiasAMD)
}

// allocShaderResourceUsageAMDMemory allocates memory for type C.VkShaderResourceUsageAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderResourceUsageAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderResourceUsageAMDValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaderResourceUsageAMDValue = unsafe.Sizeof([1]C.VkShaderResourceUsageAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShaderResourceUsageAMD) Ref() *C.VkShaderResourceUsageAMD {
	if x == nil {
		return nil
	}
	return x.ref8a688131
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShaderResourceUsageAMD) Free() {
	if x != nil && x.allocs8a688131 != nil {
		x.allocs8a688131.(*cgoAllocMap).Free()
		x.ref8a688131 = nil
	}
}

// NewShaderResourceUsageAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderResourceUsageAMDRef(ref unsafe.Pointer) *ShaderResourceUsageAMD {
	if ref == nil {
		return nil
	}
	obj := new(ShaderResourceUsageAMD)
	obj.ref8a688131 = (*C.VkShaderResourceUsageAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShaderResourceUsageAMD) PassRef() (*C.VkShaderResourceUsageAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8a688131 != nil {
		return x.ref8a688131, nil
	}
	mem8a688131 := allocShaderResourceUsageAMDMemory(1)
	ref8a688131 := (*C.VkShaderResourceUsageAMD)(mem8a688131)
	allocs8a688131 := new(cgoAllocMap)
	allocs8a688131.Add(mem8a688131)

	var cnumUsedVgprs_allocs *cgoAllocMap
	ref8a688131.numUsedVgprs, cnumUsedVgprs_allocs = (C.uint32_t)(x.NumUsedVgprs), cgoAllocsUnknown
	allocs8a688131.Borrow(cnumUsedVgprs_allocs)

	var cnumUsedSgprs_allocs *cgoAllocMap
	ref8a688131.numUsedSgprs, cnumUsedSgprs_allocs = (C.uint32_t)(x.NumUsedSgprs), cgoAllocsUnknown
	allocs8a688131.Borrow(cnumUsedSgprs_allocs)

	var cldsSizePerLocalWorkGroup_allocs *cgoAllocMap
	ref8a688131.ldsSizePerLocalWorkGroup, cldsSizePerLocalWorkGroup_allocs = (C.uint32_t)(x.LdsSizePerLocalWorkGroup), cgoAllocsUnknown
	allocs8a688131.Borrow(cldsSizePerLocalWorkGroup_allocs)

	var cldsUsageSizeInBytes_allocs *cgoAllocMap
	ref8a688131.ldsUsageSizeInBytes, cldsUsageSizeInBytes_allocs = (C.size_t)(x.LdsUsageSizeInBytes), cgoAllocsUnknown
	allocs8a688131.Borrow(cldsUsageSizeInBytes_allocs)

	var cscratchMemUsageInBytes_allocs *cgoAllocMap
	ref8a688131.scratchMemUsageInBytes, cscratchMemUsageInBytes_allocs = (C.size_t)(x.ScratchMemUsageInBytes), cgoAllocsUnknown
	allocs8a688131.Borrow(cscratchMemUsageInBytes_allocs)

	x.ref8a688131 = ref8a688131
	x.allocs8a688131 = allocs8a688131
	return ref8a688131, allocs8a688131

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShaderResourceUsageAMD) PassValue() (C.VkShaderResourceUsageAMD, *cgoAllocMap) {
	if x.ref8a688131 != nil {
		return *x.ref8a688131, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShaderResourceUsageAMD) Deref() {
	if x.ref8a688131 == nil {
		return
	}
	x.NumUsedVgprs = (uint32)(x.ref8a688131.numUsedVgprs)
	x.NumUsedSgprs = (uint32)(x.ref8a688131.numUsedSgprs)
	x.LdsSizePerLocalWorkGroup = (uint32)(x.ref8a688131.ldsSizePerLocalWorkGroup)
	x.LdsUsageSizeInBytes = (uint64)(x.ref8a688131.ldsUsageSizeInBytes)
	x.ScratchMemUsageInBytes = (uint64)(x.ref8a688131.scratchMemUsageInBytes)
}

// allocShaderStatisticsInfoAMDMemory allocates memory for type C.VkShaderStatisticsInfoAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderStatisticsInfoAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderStatisticsInfoAMDValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaderStatisticsInfoAMDValue = unsafe.Sizeof([1]C.VkShaderStatisticsInfoAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShaderStatisticsInfoAMD) Ref() *C.VkShaderStatisticsInfoAMD {
	if x == nil {
		return nil
	}
	return x.ref896a52bf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShaderStatisticsInfoAMD) Free() {
	if x != nil && x.allocs896a52bf != nil {
		x.allocs896a52bf.(*cgoAllocMap).Free()
		x.ref896a52bf = nil
	}
}

// NewShaderStatisticsInfoAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderStatisticsInfoAMDRef(ref unsafe.Pointer) *ShaderStatisticsInfoAMD {
	if ref == nil {
		return nil
	}
	obj := new(ShaderStatisticsInfoAMD)
	obj.ref896a52bf = (*C.VkShaderStatisticsInfoAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShaderStatisticsInfoAMD) PassRef() (*C.VkShaderStatisticsInfoAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref896a52bf != nil {
		return x.ref896a52bf, nil
	}
	mem896a52bf := allocShaderStatisticsInfoAMDMemory(1)
	ref896a52bf := (*C.VkShaderStatisticsInfoAMD)(mem896a52bf)
	allocs896a52bf := new(cgoAllocMap)
	allocs896a52bf.Add(mem896a52bf)

	var cshaderStageMask_allocs *cgoAllocMap
	ref896a52bf.shaderStageMask, cshaderStageMask_allocs = (C.VkShaderStageFlags)(x.ShaderStageMask), cgoAllocsUnknown
	allocs896a52bf.Borrow(cshaderStageMask_allocs)

	var cresourceUsage_allocs *cgoAllocMap
	ref896a52bf.resourceUsage, cresourceUsage_allocs = x.ResourceUsage.PassValue()
	allocs896a52bf.Borrow(cresourceUsage_allocs)

	var cnumPhysicalVgprs_allocs *cgoAllocMap
	ref896a52bf.numPhysicalVgprs, cnumPhysicalVgprs_allocs = (C.uint32_t)(x.NumPhysicalVgprs), cgoAllocsUnknown
	allocs896a52bf.Borrow(cnumPhysicalVgprs_allocs)

	var cnumPhysicalSgprs_allocs *cgoAllocMap
	ref896a52bf.numPhysicalSgprs, cnumPhysicalSgprs_allocs = (C.uint32_t)(x.NumPhysicalSgprs), cgoAllocsUnknown
	allocs896a52bf.Borrow(cnumPhysicalSgprs_allocs)

	var cnumAvailableVgprs_allocs *cgoAllocMap
	ref896a52bf.numAvailableVgprs, cnumAvailableVgprs_allocs = (C.uint32_t)(x.NumAvailableVgprs), cgoAllocsUnknown
	allocs896a52bf.Borrow(cnumAvailableVgprs_allocs)

	var cnumAvailableSgprs_allocs *cgoAllocMap
	ref896a52bf.numAvailableSgprs, cnumAvailableSgprs_allocs = (C.uint32_t)(x.NumAvailableSgprs), cgoAllocsUnknown
	allocs896a52bf.Borrow(cnumAvailableSgprs_allocs)

	var ccomputeWorkGroupSize_allocs *cgoAllocMap
	ref896a52bf.computeWorkGroupSize, ccomputeWorkGroupSize_allocs = *(*[3]C.uint32_t)(unsafe.Pointer(&x.ComputeWorkGroupSize)), cgoAllocsUnknown
	allocs896a52bf.Borrow(ccomputeWorkGroupSize_allocs)

	x.ref896a52bf = ref896a52bf
	x.allocs896a52bf = allocs896a52bf
	return ref896a52bf, allocs896a52bf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShaderStatisticsInfoAMD) PassValue() (C.VkShaderStatisticsInfoAMD, *cgoAllocMap) {
	if x.ref896a52bf != nil {
		return *x.ref896a52bf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShaderStatisticsInfoAMD) Deref() {
	if x.ref896a52bf == nil {
		return
	}
	x.ShaderStageMask = (ShaderStageFlags)(x.ref896a52bf.shaderStageMask)
	x.ResourceUsage = *NewShaderResourceUsageAMDRef(unsafe.Pointer(&x.ref896a52bf.resourceUsage))
	x.NumPhysicalVgprs = (uint32)(x.ref896a52bf.numPhysicalVgprs)
	x.NumPhysicalSgprs = (uint32)(x.ref896a52bf.numPhysicalSgprs)
	x.NumAvailableVgprs = (uint32)(x.ref896a52bf.numAvailableVgprs)
	x.NumAvailableSgprs = (uint32)(x.ref896a52bf.numAvailableSgprs)
	x.ComputeWorkGroupSize = *(*[3]uint32)(unsafe.Pointer(&x.ref896a52bf.computeWorkGroupSize))
}

// allocPhysicalDeviceCornerSampledImageFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceCornerSampledImageFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceCornerSampledImageFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceCornerSampledImageFeaturesNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceCornerSampledImageFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceCornerSampledImageFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceCornerSampledImageFeaturesNV) Ref() *C.VkPhysicalDeviceCornerSampledImageFeaturesNV {
	if x == nil {
		return nil
	}
	return x.refdf4a62d1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceCornerSampledImageFeaturesNV) Free() {
	if x != nil && x.allocsdf4a62d1 != nil {
		x.allocsdf4a62d1.(*cgoAllocMap).Free()
		x.refdf4a62d1 = nil
	}
}

// NewPhysicalDeviceCornerSampledImageFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceCornerSampledImageFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceCornerSampledImageFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceCornerSampledImageFeaturesNV)
	obj.refdf4a62d1 = (*C.VkPhysicalDeviceCornerSampledImageFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceCornerSampledImageFeaturesNV) PassRef() (*C.VkPhysicalDeviceCornerSampledImageFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdf4a62d1 != nil {
		return x.refdf4a62d1, nil
	}
	memdf4a62d1 := allocPhysicalDeviceCornerSampledImageFeaturesNVMemory(1)
	refdf4a62d1 := (*C.VkPhysicalDeviceCornerSampledImageFeaturesNV)(memdf4a62d1)
	allocsdf4a62d1 := new(cgoAllocMap)
	allocsdf4a62d1.Add(memdf4a62d1)

	var csType_allocs *cgoAllocMap
	refdf4a62d1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdf4a62d1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdf4a62d1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdf4a62d1.Borrow(cpNext_allocs)

	var ccornerSampledImage_allocs *cgoAllocMap
	refdf4a62d1.cornerSampledImage, ccornerSampledImage_allocs = (C.VkBool32)(x.CornerSampledImage), cgoAllocsUnknown
	allocsdf4a62d1.Borrow(ccornerSampledImage_allocs)

	x.refdf4a62d1 = refdf4a62d1
	x.allocsdf4a62d1 = allocsdf4a62d1
	return refdf4a62d1, allocsdf4a62d1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceCornerSampledImageFeaturesNV) PassValue() (C.VkPhysicalDeviceCornerSampledImageFeaturesNV, *cgoAllocMap) {
	if x.refdf4a62d1 != nil {
		return *x.refdf4a62d1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceCornerSampledImageFeaturesNV) Deref() {
	if x.refdf4a62d1 == nil {
		return
	}
	x.SType = (StructureType)(x.refdf4a62d1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdf4a62d1.pNext))
	x.CornerSampledImage = (Bool32)(x.refdf4a62d1.cornerSampledImage)
}

// allocExternalImageFormatPropertiesNVMemory allocates memory for type C.VkExternalImageFormatPropertiesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalImageFormatPropertiesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalImageFormatPropertiesNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalImageFormatPropertiesNVValue = unsafe.Sizeof([1]C.VkExternalImageFormatPropertiesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalImageFormatPropertiesNV) Ref() *C.VkExternalImageFormatPropertiesNV {
	if x == nil {
		return nil
	}
	return x.refa8900ce5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalImageFormatPropertiesNV) Free() {
	if x != nil && x.allocsa8900ce5 != nil {
		x.allocsa8900ce5.(*cgoAllocMap).Free()
		x.refa8900ce5 = nil
	}
}

// NewExternalImageFormatPropertiesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalImageFormatPropertiesNVRef(ref unsafe.Pointer) *ExternalImageFormatPropertiesNV {
	if ref == nil {
		return nil
	}
	obj := new(ExternalImageFormatPropertiesNV)
	obj.refa8900ce5 = (*C.VkExternalImageFormatPropertiesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalImageFormatPropertiesNV) PassRef() (*C.VkExternalImageFormatPropertiesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa8900ce5 != nil {
		return x.refa8900ce5, nil
	}
	mema8900ce5 := allocExternalImageFormatPropertiesNVMemory(1)
	refa8900ce5 := (*C.VkExternalImageFormatPropertiesNV)(mema8900ce5)
	allocsa8900ce5 := new(cgoAllocMap)
	allocsa8900ce5.Add(mema8900ce5)

	var cimageFormatProperties_allocs *cgoAllocMap
	refa8900ce5.imageFormatProperties, cimageFormatProperties_allocs = x.ImageFormatProperties.PassValue()
	allocsa8900ce5.Borrow(cimageFormatProperties_allocs)

	var cexternalMemoryFeatures_allocs *cgoAllocMap
	refa8900ce5.externalMemoryFeatures, cexternalMemoryFeatures_allocs = (C.VkExternalMemoryFeatureFlagsNV)(x.ExternalMemoryFeatures), cgoAllocsUnknown
	allocsa8900ce5.Borrow(cexternalMemoryFeatures_allocs)

	var cexportFromImportedHandleTypes_allocs *cgoAllocMap
	refa8900ce5.exportFromImportedHandleTypes, cexportFromImportedHandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlagsNV)(x.ExportFromImportedHandleTypes), cgoAllocsUnknown
	allocsa8900ce5.Borrow(cexportFromImportedHandleTypes_allocs)

	var ccompatibleHandleTypes_allocs *cgoAllocMap
	refa8900ce5.compatibleHandleTypes, ccompatibleHandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlagsNV)(x.CompatibleHandleTypes), cgoAllocsUnknown
	allocsa8900ce5.Borrow(ccompatibleHandleTypes_allocs)

	x.refa8900ce5 = refa8900ce5
	x.allocsa8900ce5 = allocsa8900ce5
	return refa8900ce5, allocsa8900ce5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalImageFormatPropertiesNV) PassValue() (C.VkExternalImageFormatPropertiesNV, *cgoAllocMap) {
	if x.refa8900ce5 != nil {
		return *x.refa8900ce5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalImageFormatPropertiesNV) Deref() {
	if x.refa8900ce5 == nil {
		return
	}
	x.ImageFormatProperties = *NewImageFormatPropertiesRef(unsafe.Pointer(&x.refa8900ce5.imageFormatProperties))
	x.ExternalMemoryFeatures = (ExternalMemoryFeatureFlagsNV)(x.refa8900ce5.externalMemoryFeatures)
	x.ExportFromImportedHandleTypes = (ExternalMemoryHandleTypeFlagsNV)(x.refa8900ce5.exportFromImportedHandleTypes)
	x.CompatibleHandleTypes = (ExternalMemoryHandleTypeFlagsNV)(x.refa8900ce5.compatibleHandleTypes)
}

// allocExternalMemoryImageCreateInfoNVMemory allocates memory for type C.VkExternalMemoryImageCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExternalMemoryImageCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExternalMemoryImageCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExternalMemoryImageCreateInfoNVValue = unsafe.Sizeof([1]C.VkExternalMemoryImageCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExternalMemoryImageCreateInfoNV) Ref() *C.VkExternalMemoryImageCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref9a7fb6c8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExternalMemoryImageCreateInfoNV) Free() {
	if x != nil && x.allocs9a7fb6c8 != nil {
		x.allocs9a7fb6c8.(*cgoAllocMap).Free()
		x.ref9a7fb6c8 = nil
	}
}

// NewExternalMemoryImageCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExternalMemoryImageCreateInfoNVRef(ref unsafe.Pointer) *ExternalMemoryImageCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(ExternalMemoryImageCreateInfoNV)
	obj.ref9a7fb6c8 = (*C.VkExternalMemoryImageCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExternalMemoryImageCreateInfoNV) PassRef() (*C.VkExternalMemoryImageCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9a7fb6c8 != nil {
		return x.ref9a7fb6c8, nil
	}
	mem9a7fb6c8 := allocExternalMemoryImageCreateInfoNVMemory(1)
	ref9a7fb6c8 := (*C.VkExternalMemoryImageCreateInfoNV)(mem9a7fb6c8)
	allocs9a7fb6c8 := new(cgoAllocMap)
	allocs9a7fb6c8.Add(mem9a7fb6c8)

	var csType_allocs *cgoAllocMap
	ref9a7fb6c8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9a7fb6c8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9a7fb6c8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9a7fb6c8.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	ref9a7fb6c8.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlagsNV)(x.HandleTypes), cgoAllocsUnknown
	allocs9a7fb6c8.Borrow(chandleTypes_allocs)

	x.ref9a7fb6c8 = ref9a7fb6c8
	x.allocs9a7fb6c8 = allocs9a7fb6c8
	return ref9a7fb6c8, allocs9a7fb6c8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExternalMemoryImageCreateInfoNV) PassValue() (C.VkExternalMemoryImageCreateInfoNV, *cgoAllocMap) {
	if x.ref9a7fb6c8 != nil {
		return *x.ref9a7fb6c8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExternalMemoryImageCreateInfoNV) Deref() {
	if x.ref9a7fb6c8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9a7fb6c8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9a7fb6c8.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlagsNV)(x.ref9a7fb6c8.handleTypes)
}

// allocExportMemoryAllocateInfoNVMemory allocates memory for type C.VkExportMemoryAllocateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExportMemoryAllocateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExportMemoryAllocateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfExportMemoryAllocateInfoNVValue = unsafe.Sizeof([1]C.VkExportMemoryAllocateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExportMemoryAllocateInfoNV) Ref() *C.VkExportMemoryAllocateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref5066f33
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExportMemoryAllocateInfoNV) Free() {
	if x != nil && x.allocs5066f33 != nil {
		x.allocs5066f33.(*cgoAllocMap).Free()
		x.ref5066f33 = nil
	}
}

// NewExportMemoryAllocateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExportMemoryAllocateInfoNVRef(ref unsafe.Pointer) *ExportMemoryAllocateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(ExportMemoryAllocateInfoNV)
	obj.ref5066f33 = (*C.VkExportMemoryAllocateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExportMemoryAllocateInfoNV) PassRef() (*C.VkExportMemoryAllocateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5066f33 != nil {
		return x.ref5066f33, nil
	}
	mem5066f33 := allocExportMemoryAllocateInfoNVMemory(1)
	ref5066f33 := (*C.VkExportMemoryAllocateInfoNV)(mem5066f33)
	allocs5066f33 := new(cgoAllocMap)
	allocs5066f33.Add(mem5066f33)

	var csType_allocs *cgoAllocMap
	ref5066f33.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5066f33.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5066f33.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5066f33.Borrow(cpNext_allocs)

	var chandleTypes_allocs *cgoAllocMap
	ref5066f33.handleTypes, chandleTypes_allocs = (C.VkExternalMemoryHandleTypeFlagsNV)(x.HandleTypes), cgoAllocsUnknown
	allocs5066f33.Borrow(chandleTypes_allocs)

	x.ref5066f33 = ref5066f33
	x.allocs5066f33 = allocs5066f33
	return ref5066f33, allocs5066f33

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExportMemoryAllocateInfoNV) PassValue() (C.VkExportMemoryAllocateInfoNV, *cgoAllocMap) {
	if x.ref5066f33 != nil {
		return *x.ref5066f33, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExportMemoryAllocateInfoNV) Deref() {
	if x.ref5066f33 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5066f33.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5066f33.pNext))
	x.HandleTypes = (ExternalMemoryHandleTypeFlagsNV)(x.ref5066f33.handleTypes)
}

// allocValidationFlagsMemory allocates memory for type C.VkValidationFlagsEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValidationFlagsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValidationFlagsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfValidationFlagsValue = unsafe.Sizeof([1]C.VkValidationFlagsEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ValidationFlags) Ref() *C.VkValidationFlagsEXT {
	if x == nil {
		return nil
	}
	return x.refffe080ad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ValidationFlags) Free() {
	if x != nil && x.allocsffe080ad != nil {
		x.allocsffe080ad.(*cgoAllocMap).Free()
		x.refffe080ad = nil
	}
}

// NewValidationFlagsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewValidationFlagsRef(ref unsafe.Pointer) *ValidationFlags {
	if ref == nil {
		return nil
	}
	obj := new(ValidationFlags)
	obj.refffe080ad = (*C.VkValidationFlagsEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ValidationFlags) PassRef() (*C.VkValidationFlagsEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refffe080ad != nil {
		return x.refffe080ad, nil
	}
	memffe080ad := allocValidationFlagsMemory(1)
	refffe080ad := (*C.VkValidationFlagsEXT)(memffe080ad)
	allocsffe080ad := new(cgoAllocMap)
	allocsffe080ad.Add(memffe080ad)

	var csType_allocs *cgoAllocMap
	refffe080ad.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsffe080ad.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refffe080ad.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsffe080ad.Borrow(cpNext_allocs)

	var cdisabledValidationCheckCount_allocs *cgoAllocMap
	refffe080ad.disabledValidationCheckCount, cdisabledValidationCheckCount_allocs = (C.uint32_t)(x.DisabledValidationCheckCount), cgoAllocsUnknown
	allocsffe080ad.Borrow(cdisabledValidationCheckCount_allocs)

	var cpDisabledValidationChecks_allocs *cgoAllocMap
	refffe080ad.pDisabledValidationChecks, cpDisabledValidationChecks_allocs = (*C.VkValidationCheckEXT)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDisabledValidationChecks)).Data)), cgoAllocsUnknown
	allocsffe080ad.Borrow(cpDisabledValidationChecks_allocs)

	x.refffe080ad = refffe080ad
	x.allocsffe080ad = allocsffe080ad
	return refffe080ad, allocsffe080ad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ValidationFlags) PassValue() (C.VkValidationFlagsEXT, *cgoAllocMap) {
	if x.refffe080ad != nil {
		return *x.refffe080ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ValidationFlags) Deref() {
	if x.refffe080ad == nil {
		return
	}
	x.SType = (StructureType)(x.refffe080ad.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refffe080ad.pNext))
	x.DisabledValidationCheckCount = (uint32)(x.refffe080ad.disabledValidationCheckCount)
	hxf8aebb5 := (*sliceHeader)(unsafe.Pointer(&x.PDisabledValidationChecks))
	hxf8aebb5.Data = unsafe.Pointer(x.refffe080ad.pDisabledValidationChecks)
	hxf8aebb5.Cap = 0x7fffffff
	// hxf8aebb5.Len = ?

}

// allocImageViewASTCDecodeModeMemory allocates memory for type C.VkImageViewASTCDecodeModeEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageViewASTCDecodeModeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageViewASTCDecodeModeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageViewASTCDecodeModeValue = unsafe.Sizeof([1]C.VkImageViewASTCDecodeModeEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageViewASTCDecodeMode) Ref() *C.VkImageViewASTCDecodeModeEXT {
	if x == nil {
		return nil
	}
	return x.ref3a973fc0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageViewASTCDecodeMode) Free() {
	if x != nil && x.allocs3a973fc0 != nil {
		x.allocs3a973fc0.(*cgoAllocMap).Free()
		x.ref3a973fc0 = nil
	}
}

// NewImageViewASTCDecodeModeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageViewASTCDecodeModeRef(ref unsafe.Pointer) *ImageViewASTCDecodeMode {
	if ref == nil {
		return nil
	}
	obj := new(ImageViewASTCDecodeMode)
	obj.ref3a973fc0 = (*C.VkImageViewASTCDecodeModeEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageViewASTCDecodeMode) PassRef() (*C.VkImageViewASTCDecodeModeEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3a973fc0 != nil {
		return x.ref3a973fc0, nil
	}
	mem3a973fc0 := allocImageViewASTCDecodeModeMemory(1)
	ref3a973fc0 := (*C.VkImageViewASTCDecodeModeEXT)(mem3a973fc0)
	allocs3a973fc0 := new(cgoAllocMap)
	allocs3a973fc0.Add(mem3a973fc0)

	var csType_allocs *cgoAllocMap
	ref3a973fc0.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3a973fc0.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3a973fc0.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3a973fc0.Borrow(cpNext_allocs)

	var cdecodeMode_allocs *cgoAllocMap
	ref3a973fc0.decodeMode, cdecodeMode_allocs = (C.VkFormat)(x.DecodeMode), cgoAllocsUnknown
	allocs3a973fc0.Borrow(cdecodeMode_allocs)

	x.ref3a973fc0 = ref3a973fc0
	x.allocs3a973fc0 = allocs3a973fc0
	return ref3a973fc0, allocs3a973fc0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageViewASTCDecodeMode) PassValue() (C.VkImageViewASTCDecodeModeEXT, *cgoAllocMap) {
	if x.ref3a973fc0 != nil {
		return *x.ref3a973fc0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageViewASTCDecodeMode) Deref() {
	if x.ref3a973fc0 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3a973fc0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3a973fc0.pNext))
	x.DecodeMode = (Format)(x.ref3a973fc0.decodeMode)
}

// allocPhysicalDeviceASTCDecodeFeaturesMemory allocates memory for type C.VkPhysicalDeviceASTCDecodeFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceASTCDecodeFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceASTCDecodeFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceASTCDecodeFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceASTCDecodeFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceASTCDecodeFeatures) Ref() *C.VkPhysicalDeviceASTCDecodeFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refd8af7d5a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceASTCDecodeFeatures) Free() {
	if x != nil && x.allocsd8af7d5a != nil {
		x.allocsd8af7d5a.(*cgoAllocMap).Free()
		x.refd8af7d5a = nil
	}
}

// NewPhysicalDeviceASTCDecodeFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceASTCDecodeFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceASTCDecodeFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceASTCDecodeFeatures)
	obj.refd8af7d5a = (*C.VkPhysicalDeviceASTCDecodeFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceASTCDecodeFeatures) PassRef() (*C.VkPhysicalDeviceASTCDecodeFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd8af7d5a != nil {
		return x.refd8af7d5a, nil
	}
	memd8af7d5a := allocPhysicalDeviceASTCDecodeFeaturesMemory(1)
	refd8af7d5a := (*C.VkPhysicalDeviceASTCDecodeFeaturesEXT)(memd8af7d5a)
	allocsd8af7d5a := new(cgoAllocMap)
	allocsd8af7d5a.Add(memd8af7d5a)

	var csType_allocs *cgoAllocMap
	refd8af7d5a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd8af7d5a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd8af7d5a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd8af7d5a.Borrow(cpNext_allocs)

	var cdecodeModeSharedExponent_allocs *cgoAllocMap
	refd8af7d5a.decodeModeSharedExponent, cdecodeModeSharedExponent_allocs = (C.VkBool32)(x.DecodeModeSharedExponent), cgoAllocsUnknown
	allocsd8af7d5a.Borrow(cdecodeModeSharedExponent_allocs)

	x.refd8af7d5a = refd8af7d5a
	x.allocsd8af7d5a = allocsd8af7d5a
	return refd8af7d5a, allocsd8af7d5a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceASTCDecodeFeatures) PassValue() (C.VkPhysicalDeviceASTCDecodeFeaturesEXT, *cgoAllocMap) {
	if x.refd8af7d5a != nil {
		return *x.refd8af7d5a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceASTCDecodeFeatures) Deref() {
	if x.refd8af7d5a == nil {
		return
	}
	x.SType = (StructureType)(x.refd8af7d5a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd8af7d5a.pNext))
	x.DecodeModeSharedExponent = (Bool32)(x.refd8af7d5a.decodeModeSharedExponent)
}

// allocConditionalRenderingBeginInfoMemory allocates memory for type C.VkConditionalRenderingBeginInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocConditionalRenderingBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfConditionalRenderingBeginInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfConditionalRenderingBeginInfoValue = unsafe.Sizeof([1]C.VkConditionalRenderingBeginInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConditionalRenderingBeginInfo) Ref() *C.VkConditionalRenderingBeginInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref82da87c9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConditionalRenderingBeginInfo) Free() {
	if x != nil && x.allocs82da87c9 != nil {
		x.allocs82da87c9.(*cgoAllocMap).Free()
		x.ref82da87c9 = nil
	}
}

// NewConditionalRenderingBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConditionalRenderingBeginInfoRef(ref unsafe.Pointer) *ConditionalRenderingBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(ConditionalRenderingBeginInfo)
	obj.ref82da87c9 = (*C.VkConditionalRenderingBeginInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConditionalRenderingBeginInfo) PassRef() (*C.VkConditionalRenderingBeginInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref82da87c9 != nil {
		return x.ref82da87c9, nil
	}
	mem82da87c9 := allocConditionalRenderingBeginInfoMemory(1)
	ref82da87c9 := (*C.VkConditionalRenderingBeginInfoEXT)(mem82da87c9)
	allocs82da87c9 := new(cgoAllocMap)
	allocs82da87c9.Add(mem82da87c9)

	var csType_allocs *cgoAllocMap
	ref82da87c9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs82da87c9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref82da87c9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs82da87c9.Borrow(cpNext_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref82da87c9.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs82da87c9.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	ref82da87c9.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs82da87c9.Borrow(coffset_allocs)

	var cflags_allocs *cgoAllocMap
	ref82da87c9.flags, cflags_allocs = (C.VkConditionalRenderingFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocs82da87c9.Borrow(cflags_allocs)

	x.ref82da87c9 = ref82da87c9
	x.allocs82da87c9 = allocs82da87c9
	return ref82da87c9, allocs82da87c9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConditionalRenderingBeginInfo) PassValue() (C.VkConditionalRenderingBeginInfoEXT, *cgoAllocMap) {
	if x.ref82da87c9 != nil {
		return *x.ref82da87c9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConditionalRenderingBeginInfo) Deref() {
	if x.ref82da87c9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref82da87c9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref82da87c9.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref82da87c9.buffer))
	x.Offset = (DeviceSize)(x.ref82da87c9.offset)
	x.Flags = (ConditionalRenderingFlags)(x.ref82da87c9.flags)
}

// allocPhysicalDeviceConditionalRenderingFeaturesMemory allocates memory for type C.VkPhysicalDeviceConditionalRenderingFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceConditionalRenderingFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceConditionalRenderingFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceConditionalRenderingFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceConditionalRenderingFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceConditionalRenderingFeatures) Ref() *C.VkPhysicalDeviceConditionalRenderingFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref89d2a224
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceConditionalRenderingFeatures) Free() {
	if x != nil && x.allocs89d2a224 != nil {
		x.allocs89d2a224.(*cgoAllocMap).Free()
		x.ref89d2a224 = nil
	}
}

// NewPhysicalDeviceConditionalRenderingFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceConditionalRenderingFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceConditionalRenderingFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceConditionalRenderingFeatures)
	obj.ref89d2a224 = (*C.VkPhysicalDeviceConditionalRenderingFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceConditionalRenderingFeatures) PassRef() (*C.VkPhysicalDeviceConditionalRenderingFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref89d2a224 != nil {
		return x.ref89d2a224, nil
	}
	mem89d2a224 := allocPhysicalDeviceConditionalRenderingFeaturesMemory(1)
	ref89d2a224 := (*C.VkPhysicalDeviceConditionalRenderingFeaturesEXT)(mem89d2a224)
	allocs89d2a224 := new(cgoAllocMap)
	allocs89d2a224.Add(mem89d2a224)

	var csType_allocs *cgoAllocMap
	ref89d2a224.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs89d2a224.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref89d2a224.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs89d2a224.Borrow(cpNext_allocs)

	var cconditionalRendering_allocs *cgoAllocMap
	ref89d2a224.conditionalRendering, cconditionalRendering_allocs = (C.VkBool32)(x.ConditionalRendering), cgoAllocsUnknown
	allocs89d2a224.Borrow(cconditionalRendering_allocs)

	var cinheritedConditionalRendering_allocs *cgoAllocMap
	ref89d2a224.inheritedConditionalRendering, cinheritedConditionalRendering_allocs = (C.VkBool32)(x.InheritedConditionalRendering), cgoAllocsUnknown
	allocs89d2a224.Borrow(cinheritedConditionalRendering_allocs)

	x.ref89d2a224 = ref89d2a224
	x.allocs89d2a224 = allocs89d2a224
	return ref89d2a224, allocs89d2a224

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceConditionalRenderingFeatures) PassValue() (C.VkPhysicalDeviceConditionalRenderingFeaturesEXT, *cgoAllocMap) {
	if x.ref89d2a224 != nil {
		return *x.ref89d2a224, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceConditionalRenderingFeatures) Deref() {
	if x.ref89d2a224 == nil {
		return
	}
	x.SType = (StructureType)(x.ref89d2a224.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref89d2a224.pNext))
	x.ConditionalRendering = (Bool32)(x.ref89d2a224.conditionalRendering)
	x.InheritedConditionalRendering = (Bool32)(x.ref89d2a224.inheritedConditionalRendering)
}

// allocCommandBufferInheritanceConditionalRenderingInfoMemory allocates memory for type C.VkCommandBufferInheritanceConditionalRenderingInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferInheritanceConditionalRenderingInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferInheritanceConditionalRenderingInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCommandBufferInheritanceConditionalRenderingInfoValue = unsafe.Sizeof([1]C.VkCommandBufferInheritanceConditionalRenderingInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferInheritanceConditionalRenderingInfo) Ref() *C.VkCommandBufferInheritanceConditionalRenderingInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref7155f49c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferInheritanceConditionalRenderingInfo) Free() {
	if x != nil && x.allocs7155f49c != nil {
		x.allocs7155f49c.(*cgoAllocMap).Free()
		x.ref7155f49c = nil
	}
}

// NewCommandBufferInheritanceConditionalRenderingInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferInheritanceConditionalRenderingInfoRef(ref unsafe.Pointer) *CommandBufferInheritanceConditionalRenderingInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferInheritanceConditionalRenderingInfo)
	obj.ref7155f49c = (*C.VkCommandBufferInheritanceConditionalRenderingInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferInheritanceConditionalRenderingInfo) PassRef() (*C.VkCommandBufferInheritanceConditionalRenderingInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7155f49c != nil {
		return x.ref7155f49c, nil
	}
	mem7155f49c := allocCommandBufferInheritanceConditionalRenderingInfoMemory(1)
	ref7155f49c := (*C.VkCommandBufferInheritanceConditionalRenderingInfoEXT)(mem7155f49c)
	allocs7155f49c := new(cgoAllocMap)
	allocs7155f49c.Add(mem7155f49c)

	var csType_allocs *cgoAllocMap
	ref7155f49c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7155f49c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7155f49c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7155f49c.Borrow(cpNext_allocs)

	var cconditionalRenderingEnable_allocs *cgoAllocMap
	ref7155f49c.conditionalRenderingEnable, cconditionalRenderingEnable_allocs = (C.VkBool32)(x.ConditionalRenderingEnable), cgoAllocsUnknown
	allocs7155f49c.Borrow(cconditionalRenderingEnable_allocs)

	x.ref7155f49c = ref7155f49c
	x.allocs7155f49c = allocs7155f49c
	return ref7155f49c, allocs7155f49c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferInheritanceConditionalRenderingInfo) PassValue() (C.VkCommandBufferInheritanceConditionalRenderingInfoEXT, *cgoAllocMap) {
	if x.ref7155f49c != nil {
		return *x.ref7155f49c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferInheritanceConditionalRenderingInfo) Deref() {
	if x.ref7155f49c == nil {
		return
	}
	x.SType = (StructureType)(x.ref7155f49c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7155f49c.pNext))
	x.ConditionalRenderingEnable = (Bool32)(x.ref7155f49c.conditionalRenderingEnable)
}

// allocDeviceGeneratedCommandsFeaturesNVXMemory allocates memory for type C.VkDeviceGeneratedCommandsFeaturesNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGeneratedCommandsFeaturesNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGeneratedCommandsFeaturesNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGeneratedCommandsFeaturesNVXValue = unsafe.Sizeof([1]C.VkDeviceGeneratedCommandsFeaturesNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGeneratedCommandsFeaturesNVX) Ref() *C.VkDeviceGeneratedCommandsFeaturesNVX {
	if x == nil {
		return nil
	}
	return x.ref489899be
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGeneratedCommandsFeaturesNVX) Free() {
	if x != nil && x.allocs489899be != nil {
		x.allocs489899be.(*cgoAllocMap).Free()
		x.ref489899be = nil
	}
}

// NewDeviceGeneratedCommandsFeaturesNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGeneratedCommandsFeaturesNVXRef(ref unsafe.Pointer) *DeviceGeneratedCommandsFeaturesNVX {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGeneratedCommandsFeaturesNVX)
	obj.ref489899be = (*C.VkDeviceGeneratedCommandsFeaturesNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGeneratedCommandsFeaturesNVX) PassRef() (*C.VkDeviceGeneratedCommandsFeaturesNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref489899be != nil {
		return x.ref489899be, nil
	}
	mem489899be := allocDeviceGeneratedCommandsFeaturesNVXMemory(1)
	ref489899be := (*C.VkDeviceGeneratedCommandsFeaturesNVX)(mem489899be)
	allocs489899be := new(cgoAllocMap)
	allocs489899be.Add(mem489899be)

	var csType_allocs *cgoAllocMap
	ref489899be.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs489899be.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref489899be.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs489899be.Borrow(cpNext_allocs)

	var ccomputeBindingPointSupport_allocs *cgoAllocMap
	ref489899be.computeBindingPointSupport, ccomputeBindingPointSupport_allocs = (C.VkBool32)(x.ComputeBindingPointSupport), cgoAllocsUnknown
	allocs489899be.Borrow(ccomputeBindingPointSupport_allocs)

	x.ref489899be = ref489899be
	x.allocs489899be = allocs489899be
	return ref489899be, allocs489899be

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGeneratedCommandsFeaturesNVX) PassValue() (C.VkDeviceGeneratedCommandsFeaturesNVX, *cgoAllocMap) {
	if x.ref489899be != nil {
		return *x.ref489899be, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGeneratedCommandsFeaturesNVX) Deref() {
	if x.ref489899be == nil {
		return
	}
	x.SType = (StructureType)(x.ref489899be.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref489899be.pNext))
	x.ComputeBindingPointSupport = (Bool32)(x.ref489899be.computeBindingPointSupport)
}

// allocDeviceGeneratedCommandsLimitsNVXMemory allocates memory for type C.VkDeviceGeneratedCommandsLimitsNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGeneratedCommandsLimitsNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGeneratedCommandsLimitsNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceGeneratedCommandsLimitsNVXValue = unsafe.Sizeof([1]C.VkDeviceGeneratedCommandsLimitsNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGeneratedCommandsLimitsNVX) Ref() *C.VkDeviceGeneratedCommandsLimitsNVX {
	if x == nil {
		return nil
	}
	return x.refb2b76f40
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGeneratedCommandsLimitsNVX) Free() {
	if x != nil && x.allocsb2b76f40 != nil {
		x.allocsb2b76f40.(*cgoAllocMap).Free()
		x.refb2b76f40 = nil
	}
}

// NewDeviceGeneratedCommandsLimitsNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGeneratedCommandsLimitsNVXRef(ref unsafe.Pointer) *DeviceGeneratedCommandsLimitsNVX {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGeneratedCommandsLimitsNVX)
	obj.refb2b76f40 = (*C.VkDeviceGeneratedCommandsLimitsNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGeneratedCommandsLimitsNVX) PassRef() (*C.VkDeviceGeneratedCommandsLimitsNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb2b76f40 != nil {
		return x.refb2b76f40, nil
	}
	memb2b76f40 := allocDeviceGeneratedCommandsLimitsNVXMemory(1)
	refb2b76f40 := (*C.VkDeviceGeneratedCommandsLimitsNVX)(memb2b76f40)
	allocsb2b76f40 := new(cgoAllocMap)
	allocsb2b76f40.Add(memb2b76f40)

	var csType_allocs *cgoAllocMap
	refb2b76f40.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb2b76f40.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb2b76f40.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb2b76f40.Borrow(cpNext_allocs)

	var cmaxIndirectCommandsLayoutTokenCount_allocs *cgoAllocMap
	refb2b76f40.maxIndirectCommandsLayoutTokenCount, cmaxIndirectCommandsLayoutTokenCount_allocs = (C.uint32_t)(x.MaxIndirectCommandsLayoutTokenCount), cgoAllocsUnknown
	allocsb2b76f40.Borrow(cmaxIndirectCommandsLayoutTokenCount_allocs)

	var cmaxObjectEntryCounts_allocs *cgoAllocMap
	refb2b76f40.maxObjectEntryCounts, cmaxObjectEntryCounts_allocs = (C.uint32_t)(x.MaxObjectEntryCounts), cgoAllocsUnknown
	allocsb2b76f40.Borrow(cmaxObjectEntryCounts_allocs)

	var cminSequenceCountBufferOffsetAlignment_allocs *cgoAllocMap
	refb2b76f40.minSequenceCountBufferOffsetAlignment, cminSequenceCountBufferOffsetAlignment_allocs = (C.uint32_t)(x.MinSequenceCountBufferOffsetAlignment), cgoAllocsUnknown
	allocsb2b76f40.Borrow(cminSequenceCountBufferOffsetAlignment_allocs)

	var cminSequenceIndexBufferOffsetAlignment_allocs *cgoAllocMap
	refb2b76f40.minSequenceIndexBufferOffsetAlignment, cminSequenceIndexBufferOffsetAlignment_allocs = (C.uint32_t)(x.MinSequenceIndexBufferOffsetAlignment), cgoAllocsUnknown
	allocsb2b76f40.Borrow(cminSequenceIndexBufferOffsetAlignment_allocs)

	var cminCommandsTokenBufferOffsetAlignment_allocs *cgoAllocMap
	refb2b76f40.minCommandsTokenBufferOffsetAlignment, cminCommandsTokenBufferOffsetAlignment_allocs = (C.uint32_t)(x.MinCommandsTokenBufferOffsetAlignment), cgoAllocsUnknown
	allocsb2b76f40.Borrow(cminCommandsTokenBufferOffsetAlignment_allocs)

	x.refb2b76f40 = refb2b76f40
	x.allocsb2b76f40 = allocsb2b76f40
	return refb2b76f40, allocsb2b76f40

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGeneratedCommandsLimitsNVX) PassValue() (C.VkDeviceGeneratedCommandsLimitsNVX, *cgoAllocMap) {
	if x.refb2b76f40 != nil {
		return *x.refb2b76f40, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGeneratedCommandsLimitsNVX) Deref() {
	if x.refb2b76f40 == nil {
		return
	}
	x.SType = (StructureType)(x.refb2b76f40.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb2b76f40.pNext))
	x.MaxIndirectCommandsLayoutTokenCount = (uint32)(x.refb2b76f40.maxIndirectCommandsLayoutTokenCount)
	x.MaxObjectEntryCounts = (uint32)(x.refb2b76f40.maxObjectEntryCounts)
	x.MinSequenceCountBufferOffsetAlignment = (uint32)(x.refb2b76f40.minSequenceCountBufferOffsetAlignment)
	x.MinSequenceIndexBufferOffsetAlignment = (uint32)(x.refb2b76f40.minSequenceIndexBufferOffsetAlignment)
	x.MinCommandsTokenBufferOffsetAlignment = (uint32)(x.refb2b76f40.minCommandsTokenBufferOffsetAlignment)
}

// allocIndirectCommandsTokenNVXMemory allocates memory for type C.VkIndirectCommandsTokenNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIndirectCommandsTokenNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIndirectCommandsTokenNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfIndirectCommandsTokenNVXValue = unsafe.Sizeof([1]C.VkIndirectCommandsTokenNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *IndirectCommandsTokenNVX) Ref() *C.VkIndirectCommandsTokenNVX {
	if x == nil {
		return nil
	}
	return x.ref8a2daca5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *IndirectCommandsTokenNVX) Free() {
	if x != nil && x.allocs8a2daca5 != nil {
		x.allocs8a2daca5.(*cgoAllocMap).Free()
		x.ref8a2daca5 = nil
	}
}

// NewIndirectCommandsTokenNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewIndirectCommandsTokenNVXRef(ref unsafe.Pointer) *IndirectCommandsTokenNVX {
	if ref == nil {
		return nil
	}
	obj := new(IndirectCommandsTokenNVX)
	obj.ref8a2daca5 = (*C.VkIndirectCommandsTokenNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *IndirectCommandsTokenNVX) PassRef() (*C.VkIndirectCommandsTokenNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8a2daca5 != nil {
		return x.ref8a2daca5, nil
	}
	mem8a2daca5 := allocIndirectCommandsTokenNVXMemory(1)
	ref8a2daca5 := (*C.VkIndirectCommandsTokenNVX)(mem8a2daca5)
	allocs8a2daca5 := new(cgoAllocMap)
	allocs8a2daca5.Add(mem8a2daca5)

	var ctokenType_allocs *cgoAllocMap
	ref8a2daca5.tokenType, ctokenType_allocs = (C.VkIndirectCommandsTokenTypeNVX)(x.TokenType), cgoAllocsUnknown
	allocs8a2daca5.Borrow(ctokenType_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref8a2daca5.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs8a2daca5.Borrow(cbuffer_allocs)

	var coffset_allocs *cgoAllocMap
	ref8a2daca5.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocs8a2daca5.Borrow(coffset_allocs)

	x.ref8a2daca5 = ref8a2daca5
	x.allocs8a2daca5 = allocs8a2daca5
	return ref8a2daca5, allocs8a2daca5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x IndirectCommandsTokenNVX) PassValue() (C.VkIndirectCommandsTokenNVX, *cgoAllocMap) {
	if x.ref8a2daca5 != nil {
		return *x.ref8a2daca5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *IndirectCommandsTokenNVX) Deref() {
	if x.ref8a2daca5 == nil {
		return
	}
	x.TokenType = (IndirectCommandsTokenTypeNVX)(x.ref8a2daca5.tokenType)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref8a2daca5.buffer))
	x.Offset = (DeviceSize)(x.ref8a2daca5.offset)
}

// allocIndirectCommandsLayoutTokenNVXMemory allocates memory for type C.VkIndirectCommandsLayoutTokenNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIndirectCommandsLayoutTokenNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIndirectCommandsLayoutTokenNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfIndirectCommandsLayoutTokenNVXValue = unsafe.Sizeof([1]C.VkIndirectCommandsLayoutTokenNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *IndirectCommandsLayoutTokenNVX) Ref() *C.VkIndirectCommandsLayoutTokenNVX {
	if x == nil {
		return nil
	}
	return x.refe421769
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *IndirectCommandsLayoutTokenNVX) Free() {
	if x != nil && x.allocse421769 != nil {
		x.allocse421769.(*cgoAllocMap).Free()
		x.refe421769 = nil
	}
}

// NewIndirectCommandsLayoutTokenNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewIndirectCommandsLayoutTokenNVXRef(ref unsafe.Pointer) *IndirectCommandsLayoutTokenNVX {
	if ref == nil {
		return nil
	}
	obj := new(IndirectCommandsLayoutTokenNVX)
	obj.refe421769 = (*C.VkIndirectCommandsLayoutTokenNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *IndirectCommandsLayoutTokenNVX) PassRef() (*C.VkIndirectCommandsLayoutTokenNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe421769 != nil {
		return x.refe421769, nil
	}
	meme421769 := allocIndirectCommandsLayoutTokenNVXMemory(1)
	refe421769 := (*C.VkIndirectCommandsLayoutTokenNVX)(meme421769)
	allocse421769 := new(cgoAllocMap)
	allocse421769.Add(meme421769)

	var ctokenType_allocs *cgoAllocMap
	refe421769.tokenType, ctokenType_allocs = (C.VkIndirectCommandsTokenTypeNVX)(x.TokenType), cgoAllocsUnknown
	allocse421769.Borrow(ctokenType_allocs)

	var cbindingUnit_allocs *cgoAllocMap
	refe421769.bindingUnit, cbindingUnit_allocs = (C.uint32_t)(x.BindingUnit), cgoAllocsUnknown
	allocse421769.Borrow(cbindingUnit_allocs)

	var cdynamicCount_allocs *cgoAllocMap
	refe421769.dynamicCount, cdynamicCount_allocs = (C.uint32_t)(x.DynamicCount), cgoAllocsUnknown
	allocse421769.Borrow(cdynamicCount_allocs)

	var cdivisor_allocs *cgoAllocMap
	refe421769.divisor, cdivisor_allocs = (C.uint32_t)(x.Divisor), cgoAllocsUnknown
	allocse421769.Borrow(cdivisor_allocs)

	x.refe421769 = refe421769
	x.allocse421769 = allocse421769
	return refe421769, allocse421769

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x IndirectCommandsLayoutTokenNVX) PassValue() (C.VkIndirectCommandsLayoutTokenNVX, *cgoAllocMap) {
	if x.refe421769 != nil {
		return *x.refe421769, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *IndirectCommandsLayoutTokenNVX) Deref() {
	if x.refe421769 == nil {
		return
	}
	x.TokenType = (IndirectCommandsTokenTypeNVX)(x.refe421769.tokenType)
	x.BindingUnit = (uint32)(x.refe421769.bindingUnit)
	x.DynamicCount = (uint32)(x.refe421769.dynamicCount)
	x.Divisor = (uint32)(x.refe421769.divisor)
}

// allocIndirectCommandsLayoutCreateInfoNVXMemory allocates memory for type C.VkIndirectCommandsLayoutCreateInfoNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIndirectCommandsLayoutCreateInfoNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIndirectCommandsLayoutCreateInfoNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfIndirectCommandsLayoutCreateInfoNVXValue = unsafe.Sizeof([1]C.VkIndirectCommandsLayoutCreateInfoNVX{})

// unpackSIndirectCommandsLayoutTokenNVX transforms a sliced Go data structure into plain C format.
func unpackSIndirectCommandsLayoutTokenNVX(x []IndirectCommandsLayoutTokenNVX) (unpacked *C.VkIndirectCommandsLayoutTokenNVX, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkIndirectCommandsLayoutTokenNVX) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocIndirectCommandsLayoutTokenNVXMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkIndirectCommandsLayoutTokenNVX)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkIndirectCommandsLayoutTokenNVX)(h.Data)
	return
}

// packSIndirectCommandsLayoutTokenNVX reads sliced Go data structure out from plain C format.
func packSIndirectCommandsLayoutTokenNVX(v []IndirectCommandsLayoutTokenNVX, ptr0 *C.VkIndirectCommandsLayoutTokenNVX) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfIndirectCommandsLayoutTokenNVXValue]C.VkIndirectCommandsLayoutTokenNVX)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewIndirectCommandsLayoutTokenNVXRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *IndirectCommandsLayoutCreateInfoNVX) Ref() *C.VkIndirectCommandsLayoutCreateInfoNVX {
	if x == nil {
		return nil
	}
	return x.ref2a2866d5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *IndirectCommandsLayoutCreateInfoNVX) Free() {
	if x != nil && x.allocs2a2866d5 != nil {
		x.allocs2a2866d5.(*cgoAllocMap).Free()
		x.ref2a2866d5 = nil
	}
}

// NewIndirectCommandsLayoutCreateInfoNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewIndirectCommandsLayoutCreateInfoNVXRef(ref unsafe.Pointer) *IndirectCommandsLayoutCreateInfoNVX {
	if ref == nil {
		return nil
	}
	obj := new(IndirectCommandsLayoutCreateInfoNVX)
	obj.ref2a2866d5 = (*C.VkIndirectCommandsLayoutCreateInfoNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *IndirectCommandsLayoutCreateInfoNVX) PassRef() (*C.VkIndirectCommandsLayoutCreateInfoNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2a2866d5 != nil {
		return x.ref2a2866d5, nil
	}
	mem2a2866d5 := allocIndirectCommandsLayoutCreateInfoNVXMemory(1)
	ref2a2866d5 := (*C.VkIndirectCommandsLayoutCreateInfoNVX)(mem2a2866d5)
	allocs2a2866d5 := new(cgoAllocMap)
	allocs2a2866d5.Add(mem2a2866d5)

	var csType_allocs *cgoAllocMap
	ref2a2866d5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2a2866d5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2a2866d5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2a2866d5.Borrow(cpNext_allocs)

	var cpipelineBindPoint_allocs *cgoAllocMap
	ref2a2866d5.pipelineBindPoint, cpipelineBindPoint_allocs = (C.VkPipelineBindPoint)(x.PipelineBindPoint), cgoAllocsUnknown
	allocs2a2866d5.Borrow(cpipelineBindPoint_allocs)

	var cflags_allocs *cgoAllocMap
	ref2a2866d5.flags, cflags_allocs = (C.VkIndirectCommandsLayoutUsageFlagsNVX)(x.Flags), cgoAllocsUnknown
	allocs2a2866d5.Borrow(cflags_allocs)

	var ctokenCount_allocs *cgoAllocMap
	ref2a2866d5.tokenCount, ctokenCount_allocs = (C.uint32_t)(x.TokenCount), cgoAllocsUnknown
	allocs2a2866d5.Borrow(ctokenCount_allocs)

	var cpTokens_allocs *cgoAllocMap
	ref2a2866d5.pTokens, cpTokens_allocs = unpackSIndirectCommandsLayoutTokenNVX(x.PTokens)
	allocs2a2866d5.Borrow(cpTokens_allocs)

	x.ref2a2866d5 = ref2a2866d5
	x.allocs2a2866d5 = allocs2a2866d5
	return ref2a2866d5, allocs2a2866d5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x IndirectCommandsLayoutCreateInfoNVX) PassValue() (C.VkIndirectCommandsLayoutCreateInfoNVX, *cgoAllocMap) {
	if x.ref2a2866d5 != nil {
		return *x.ref2a2866d5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *IndirectCommandsLayoutCreateInfoNVX) Deref() {
	if x.ref2a2866d5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2a2866d5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2a2866d5.pNext))
	x.PipelineBindPoint = (PipelineBindPoint)(x.ref2a2866d5.pipelineBindPoint)
	x.Flags = (IndirectCommandsLayoutUsageFlagsNVX)(x.ref2a2866d5.flags)
	x.TokenCount = (uint32)(x.ref2a2866d5.tokenCount)
	packSIndirectCommandsLayoutTokenNVX(x.PTokens, x.ref2a2866d5.pTokens)
}

// allocCmdProcessCommandsInfoNVXMemory allocates memory for type C.VkCmdProcessCommandsInfoNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCmdProcessCommandsInfoNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCmdProcessCommandsInfoNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCmdProcessCommandsInfoNVXValue = unsafe.Sizeof([1]C.VkCmdProcessCommandsInfoNVX{})

// unpackSIndirectCommandsTokenNVX transforms a sliced Go data structure into plain C format.
func unpackSIndirectCommandsTokenNVX(x []IndirectCommandsTokenNVX) (unpacked *C.VkIndirectCommandsTokenNVX, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkIndirectCommandsTokenNVX) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocIndirectCommandsTokenNVXMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkIndirectCommandsTokenNVX)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkIndirectCommandsTokenNVX)(h.Data)
	return
}

// packSIndirectCommandsTokenNVX reads sliced Go data structure out from plain C format.
func packSIndirectCommandsTokenNVX(v []IndirectCommandsTokenNVX, ptr0 *C.VkIndirectCommandsTokenNVX) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfIndirectCommandsTokenNVXValue]C.VkIndirectCommandsTokenNVX)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewIndirectCommandsTokenNVXRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CmdProcessCommandsInfoNVX) Ref() *C.VkCmdProcessCommandsInfoNVX {
	if x == nil {
		return nil
	}
	return x.refcd94895d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CmdProcessCommandsInfoNVX) Free() {
	if x != nil && x.allocscd94895d != nil {
		x.allocscd94895d.(*cgoAllocMap).Free()
		x.refcd94895d = nil
	}
}

// NewCmdProcessCommandsInfoNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCmdProcessCommandsInfoNVXRef(ref unsafe.Pointer) *CmdProcessCommandsInfoNVX {
	if ref == nil {
		return nil
	}
	obj := new(CmdProcessCommandsInfoNVX)
	obj.refcd94895d = (*C.VkCmdProcessCommandsInfoNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CmdProcessCommandsInfoNVX) PassRef() (*C.VkCmdProcessCommandsInfoNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcd94895d != nil {
		return x.refcd94895d, nil
	}
	memcd94895d := allocCmdProcessCommandsInfoNVXMemory(1)
	refcd94895d := (*C.VkCmdProcessCommandsInfoNVX)(memcd94895d)
	allocscd94895d := new(cgoAllocMap)
	allocscd94895d.Add(memcd94895d)

	var csType_allocs *cgoAllocMap
	refcd94895d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscd94895d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcd94895d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscd94895d.Borrow(cpNext_allocs)

	var cobjectTable_allocs *cgoAllocMap
	refcd94895d.objectTable, cobjectTable_allocs = *(*C.VkObjectTableNVX)(unsafe.Pointer(&x.ObjectTable)), cgoAllocsUnknown
	allocscd94895d.Borrow(cobjectTable_allocs)

	var cindirectCommandsLayout_allocs *cgoAllocMap
	refcd94895d.indirectCommandsLayout, cindirectCommandsLayout_allocs = *(*C.VkIndirectCommandsLayoutNVX)(unsafe.Pointer(&x.IndirectCommandsLayout)), cgoAllocsUnknown
	allocscd94895d.Borrow(cindirectCommandsLayout_allocs)

	var cindirectCommandsTokenCount_allocs *cgoAllocMap
	refcd94895d.indirectCommandsTokenCount, cindirectCommandsTokenCount_allocs = (C.uint32_t)(x.IndirectCommandsTokenCount), cgoAllocsUnknown
	allocscd94895d.Borrow(cindirectCommandsTokenCount_allocs)

	var cpIndirectCommandsTokens_allocs *cgoAllocMap
	refcd94895d.pIndirectCommandsTokens, cpIndirectCommandsTokens_allocs = unpackSIndirectCommandsTokenNVX(x.PIndirectCommandsTokens)
	allocscd94895d.Borrow(cpIndirectCommandsTokens_allocs)

	var cmaxSequencesCount_allocs *cgoAllocMap
	refcd94895d.maxSequencesCount, cmaxSequencesCount_allocs = (C.uint32_t)(x.MaxSequencesCount), cgoAllocsUnknown
	allocscd94895d.Borrow(cmaxSequencesCount_allocs)

	var ctargetCommandBuffer_allocs *cgoAllocMap
	refcd94895d.targetCommandBuffer, ctargetCommandBuffer_allocs = *(*C.VkCommandBuffer)(unsafe.Pointer(&x.TargetCommandBuffer)), cgoAllocsUnknown
	allocscd94895d.Borrow(ctargetCommandBuffer_allocs)

	var csequencesCountBuffer_allocs *cgoAllocMap
	refcd94895d.sequencesCountBuffer, csequencesCountBuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.SequencesCountBuffer)), cgoAllocsUnknown
	allocscd94895d.Borrow(csequencesCountBuffer_allocs)

	var csequencesCountOffset_allocs *cgoAllocMap
	refcd94895d.sequencesCountOffset, csequencesCountOffset_allocs = (C.VkDeviceSize)(x.SequencesCountOffset), cgoAllocsUnknown
	allocscd94895d.Borrow(csequencesCountOffset_allocs)

	var csequencesIndexBuffer_allocs *cgoAllocMap
	refcd94895d.sequencesIndexBuffer, csequencesIndexBuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.SequencesIndexBuffer)), cgoAllocsUnknown
	allocscd94895d.Borrow(csequencesIndexBuffer_allocs)

	var csequencesIndexOffset_allocs *cgoAllocMap
	refcd94895d.sequencesIndexOffset, csequencesIndexOffset_allocs = (C.VkDeviceSize)(x.SequencesIndexOffset), cgoAllocsUnknown
	allocscd94895d.Borrow(csequencesIndexOffset_allocs)

	x.refcd94895d = refcd94895d
	x.allocscd94895d = allocscd94895d
	return refcd94895d, allocscd94895d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CmdProcessCommandsInfoNVX) PassValue() (C.VkCmdProcessCommandsInfoNVX, *cgoAllocMap) {
	if x.refcd94895d != nil {
		return *x.refcd94895d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CmdProcessCommandsInfoNVX) Deref() {
	if x.refcd94895d == nil {
		return
	}
	x.SType = (StructureType)(x.refcd94895d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcd94895d.pNext))
	x.ObjectTable = *(*ObjectTableNVX)(unsafe.Pointer(&x.refcd94895d.objectTable))
	x.IndirectCommandsLayout = *(*IndirectCommandsLayoutNVX)(unsafe.Pointer(&x.refcd94895d.indirectCommandsLayout))
	x.IndirectCommandsTokenCount = (uint32)(x.refcd94895d.indirectCommandsTokenCount)
	packSIndirectCommandsTokenNVX(x.PIndirectCommandsTokens, x.refcd94895d.pIndirectCommandsTokens)
	x.MaxSequencesCount = (uint32)(x.refcd94895d.maxSequencesCount)
	x.TargetCommandBuffer = *(*CommandBuffer)(unsafe.Pointer(&x.refcd94895d.targetCommandBuffer))
	x.SequencesCountBuffer = *(*Buffer)(unsafe.Pointer(&x.refcd94895d.sequencesCountBuffer))
	x.SequencesCountOffset = (DeviceSize)(x.refcd94895d.sequencesCountOffset)
	x.SequencesIndexBuffer = *(*Buffer)(unsafe.Pointer(&x.refcd94895d.sequencesIndexBuffer))
	x.SequencesIndexOffset = (DeviceSize)(x.refcd94895d.sequencesIndexOffset)
}

// allocCmdReserveSpaceForCommandsInfoNVXMemory allocates memory for type C.VkCmdReserveSpaceForCommandsInfoNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCmdReserveSpaceForCommandsInfoNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCmdReserveSpaceForCommandsInfoNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCmdReserveSpaceForCommandsInfoNVXValue = unsafe.Sizeof([1]C.VkCmdReserveSpaceForCommandsInfoNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CmdReserveSpaceForCommandsInfoNVX) Ref() *C.VkCmdReserveSpaceForCommandsInfoNVX {
	if x == nil {
		return nil
	}
	return x.ref900bfee5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CmdReserveSpaceForCommandsInfoNVX) Free() {
	if x != nil && x.allocs900bfee5 != nil {
		x.allocs900bfee5.(*cgoAllocMap).Free()
		x.ref900bfee5 = nil
	}
}

// NewCmdReserveSpaceForCommandsInfoNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCmdReserveSpaceForCommandsInfoNVXRef(ref unsafe.Pointer) *CmdReserveSpaceForCommandsInfoNVX {
	if ref == nil {
		return nil
	}
	obj := new(CmdReserveSpaceForCommandsInfoNVX)
	obj.ref900bfee5 = (*C.VkCmdReserveSpaceForCommandsInfoNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CmdReserveSpaceForCommandsInfoNVX) PassRef() (*C.VkCmdReserveSpaceForCommandsInfoNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref900bfee5 != nil {
		return x.ref900bfee5, nil
	}
	mem900bfee5 := allocCmdReserveSpaceForCommandsInfoNVXMemory(1)
	ref900bfee5 := (*C.VkCmdReserveSpaceForCommandsInfoNVX)(mem900bfee5)
	allocs900bfee5 := new(cgoAllocMap)
	allocs900bfee5.Add(mem900bfee5)

	var csType_allocs *cgoAllocMap
	ref900bfee5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs900bfee5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref900bfee5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs900bfee5.Borrow(cpNext_allocs)

	var cobjectTable_allocs *cgoAllocMap
	ref900bfee5.objectTable, cobjectTable_allocs = *(*C.VkObjectTableNVX)(unsafe.Pointer(&x.ObjectTable)), cgoAllocsUnknown
	allocs900bfee5.Borrow(cobjectTable_allocs)

	var cindirectCommandsLayout_allocs *cgoAllocMap
	ref900bfee5.indirectCommandsLayout, cindirectCommandsLayout_allocs = *(*C.VkIndirectCommandsLayoutNVX)(unsafe.Pointer(&x.IndirectCommandsLayout)), cgoAllocsUnknown
	allocs900bfee5.Borrow(cindirectCommandsLayout_allocs)

	var cmaxSequencesCount_allocs *cgoAllocMap
	ref900bfee5.maxSequencesCount, cmaxSequencesCount_allocs = (C.uint32_t)(x.MaxSequencesCount), cgoAllocsUnknown
	allocs900bfee5.Borrow(cmaxSequencesCount_allocs)

	x.ref900bfee5 = ref900bfee5
	x.allocs900bfee5 = allocs900bfee5
	return ref900bfee5, allocs900bfee5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CmdReserveSpaceForCommandsInfoNVX) PassValue() (C.VkCmdReserveSpaceForCommandsInfoNVX, *cgoAllocMap) {
	if x.ref900bfee5 != nil {
		return *x.ref900bfee5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CmdReserveSpaceForCommandsInfoNVX) Deref() {
	if x.ref900bfee5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref900bfee5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref900bfee5.pNext))
	x.ObjectTable = *(*ObjectTableNVX)(unsafe.Pointer(&x.ref900bfee5.objectTable))
	x.IndirectCommandsLayout = *(*IndirectCommandsLayoutNVX)(unsafe.Pointer(&x.ref900bfee5.indirectCommandsLayout))
	x.MaxSequencesCount = (uint32)(x.ref900bfee5.maxSequencesCount)
}

// allocObjectTableCreateInfoNVXMemory allocates memory for type C.VkObjectTableCreateInfoNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocObjectTableCreateInfoNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfObjectTableCreateInfoNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfObjectTableCreateInfoNVXValue = unsafe.Sizeof([1]C.VkObjectTableCreateInfoNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ObjectTableCreateInfoNVX) Ref() *C.VkObjectTableCreateInfoNVX {
	if x == nil {
		return nil
	}
	return x.refb4a6c9e1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ObjectTableCreateInfoNVX) Free() {
	if x != nil && x.allocsb4a6c9e1 != nil {
		x.allocsb4a6c9e1.(*cgoAllocMap).Free()
		x.refb4a6c9e1 = nil
	}
}

// NewObjectTableCreateInfoNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewObjectTableCreateInfoNVXRef(ref unsafe.Pointer) *ObjectTableCreateInfoNVX {
	if ref == nil {
		return nil
	}
	obj := new(ObjectTableCreateInfoNVX)
	obj.refb4a6c9e1 = (*C.VkObjectTableCreateInfoNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ObjectTableCreateInfoNVX) PassRef() (*C.VkObjectTableCreateInfoNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb4a6c9e1 != nil {
		return x.refb4a6c9e1, nil
	}
	memb4a6c9e1 := allocObjectTableCreateInfoNVXMemory(1)
	refb4a6c9e1 := (*C.VkObjectTableCreateInfoNVX)(memb4a6c9e1)
	allocsb4a6c9e1 := new(cgoAllocMap)
	allocsb4a6c9e1.Add(memb4a6c9e1)

	var csType_allocs *cgoAllocMap
	refb4a6c9e1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb4a6c9e1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cpNext_allocs)

	var cobjectCount_allocs *cgoAllocMap
	refb4a6c9e1.objectCount, cobjectCount_allocs = (C.uint32_t)(x.ObjectCount), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cobjectCount_allocs)

	var cpObjectEntryTypes_allocs *cgoAllocMap
	refb4a6c9e1.pObjectEntryTypes, cpObjectEntryTypes_allocs = (*C.VkObjectEntryTypeNVX)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PObjectEntryTypes)).Data)), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cpObjectEntryTypes_allocs)

	var cpObjectEntryCounts_allocs *cgoAllocMap
	refb4a6c9e1.pObjectEntryCounts, cpObjectEntryCounts_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PObjectEntryCounts)).Data)), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cpObjectEntryCounts_allocs)

	var cpObjectEntryUsageFlags_allocs *cgoAllocMap
	refb4a6c9e1.pObjectEntryUsageFlags, cpObjectEntryUsageFlags_allocs = (*C.VkObjectEntryUsageFlagsNVX)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PObjectEntryUsageFlags)).Data)), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cpObjectEntryUsageFlags_allocs)

	var cmaxUniformBuffersPerDescriptor_allocs *cgoAllocMap
	refb4a6c9e1.maxUniformBuffersPerDescriptor, cmaxUniformBuffersPerDescriptor_allocs = (C.uint32_t)(x.MaxUniformBuffersPerDescriptor), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cmaxUniformBuffersPerDescriptor_allocs)

	var cmaxStorageBuffersPerDescriptor_allocs *cgoAllocMap
	refb4a6c9e1.maxStorageBuffersPerDescriptor, cmaxStorageBuffersPerDescriptor_allocs = (C.uint32_t)(x.MaxStorageBuffersPerDescriptor), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cmaxStorageBuffersPerDescriptor_allocs)

	var cmaxStorageImagesPerDescriptor_allocs *cgoAllocMap
	refb4a6c9e1.maxStorageImagesPerDescriptor, cmaxStorageImagesPerDescriptor_allocs = (C.uint32_t)(x.MaxStorageImagesPerDescriptor), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cmaxStorageImagesPerDescriptor_allocs)

	var cmaxSampledImagesPerDescriptor_allocs *cgoAllocMap
	refb4a6c9e1.maxSampledImagesPerDescriptor, cmaxSampledImagesPerDescriptor_allocs = (C.uint32_t)(x.MaxSampledImagesPerDescriptor), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cmaxSampledImagesPerDescriptor_allocs)

	var cmaxPipelineLayouts_allocs *cgoAllocMap
	refb4a6c9e1.maxPipelineLayouts, cmaxPipelineLayouts_allocs = (C.uint32_t)(x.MaxPipelineLayouts), cgoAllocsUnknown
	allocsb4a6c9e1.Borrow(cmaxPipelineLayouts_allocs)

	x.refb4a6c9e1 = refb4a6c9e1
	x.allocsb4a6c9e1 = allocsb4a6c9e1
	return refb4a6c9e1, allocsb4a6c9e1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ObjectTableCreateInfoNVX) PassValue() (C.VkObjectTableCreateInfoNVX, *cgoAllocMap) {
	if x.refb4a6c9e1 != nil {
		return *x.refb4a6c9e1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ObjectTableCreateInfoNVX) Deref() {
	if x.refb4a6c9e1 == nil {
		return
	}
	x.SType = (StructureType)(x.refb4a6c9e1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb4a6c9e1.pNext))
	x.ObjectCount = (uint32)(x.refb4a6c9e1.objectCount)
	hxf5d30cf := (*sliceHeader)(unsafe.Pointer(&x.PObjectEntryTypes))
	hxf5d30cf.Data = unsafe.Pointer(x.refb4a6c9e1.pObjectEntryTypes)
	hxf5d30cf.Cap = 0x7fffffff
	// hxf5d30cf.Len = ?

	hxf882e98 := (*sliceHeader)(unsafe.Pointer(&x.PObjectEntryCounts))
	hxf882e98.Data = unsafe.Pointer(x.refb4a6c9e1.pObjectEntryCounts)
	hxf882e98.Cap = 0x7fffffff
	// hxf882e98.Len = ?

	hxf992404 := (*sliceHeader)(unsafe.Pointer(&x.PObjectEntryUsageFlags))
	hxf992404.Data = unsafe.Pointer(x.refb4a6c9e1.pObjectEntryUsageFlags)
	hxf992404.Cap = 0x7fffffff
	// hxf992404.Len = ?

	x.MaxUniformBuffersPerDescriptor = (uint32)(x.refb4a6c9e1.maxUniformBuffersPerDescriptor)
	x.MaxStorageBuffersPerDescriptor = (uint32)(x.refb4a6c9e1.maxStorageBuffersPerDescriptor)
	x.MaxStorageImagesPerDescriptor = (uint32)(x.refb4a6c9e1.maxStorageImagesPerDescriptor)
	x.MaxSampledImagesPerDescriptor = (uint32)(x.refb4a6c9e1.maxSampledImagesPerDescriptor)
	x.MaxPipelineLayouts = (uint32)(x.refb4a6c9e1.maxPipelineLayouts)
}

// allocObjectTableEntryNVXMemory allocates memory for type C.VkObjectTableEntryNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocObjectTableEntryNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfObjectTableEntryNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfObjectTableEntryNVXValue = unsafe.Sizeof([1]C.VkObjectTableEntryNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ObjectTableEntryNVX) Ref() *C.VkObjectTableEntryNVX {
	if x == nil {
		return nil
	}
	return x.refb8f7ffef
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ObjectTableEntryNVX) Free() {
	if x != nil && x.allocsb8f7ffef != nil {
		x.allocsb8f7ffef.(*cgoAllocMap).Free()
		x.refb8f7ffef = nil
	}
}

// NewObjectTableEntryNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewObjectTableEntryNVXRef(ref unsafe.Pointer) *ObjectTableEntryNVX {
	if ref == nil {
		return nil
	}
	obj := new(ObjectTableEntryNVX)
	obj.refb8f7ffef = (*C.VkObjectTableEntryNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ObjectTableEntryNVX) PassRef() (*C.VkObjectTableEntryNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8f7ffef != nil {
		return x.refb8f7ffef, nil
	}
	memb8f7ffef := allocObjectTableEntryNVXMemory(1)
	refb8f7ffef := (*C.VkObjectTableEntryNVX)(memb8f7ffef)
	allocsb8f7ffef := new(cgoAllocMap)
	allocsb8f7ffef.Add(memb8f7ffef)

	var c_type_allocs *cgoAllocMap
	refb8f7ffef._type, c_type_allocs = (C.VkObjectEntryTypeNVX)(x.Type), cgoAllocsUnknown
	allocsb8f7ffef.Borrow(c_type_allocs)

	var cflags_allocs *cgoAllocMap
	refb8f7ffef.flags, cflags_allocs = (C.VkObjectEntryUsageFlagsNVX)(x.Flags), cgoAllocsUnknown
	allocsb8f7ffef.Borrow(cflags_allocs)

	x.refb8f7ffef = refb8f7ffef
	x.allocsb8f7ffef = allocsb8f7ffef
	return refb8f7ffef, allocsb8f7ffef

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ObjectTableEntryNVX) PassValue() (C.VkObjectTableEntryNVX, *cgoAllocMap) {
	if x.refb8f7ffef != nil {
		return *x.refb8f7ffef, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ObjectTableEntryNVX) Deref() {
	if x.refb8f7ffef == nil {
		return
	}
	x.Type = (ObjectEntryTypeNVX)(x.refb8f7ffef._type)
	x.Flags = (ObjectEntryUsageFlagsNVX)(x.refb8f7ffef.flags)
}

// allocObjectTablePipelineEntryNVXMemory allocates memory for type C.VkObjectTablePipelineEntryNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocObjectTablePipelineEntryNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfObjectTablePipelineEntryNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfObjectTablePipelineEntryNVXValue = unsafe.Sizeof([1]C.VkObjectTablePipelineEntryNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ObjectTablePipelineEntryNVX) Ref() *C.VkObjectTablePipelineEntryNVX {
	if x == nil {
		return nil
	}
	return x.ref8112859b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ObjectTablePipelineEntryNVX) Free() {
	if x != nil && x.allocs8112859b != nil {
		x.allocs8112859b.(*cgoAllocMap).Free()
		x.ref8112859b = nil
	}
}

// NewObjectTablePipelineEntryNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewObjectTablePipelineEntryNVXRef(ref unsafe.Pointer) *ObjectTablePipelineEntryNVX {
	if ref == nil {
		return nil
	}
	obj := new(ObjectTablePipelineEntryNVX)
	obj.ref8112859b = (*C.VkObjectTablePipelineEntryNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ObjectTablePipelineEntryNVX) PassRef() (*C.VkObjectTablePipelineEntryNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8112859b != nil {
		return x.ref8112859b, nil
	}
	mem8112859b := allocObjectTablePipelineEntryNVXMemory(1)
	ref8112859b := (*C.VkObjectTablePipelineEntryNVX)(mem8112859b)
	allocs8112859b := new(cgoAllocMap)
	allocs8112859b.Add(mem8112859b)

	var c_type_allocs *cgoAllocMap
	ref8112859b._type, c_type_allocs = (C.VkObjectEntryTypeNVX)(x.Type), cgoAllocsUnknown
	allocs8112859b.Borrow(c_type_allocs)

	var cflags_allocs *cgoAllocMap
	ref8112859b.flags, cflags_allocs = (C.VkObjectEntryUsageFlagsNVX)(x.Flags), cgoAllocsUnknown
	allocs8112859b.Borrow(cflags_allocs)

	var cpipeline_allocs *cgoAllocMap
	ref8112859b.pipeline, cpipeline_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.Pipeline)), cgoAllocsUnknown
	allocs8112859b.Borrow(cpipeline_allocs)

	x.ref8112859b = ref8112859b
	x.allocs8112859b = allocs8112859b
	return ref8112859b, allocs8112859b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ObjectTablePipelineEntryNVX) PassValue() (C.VkObjectTablePipelineEntryNVX, *cgoAllocMap) {
	if x.ref8112859b != nil {
		return *x.ref8112859b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ObjectTablePipelineEntryNVX) Deref() {
	if x.ref8112859b == nil {
		return
	}
	x.Type = (ObjectEntryTypeNVX)(x.ref8112859b._type)
	x.Flags = (ObjectEntryUsageFlagsNVX)(x.ref8112859b.flags)
	x.Pipeline = *(*Pipeline)(unsafe.Pointer(&x.ref8112859b.pipeline))
}

// allocObjectTableDescriptorSetEntryNVXMemory allocates memory for type C.VkObjectTableDescriptorSetEntryNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocObjectTableDescriptorSetEntryNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfObjectTableDescriptorSetEntryNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfObjectTableDescriptorSetEntryNVXValue = unsafe.Sizeof([1]C.VkObjectTableDescriptorSetEntryNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ObjectTableDescriptorSetEntryNVX) Ref() *C.VkObjectTableDescriptorSetEntryNVX {
	if x == nil {
		return nil
	}
	return x.ref6fc0d42f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ObjectTableDescriptorSetEntryNVX) Free() {
	if x != nil && x.allocs6fc0d42f != nil {
		x.allocs6fc0d42f.(*cgoAllocMap).Free()
		x.ref6fc0d42f = nil
	}
}

// NewObjectTableDescriptorSetEntryNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewObjectTableDescriptorSetEntryNVXRef(ref unsafe.Pointer) *ObjectTableDescriptorSetEntryNVX {
	if ref == nil {
		return nil
	}
	obj := new(ObjectTableDescriptorSetEntryNVX)
	obj.ref6fc0d42f = (*C.VkObjectTableDescriptorSetEntryNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ObjectTableDescriptorSetEntryNVX) PassRef() (*C.VkObjectTableDescriptorSetEntryNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6fc0d42f != nil {
		return x.ref6fc0d42f, nil
	}
	mem6fc0d42f := allocObjectTableDescriptorSetEntryNVXMemory(1)
	ref6fc0d42f := (*C.VkObjectTableDescriptorSetEntryNVX)(mem6fc0d42f)
	allocs6fc0d42f := new(cgoAllocMap)
	allocs6fc0d42f.Add(mem6fc0d42f)

	var c_type_allocs *cgoAllocMap
	ref6fc0d42f._type, c_type_allocs = (C.VkObjectEntryTypeNVX)(x.Type), cgoAllocsUnknown
	allocs6fc0d42f.Borrow(c_type_allocs)

	var cflags_allocs *cgoAllocMap
	ref6fc0d42f.flags, cflags_allocs = (C.VkObjectEntryUsageFlagsNVX)(x.Flags), cgoAllocsUnknown
	allocs6fc0d42f.Borrow(cflags_allocs)

	var cpipelineLayout_allocs *cgoAllocMap
	ref6fc0d42f.pipelineLayout, cpipelineLayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.PipelineLayout)), cgoAllocsUnknown
	allocs6fc0d42f.Borrow(cpipelineLayout_allocs)

	var cdescriptorSet_allocs *cgoAllocMap
	ref6fc0d42f.descriptorSet, cdescriptorSet_allocs = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.DescriptorSet)), cgoAllocsUnknown
	allocs6fc0d42f.Borrow(cdescriptorSet_allocs)

	x.ref6fc0d42f = ref6fc0d42f
	x.allocs6fc0d42f = allocs6fc0d42f
	return ref6fc0d42f, allocs6fc0d42f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ObjectTableDescriptorSetEntryNVX) PassValue() (C.VkObjectTableDescriptorSetEntryNVX, *cgoAllocMap) {
	if x.ref6fc0d42f != nil {
		return *x.ref6fc0d42f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ObjectTableDescriptorSetEntryNVX) Deref() {
	if x.ref6fc0d42f == nil {
		return
	}
	x.Type = (ObjectEntryTypeNVX)(x.ref6fc0d42f._type)
	x.Flags = (ObjectEntryUsageFlagsNVX)(x.ref6fc0d42f.flags)
	x.PipelineLayout = *(*PipelineLayout)(unsafe.Pointer(&x.ref6fc0d42f.pipelineLayout))
	x.DescriptorSet = *(*DescriptorSet)(unsafe.Pointer(&x.ref6fc0d42f.descriptorSet))
}

// allocObjectTableVertexBufferEntryNVXMemory allocates memory for type C.VkObjectTableVertexBufferEntryNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocObjectTableVertexBufferEntryNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfObjectTableVertexBufferEntryNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfObjectTableVertexBufferEntryNVXValue = unsafe.Sizeof([1]C.VkObjectTableVertexBufferEntryNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ObjectTableVertexBufferEntryNVX) Ref() *C.VkObjectTableVertexBufferEntryNVX {
	if x == nil {
		return nil
	}
	return x.refe8a5908b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ObjectTableVertexBufferEntryNVX) Free() {
	if x != nil && x.allocse8a5908b != nil {
		x.allocse8a5908b.(*cgoAllocMap).Free()
		x.refe8a5908b = nil
	}
}

// NewObjectTableVertexBufferEntryNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewObjectTableVertexBufferEntryNVXRef(ref unsafe.Pointer) *ObjectTableVertexBufferEntryNVX {
	if ref == nil {
		return nil
	}
	obj := new(ObjectTableVertexBufferEntryNVX)
	obj.refe8a5908b = (*C.VkObjectTableVertexBufferEntryNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ObjectTableVertexBufferEntryNVX) PassRef() (*C.VkObjectTableVertexBufferEntryNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe8a5908b != nil {
		return x.refe8a5908b, nil
	}
	meme8a5908b := allocObjectTableVertexBufferEntryNVXMemory(1)
	refe8a5908b := (*C.VkObjectTableVertexBufferEntryNVX)(meme8a5908b)
	allocse8a5908b := new(cgoAllocMap)
	allocse8a5908b.Add(meme8a5908b)

	var c_type_allocs *cgoAllocMap
	refe8a5908b._type, c_type_allocs = (C.VkObjectEntryTypeNVX)(x.Type), cgoAllocsUnknown
	allocse8a5908b.Borrow(c_type_allocs)

	var cflags_allocs *cgoAllocMap
	refe8a5908b.flags, cflags_allocs = (C.VkObjectEntryUsageFlagsNVX)(x.Flags), cgoAllocsUnknown
	allocse8a5908b.Borrow(cflags_allocs)

	var cbuffer_allocs *cgoAllocMap
	refe8a5908b.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocse8a5908b.Borrow(cbuffer_allocs)

	x.refe8a5908b = refe8a5908b
	x.allocse8a5908b = allocse8a5908b
	return refe8a5908b, allocse8a5908b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ObjectTableVertexBufferEntryNVX) PassValue() (C.VkObjectTableVertexBufferEntryNVX, *cgoAllocMap) {
	if x.refe8a5908b != nil {
		return *x.refe8a5908b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ObjectTableVertexBufferEntryNVX) Deref() {
	if x.refe8a5908b == nil {
		return
	}
	x.Type = (ObjectEntryTypeNVX)(x.refe8a5908b._type)
	x.Flags = (ObjectEntryUsageFlagsNVX)(x.refe8a5908b.flags)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refe8a5908b.buffer))
}

// allocObjectTableIndexBufferEntryNVXMemory allocates memory for type C.VkObjectTableIndexBufferEntryNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocObjectTableIndexBufferEntryNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfObjectTableIndexBufferEntryNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfObjectTableIndexBufferEntryNVXValue = unsafe.Sizeof([1]C.VkObjectTableIndexBufferEntryNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ObjectTableIndexBufferEntryNVX) Ref() *C.VkObjectTableIndexBufferEntryNVX {
	if x == nil {
		return nil
	}
	return x.ref58a08650
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ObjectTableIndexBufferEntryNVX) Free() {
	if x != nil && x.allocs58a08650 != nil {
		x.allocs58a08650.(*cgoAllocMap).Free()
		x.ref58a08650 = nil
	}
}

// NewObjectTableIndexBufferEntryNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewObjectTableIndexBufferEntryNVXRef(ref unsafe.Pointer) *ObjectTableIndexBufferEntryNVX {
	if ref == nil {
		return nil
	}
	obj := new(ObjectTableIndexBufferEntryNVX)
	obj.ref58a08650 = (*C.VkObjectTableIndexBufferEntryNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ObjectTableIndexBufferEntryNVX) PassRef() (*C.VkObjectTableIndexBufferEntryNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref58a08650 != nil {
		return x.ref58a08650, nil
	}
	mem58a08650 := allocObjectTableIndexBufferEntryNVXMemory(1)
	ref58a08650 := (*C.VkObjectTableIndexBufferEntryNVX)(mem58a08650)
	allocs58a08650 := new(cgoAllocMap)
	allocs58a08650.Add(mem58a08650)

	var c_type_allocs *cgoAllocMap
	ref58a08650._type, c_type_allocs = (C.VkObjectEntryTypeNVX)(x.Type), cgoAllocsUnknown
	allocs58a08650.Borrow(c_type_allocs)

	var cflags_allocs *cgoAllocMap
	ref58a08650.flags, cflags_allocs = (C.VkObjectEntryUsageFlagsNVX)(x.Flags), cgoAllocsUnknown
	allocs58a08650.Borrow(cflags_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref58a08650.buffer, cbuffer_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs58a08650.Borrow(cbuffer_allocs)

	var cindexType_allocs *cgoAllocMap
	ref58a08650.indexType, cindexType_allocs = (C.VkIndexType)(x.IndexType), cgoAllocsUnknown
	allocs58a08650.Borrow(cindexType_allocs)

	x.ref58a08650 = ref58a08650
	x.allocs58a08650 = allocs58a08650
	return ref58a08650, allocs58a08650

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ObjectTableIndexBufferEntryNVX) PassValue() (C.VkObjectTableIndexBufferEntryNVX, *cgoAllocMap) {
	if x.ref58a08650 != nil {
		return *x.ref58a08650, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ObjectTableIndexBufferEntryNVX) Deref() {
	if x.ref58a08650 == nil {
		return
	}
	x.Type = (ObjectEntryTypeNVX)(x.ref58a08650._type)
	x.Flags = (ObjectEntryUsageFlagsNVX)(x.ref58a08650.flags)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref58a08650.buffer))
	x.IndexType = (IndexType)(x.ref58a08650.indexType)
}

// allocObjectTablePushConstantEntryNVXMemory allocates memory for type C.VkObjectTablePushConstantEntryNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocObjectTablePushConstantEntryNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfObjectTablePushConstantEntryNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfObjectTablePushConstantEntryNVXValue = unsafe.Sizeof([1]C.VkObjectTablePushConstantEntryNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ObjectTablePushConstantEntryNVX) Ref() *C.VkObjectTablePushConstantEntryNVX {
	if x == nil {
		return nil
	}
	return x.ref8c8421e0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ObjectTablePushConstantEntryNVX) Free() {
	if x != nil && x.allocs8c8421e0 != nil {
		x.allocs8c8421e0.(*cgoAllocMap).Free()
		x.ref8c8421e0 = nil
	}
}

// NewObjectTablePushConstantEntryNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewObjectTablePushConstantEntryNVXRef(ref unsafe.Pointer) *ObjectTablePushConstantEntryNVX {
	if ref == nil {
		return nil
	}
	obj := new(ObjectTablePushConstantEntryNVX)
	obj.ref8c8421e0 = (*C.VkObjectTablePushConstantEntryNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ObjectTablePushConstantEntryNVX) PassRef() (*C.VkObjectTablePushConstantEntryNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8c8421e0 != nil {
		return x.ref8c8421e0, nil
	}
	mem8c8421e0 := allocObjectTablePushConstantEntryNVXMemory(1)
	ref8c8421e0 := (*C.VkObjectTablePushConstantEntryNVX)(mem8c8421e0)
	allocs8c8421e0 := new(cgoAllocMap)
	allocs8c8421e0.Add(mem8c8421e0)

	var c_type_allocs *cgoAllocMap
	ref8c8421e0._type, c_type_allocs = (C.VkObjectEntryTypeNVX)(x.Type), cgoAllocsUnknown
	allocs8c8421e0.Borrow(c_type_allocs)

	var cflags_allocs *cgoAllocMap
	ref8c8421e0.flags, cflags_allocs = (C.VkObjectEntryUsageFlagsNVX)(x.Flags), cgoAllocsUnknown
	allocs8c8421e0.Borrow(cflags_allocs)

	var cpipelineLayout_allocs *cgoAllocMap
	ref8c8421e0.pipelineLayout, cpipelineLayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.PipelineLayout)), cgoAllocsUnknown
	allocs8c8421e0.Borrow(cpipelineLayout_allocs)

	var cstageFlags_allocs *cgoAllocMap
	ref8c8421e0.stageFlags, cstageFlags_allocs = (C.VkShaderStageFlags)(x.StageFlags), cgoAllocsUnknown
	allocs8c8421e0.Borrow(cstageFlags_allocs)

	x.ref8c8421e0 = ref8c8421e0
	x.allocs8c8421e0 = allocs8c8421e0
	return ref8c8421e0, allocs8c8421e0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ObjectTablePushConstantEntryNVX) PassValue() (C.VkObjectTablePushConstantEntryNVX, *cgoAllocMap) {
	if x.ref8c8421e0 != nil {
		return *x.ref8c8421e0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ObjectTablePushConstantEntryNVX) Deref() {
	if x.ref8c8421e0 == nil {
		return
	}
	x.Type = (ObjectEntryTypeNVX)(x.ref8c8421e0._type)
	x.Flags = (ObjectEntryUsageFlagsNVX)(x.ref8c8421e0.flags)
	x.PipelineLayout = *(*PipelineLayout)(unsafe.Pointer(&x.ref8c8421e0.pipelineLayout))
	x.StageFlags = (ShaderStageFlags)(x.ref8c8421e0.stageFlags)
}

// allocViewportWScalingNVMemory allocates memory for type C.VkViewportWScalingNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocViewportWScalingNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfViewportWScalingNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfViewportWScalingNVValue = unsafe.Sizeof([1]C.VkViewportWScalingNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ViewportWScalingNV) Ref() *C.VkViewportWScalingNV {
	if x == nil {
		return nil
	}
	return x.ref7ea4590f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ViewportWScalingNV) Free() {
	if x != nil && x.allocs7ea4590f != nil {
		x.allocs7ea4590f.(*cgoAllocMap).Free()
		x.ref7ea4590f = nil
	}
}

// NewViewportWScalingNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewViewportWScalingNVRef(ref unsafe.Pointer) *ViewportWScalingNV {
	if ref == nil {
		return nil
	}
	obj := new(ViewportWScalingNV)
	obj.ref7ea4590f = (*C.VkViewportWScalingNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ViewportWScalingNV) PassRef() (*C.VkViewportWScalingNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7ea4590f != nil {
		return x.ref7ea4590f, nil
	}
	mem7ea4590f := allocViewportWScalingNVMemory(1)
	ref7ea4590f := (*C.VkViewportWScalingNV)(mem7ea4590f)
	allocs7ea4590f := new(cgoAllocMap)
	allocs7ea4590f.Add(mem7ea4590f)

	var cxcoeff_allocs *cgoAllocMap
	ref7ea4590f.xcoeff, cxcoeff_allocs = (C.float)(x.Xcoeff), cgoAllocsUnknown
	allocs7ea4590f.Borrow(cxcoeff_allocs)

	var cycoeff_allocs *cgoAllocMap
	ref7ea4590f.ycoeff, cycoeff_allocs = (C.float)(x.Ycoeff), cgoAllocsUnknown
	allocs7ea4590f.Borrow(cycoeff_allocs)

	x.ref7ea4590f = ref7ea4590f
	x.allocs7ea4590f = allocs7ea4590f
	return ref7ea4590f, allocs7ea4590f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ViewportWScalingNV) PassValue() (C.VkViewportWScalingNV, *cgoAllocMap) {
	if x.ref7ea4590f != nil {
		return *x.ref7ea4590f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ViewportWScalingNV) Deref() {
	if x.ref7ea4590f == nil {
		return
	}
	x.Xcoeff = (float32)(x.ref7ea4590f.xcoeff)
	x.Ycoeff = (float32)(x.ref7ea4590f.ycoeff)
}

// allocPipelineViewportWScalingStateCreateInfoNVMemory allocates memory for type C.VkPipelineViewportWScalingStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportWScalingStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportWScalingStateCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineViewportWScalingStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineViewportWScalingStateCreateInfoNV{})

// unpackSViewportWScalingNV transforms a sliced Go data structure into plain C format.
func unpackSViewportWScalingNV(x []ViewportWScalingNV) (unpacked *C.VkViewportWScalingNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkViewportWScalingNV) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocViewportWScalingNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkViewportWScalingNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkViewportWScalingNV)(h.Data)
	return
}

// packSViewportWScalingNV reads sliced Go data structure out from plain C format.
func packSViewportWScalingNV(v []ViewportWScalingNV, ptr0 *C.VkViewportWScalingNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfViewportWScalingNVValue]C.VkViewportWScalingNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewViewportWScalingNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportWScalingStateCreateInfoNV) Ref() *C.VkPipelineViewportWScalingStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref3e532c0b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportWScalingStateCreateInfoNV) Free() {
	if x != nil && x.allocs3e532c0b != nil {
		x.allocs3e532c0b.(*cgoAllocMap).Free()
		x.ref3e532c0b = nil
	}
}

// NewPipelineViewportWScalingStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportWScalingStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineViewportWScalingStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportWScalingStateCreateInfoNV)
	obj.ref3e532c0b = (*C.VkPipelineViewportWScalingStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportWScalingStateCreateInfoNV) PassRef() (*C.VkPipelineViewportWScalingStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3e532c0b != nil {
		return x.ref3e532c0b, nil
	}
	mem3e532c0b := allocPipelineViewportWScalingStateCreateInfoNVMemory(1)
	ref3e532c0b := (*C.VkPipelineViewportWScalingStateCreateInfoNV)(mem3e532c0b)
	allocs3e532c0b := new(cgoAllocMap)
	allocs3e532c0b.Add(mem3e532c0b)

	var csType_allocs *cgoAllocMap
	ref3e532c0b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3e532c0b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3e532c0b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3e532c0b.Borrow(cpNext_allocs)

	var cviewportWScalingEnable_allocs *cgoAllocMap
	ref3e532c0b.viewportWScalingEnable, cviewportWScalingEnable_allocs = (C.VkBool32)(x.ViewportWScalingEnable), cgoAllocsUnknown
	allocs3e532c0b.Borrow(cviewportWScalingEnable_allocs)

	var cviewportCount_allocs *cgoAllocMap
	ref3e532c0b.viewportCount, cviewportCount_allocs = (C.uint32_t)(x.ViewportCount), cgoAllocsUnknown
	allocs3e532c0b.Borrow(cviewportCount_allocs)

	var cpViewportWScalings_allocs *cgoAllocMap
	ref3e532c0b.pViewportWScalings, cpViewportWScalings_allocs = unpackSViewportWScalingNV(x.PViewportWScalings)
	allocs3e532c0b.Borrow(cpViewportWScalings_allocs)

	x.ref3e532c0b = ref3e532c0b
	x.allocs3e532c0b = allocs3e532c0b
	return ref3e532c0b, allocs3e532c0b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportWScalingStateCreateInfoNV) PassValue() (C.VkPipelineViewportWScalingStateCreateInfoNV, *cgoAllocMap) {
	if x.ref3e532c0b != nil {
		return *x.ref3e532c0b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportWScalingStateCreateInfoNV) Deref() {
	if x.ref3e532c0b == nil {
		return
	}
	x.SType = (StructureType)(x.ref3e532c0b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3e532c0b.pNext))
	x.ViewportWScalingEnable = (Bool32)(x.ref3e532c0b.viewportWScalingEnable)
	x.ViewportCount = (uint32)(x.ref3e532c0b.viewportCount)
	packSViewportWScalingNV(x.PViewportWScalings, x.ref3e532c0b.pViewportWScalings)
}

// allocDisplayPowerInfoMemory allocates memory for type C.VkDisplayPowerInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPowerInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPowerInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayPowerInfoValue = unsafe.Sizeof([1]C.VkDisplayPowerInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPowerInfo) Ref() *C.VkDisplayPowerInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref80fed52f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPowerInfo) Free() {
	if x != nil && x.allocs80fed52f != nil {
		x.allocs80fed52f.(*cgoAllocMap).Free()
		x.ref80fed52f = nil
	}
}

// NewDisplayPowerInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPowerInfoRef(ref unsafe.Pointer) *DisplayPowerInfo {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPowerInfo)
	obj.ref80fed52f = (*C.VkDisplayPowerInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPowerInfo) PassRef() (*C.VkDisplayPowerInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref80fed52f != nil {
		return x.ref80fed52f, nil
	}
	mem80fed52f := allocDisplayPowerInfoMemory(1)
	ref80fed52f := (*C.VkDisplayPowerInfoEXT)(mem80fed52f)
	allocs80fed52f := new(cgoAllocMap)
	allocs80fed52f.Add(mem80fed52f)

	var csType_allocs *cgoAllocMap
	ref80fed52f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs80fed52f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref80fed52f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs80fed52f.Borrow(cpNext_allocs)

	var cpowerState_allocs *cgoAllocMap
	ref80fed52f.powerState, cpowerState_allocs = (C.VkDisplayPowerStateEXT)(x.PowerState), cgoAllocsUnknown
	allocs80fed52f.Borrow(cpowerState_allocs)

	x.ref80fed52f = ref80fed52f
	x.allocs80fed52f = allocs80fed52f
	return ref80fed52f, allocs80fed52f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPowerInfo) PassValue() (C.VkDisplayPowerInfoEXT, *cgoAllocMap) {
	if x.ref80fed52f != nil {
		return *x.ref80fed52f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPowerInfo) Deref() {
	if x.ref80fed52f == nil {
		return
	}
	x.SType = (StructureType)(x.ref80fed52f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref80fed52f.pNext))
	x.PowerState = (DisplayPowerState)(x.ref80fed52f.powerState)
}

// allocDeviceEventInfoMemory allocates memory for type C.VkDeviceEventInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceEventInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceEventInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceEventInfoValue = unsafe.Sizeof([1]C.VkDeviceEventInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceEventInfo) Ref() *C.VkDeviceEventInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref394b3fcb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceEventInfo) Free() {
	if x != nil && x.allocs394b3fcb != nil {
		x.allocs394b3fcb.(*cgoAllocMap).Free()
		x.ref394b3fcb = nil
	}
}

// NewDeviceEventInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceEventInfoRef(ref unsafe.Pointer) *DeviceEventInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceEventInfo)
	obj.ref394b3fcb = (*C.VkDeviceEventInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceEventInfo) PassRef() (*C.VkDeviceEventInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref394b3fcb != nil {
		return x.ref394b3fcb, nil
	}
	mem394b3fcb := allocDeviceEventInfoMemory(1)
	ref394b3fcb := (*C.VkDeviceEventInfoEXT)(mem394b3fcb)
	allocs394b3fcb := new(cgoAllocMap)
	allocs394b3fcb.Add(mem394b3fcb)

	var csType_allocs *cgoAllocMap
	ref394b3fcb.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs394b3fcb.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref394b3fcb.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs394b3fcb.Borrow(cpNext_allocs)

	var cdeviceEvent_allocs *cgoAllocMap
	ref394b3fcb.deviceEvent, cdeviceEvent_allocs = (C.VkDeviceEventTypeEXT)(x.DeviceEvent), cgoAllocsUnknown
	allocs394b3fcb.Borrow(cdeviceEvent_allocs)

	x.ref394b3fcb = ref394b3fcb
	x.allocs394b3fcb = allocs394b3fcb
	return ref394b3fcb, allocs394b3fcb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceEventInfo) PassValue() (C.VkDeviceEventInfoEXT, *cgoAllocMap) {
	if x.ref394b3fcb != nil {
		return *x.ref394b3fcb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceEventInfo) Deref() {
	if x.ref394b3fcb == nil {
		return
	}
	x.SType = (StructureType)(x.ref394b3fcb.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref394b3fcb.pNext))
	x.DeviceEvent = (DeviceEventType)(x.ref394b3fcb.deviceEvent)
}

// allocDisplayEventInfoMemory allocates memory for type C.VkDisplayEventInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayEventInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayEventInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayEventInfoValue = unsafe.Sizeof([1]C.VkDisplayEventInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayEventInfo) Ref() *C.VkDisplayEventInfoEXT {
	if x == nil {
		return nil
	}
	return x.refa69f7302
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayEventInfo) Free() {
	if x != nil && x.allocsa69f7302 != nil {
		x.allocsa69f7302.(*cgoAllocMap).Free()
		x.refa69f7302 = nil
	}
}

// NewDisplayEventInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayEventInfoRef(ref unsafe.Pointer) *DisplayEventInfo {
	if ref == nil {
		return nil
	}
	obj := new(DisplayEventInfo)
	obj.refa69f7302 = (*C.VkDisplayEventInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayEventInfo) PassRef() (*C.VkDisplayEventInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa69f7302 != nil {
		return x.refa69f7302, nil
	}
	mema69f7302 := allocDisplayEventInfoMemory(1)
	refa69f7302 := (*C.VkDisplayEventInfoEXT)(mema69f7302)
	allocsa69f7302 := new(cgoAllocMap)
	allocsa69f7302.Add(mema69f7302)

	var csType_allocs *cgoAllocMap
	refa69f7302.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa69f7302.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa69f7302.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa69f7302.Borrow(cpNext_allocs)

	var cdisplayEvent_allocs *cgoAllocMap
	refa69f7302.displayEvent, cdisplayEvent_allocs = (C.VkDisplayEventTypeEXT)(x.DisplayEvent), cgoAllocsUnknown
	allocsa69f7302.Borrow(cdisplayEvent_allocs)

	x.refa69f7302 = refa69f7302
	x.allocsa69f7302 = allocsa69f7302
	return refa69f7302, allocsa69f7302

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayEventInfo) PassValue() (C.VkDisplayEventInfoEXT, *cgoAllocMap) {
	if x.refa69f7302 != nil {
		return *x.refa69f7302, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayEventInfo) Deref() {
	if x.refa69f7302 == nil {
		return
	}
	x.SType = (StructureType)(x.refa69f7302.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa69f7302.pNext))
	x.DisplayEvent = (DisplayEventType)(x.refa69f7302.displayEvent)
}

// allocSwapchainCounterCreateInfoMemory allocates memory for type C.VkSwapchainCounterCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSwapchainCounterCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSwapchainCounterCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSwapchainCounterCreateInfoValue = unsafe.Sizeof([1]C.VkSwapchainCounterCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SwapchainCounterCreateInfo) Ref() *C.VkSwapchainCounterCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref9f21eca6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SwapchainCounterCreateInfo) Free() {
	if x != nil && x.allocs9f21eca6 != nil {
		x.allocs9f21eca6.(*cgoAllocMap).Free()
		x.ref9f21eca6 = nil
	}
}

// NewSwapchainCounterCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSwapchainCounterCreateInfoRef(ref unsafe.Pointer) *SwapchainCounterCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SwapchainCounterCreateInfo)
	obj.ref9f21eca6 = (*C.VkSwapchainCounterCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SwapchainCounterCreateInfo) PassRef() (*C.VkSwapchainCounterCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9f21eca6 != nil {
		return x.ref9f21eca6, nil
	}
	mem9f21eca6 := allocSwapchainCounterCreateInfoMemory(1)
	ref9f21eca6 := (*C.VkSwapchainCounterCreateInfoEXT)(mem9f21eca6)
	allocs9f21eca6 := new(cgoAllocMap)
	allocs9f21eca6.Add(mem9f21eca6)

	var csType_allocs *cgoAllocMap
	ref9f21eca6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9f21eca6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9f21eca6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9f21eca6.Borrow(cpNext_allocs)

	var csurfaceCounters_allocs *cgoAllocMap
	ref9f21eca6.surfaceCounters, csurfaceCounters_allocs = (C.VkSurfaceCounterFlagsEXT)(x.SurfaceCounters), cgoAllocsUnknown
	allocs9f21eca6.Borrow(csurfaceCounters_allocs)

	x.ref9f21eca6 = ref9f21eca6
	x.allocs9f21eca6 = allocs9f21eca6
	return ref9f21eca6, allocs9f21eca6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SwapchainCounterCreateInfo) PassValue() (C.VkSwapchainCounterCreateInfoEXT, *cgoAllocMap) {
	if x.ref9f21eca6 != nil {
		return *x.ref9f21eca6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SwapchainCounterCreateInfo) Deref() {
	if x.ref9f21eca6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9f21eca6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9f21eca6.pNext))
	x.SurfaceCounters = (SurfaceCounterFlags)(x.ref9f21eca6.surfaceCounters)
}

// allocRefreshCycleDurationGOOGLEMemory allocates memory for type C.VkRefreshCycleDurationGOOGLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRefreshCycleDurationGOOGLEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRefreshCycleDurationGOOGLEValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRefreshCycleDurationGOOGLEValue = unsafe.Sizeof([1]C.VkRefreshCycleDurationGOOGLE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RefreshCycleDurationGOOGLE) Ref() *C.VkRefreshCycleDurationGOOGLE {
	if x == nil {
		return nil
	}
	return x.ref969cb55b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RefreshCycleDurationGOOGLE) Free() {
	if x != nil && x.allocs969cb55b != nil {
		x.allocs969cb55b.(*cgoAllocMap).Free()
		x.ref969cb55b = nil
	}
}

// NewRefreshCycleDurationGOOGLERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRefreshCycleDurationGOOGLERef(ref unsafe.Pointer) *RefreshCycleDurationGOOGLE {
	if ref == nil {
		return nil
	}
	obj := new(RefreshCycleDurationGOOGLE)
	obj.ref969cb55b = (*C.VkRefreshCycleDurationGOOGLE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RefreshCycleDurationGOOGLE) PassRef() (*C.VkRefreshCycleDurationGOOGLE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref969cb55b != nil {
		return x.ref969cb55b, nil
	}
	mem969cb55b := allocRefreshCycleDurationGOOGLEMemory(1)
	ref969cb55b := (*C.VkRefreshCycleDurationGOOGLE)(mem969cb55b)
	allocs969cb55b := new(cgoAllocMap)
	allocs969cb55b.Add(mem969cb55b)

	var crefreshDuration_allocs *cgoAllocMap
	ref969cb55b.refreshDuration, crefreshDuration_allocs = (C.uint64_t)(x.RefreshDuration), cgoAllocsUnknown
	allocs969cb55b.Borrow(crefreshDuration_allocs)

	x.ref969cb55b = ref969cb55b
	x.allocs969cb55b = allocs969cb55b
	return ref969cb55b, allocs969cb55b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RefreshCycleDurationGOOGLE) PassValue() (C.VkRefreshCycleDurationGOOGLE, *cgoAllocMap) {
	if x.ref969cb55b != nil {
		return *x.ref969cb55b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RefreshCycleDurationGOOGLE) Deref() {
	if x.ref969cb55b == nil {
		return
	}
	x.RefreshDuration = (uint64)(x.ref969cb55b.refreshDuration)
}

// allocPastPresentationTimingGOOGLEMemory allocates memory for type C.VkPastPresentationTimingGOOGLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPastPresentationTimingGOOGLEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPastPresentationTimingGOOGLEValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPastPresentationTimingGOOGLEValue = unsafe.Sizeof([1]C.VkPastPresentationTimingGOOGLE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PastPresentationTimingGOOGLE) Ref() *C.VkPastPresentationTimingGOOGLE {
	if x == nil {
		return nil
	}
	return x.refac8cf1d8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PastPresentationTimingGOOGLE) Free() {
	if x != nil && x.allocsac8cf1d8 != nil {
		x.allocsac8cf1d8.(*cgoAllocMap).Free()
		x.refac8cf1d8 = nil
	}
}

// NewPastPresentationTimingGOOGLERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPastPresentationTimingGOOGLERef(ref unsafe.Pointer) *PastPresentationTimingGOOGLE {
	if ref == nil {
		return nil
	}
	obj := new(PastPresentationTimingGOOGLE)
	obj.refac8cf1d8 = (*C.VkPastPresentationTimingGOOGLE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PastPresentationTimingGOOGLE) PassRef() (*C.VkPastPresentationTimingGOOGLE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refac8cf1d8 != nil {
		return x.refac8cf1d8, nil
	}
	memac8cf1d8 := allocPastPresentationTimingGOOGLEMemory(1)
	refac8cf1d8 := (*C.VkPastPresentationTimingGOOGLE)(memac8cf1d8)
	allocsac8cf1d8 := new(cgoAllocMap)
	allocsac8cf1d8.Add(memac8cf1d8)

	var cpresentID_allocs *cgoAllocMap
	refac8cf1d8.presentID, cpresentID_allocs = (C.uint32_t)(x.PresentID), cgoAllocsUnknown
	allocsac8cf1d8.Borrow(cpresentID_allocs)

	var cdesiredPresentTime_allocs *cgoAllocMap
	refac8cf1d8.desiredPresentTime, cdesiredPresentTime_allocs = (C.uint64_t)(x.DesiredPresentTime), cgoAllocsUnknown
	allocsac8cf1d8.Borrow(cdesiredPresentTime_allocs)

	var cactualPresentTime_allocs *cgoAllocMap
	refac8cf1d8.actualPresentTime, cactualPresentTime_allocs = (C.uint64_t)(x.ActualPresentTime), cgoAllocsUnknown
	allocsac8cf1d8.Borrow(cactualPresentTime_allocs)

	var cearliestPresentTime_allocs *cgoAllocMap
	refac8cf1d8.earliestPresentTime, cearliestPresentTime_allocs = (C.uint64_t)(x.EarliestPresentTime), cgoAllocsUnknown
	allocsac8cf1d8.Borrow(cearliestPresentTime_allocs)

	var cpresentMargin_allocs *cgoAllocMap
	refac8cf1d8.presentMargin, cpresentMargin_allocs = (C.uint64_t)(x.PresentMargin), cgoAllocsUnknown
	allocsac8cf1d8.Borrow(cpresentMargin_allocs)

	x.refac8cf1d8 = refac8cf1d8
	x.allocsac8cf1d8 = allocsac8cf1d8
	return refac8cf1d8, allocsac8cf1d8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PastPresentationTimingGOOGLE) PassValue() (C.VkPastPresentationTimingGOOGLE, *cgoAllocMap) {
	if x.refac8cf1d8 != nil {
		return *x.refac8cf1d8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PastPresentationTimingGOOGLE) Deref() {
	if x.refac8cf1d8 == nil {
		return
	}
	x.PresentID = (uint32)(x.refac8cf1d8.presentID)
	x.DesiredPresentTime = (uint64)(x.refac8cf1d8.desiredPresentTime)
	x.ActualPresentTime = (uint64)(x.refac8cf1d8.actualPresentTime)
	x.EarliestPresentTime = (uint64)(x.refac8cf1d8.earliestPresentTime)
	x.PresentMargin = (uint64)(x.refac8cf1d8.presentMargin)
}

// allocPresentTimeGOOGLEMemory allocates memory for type C.VkPresentTimeGOOGLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentTimeGOOGLEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentTimeGOOGLEValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPresentTimeGOOGLEValue = unsafe.Sizeof([1]C.VkPresentTimeGOOGLE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentTimeGOOGLE) Ref() *C.VkPresentTimeGOOGLE {
	if x == nil {
		return nil
	}
	return x.ref9cd90ade
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentTimeGOOGLE) Free() {
	if x != nil && x.allocs9cd90ade != nil {
		x.allocs9cd90ade.(*cgoAllocMap).Free()
		x.ref9cd90ade = nil
	}
}

// NewPresentTimeGOOGLERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentTimeGOOGLERef(ref unsafe.Pointer) *PresentTimeGOOGLE {
	if ref == nil {
		return nil
	}
	obj := new(PresentTimeGOOGLE)
	obj.ref9cd90ade = (*C.VkPresentTimeGOOGLE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentTimeGOOGLE) PassRef() (*C.VkPresentTimeGOOGLE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9cd90ade != nil {
		return x.ref9cd90ade, nil
	}
	mem9cd90ade := allocPresentTimeGOOGLEMemory(1)
	ref9cd90ade := (*C.VkPresentTimeGOOGLE)(mem9cd90ade)
	allocs9cd90ade := new(cgoAllocMap)
	allocs9cd90ade.Add(mem9cd90ade)

	var cpresentID_allocs *cgoAllocMap
	ref9cd90ade.presentID, cpresentID_allocs = (C.uint32_t)(x.PresentID), cgoAllocsUnknown
	allocs9cd90ade.Borrow(cpresentID_allocs)

	var cdesiredPresentTime_allocs *cgoAllocMap
	ref9cd90ade.desiredPresentTime, cdesiredPresentTime_allocs = (C.uint64_t)(x.DesiredPresentTime), cgoAllocsUnknown
	allocs9cd90ade.Borrow(cdesiredPresentTime_allocs)

	x.ref9cd90ade = ref9cd90ade
	x.allocs9cd90ade = allocs9cd90ade
	return ref9cd90ade, allocs9cd90ade

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentTimeGOOGLE) PassValue() (C.VkPresentTimeGOOGLE, *cgoAllocMap) {
	if x.ref9cd90ade != nil {
		return *x.ref9cd90ade, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentTimeGOOGLE) Deref() {
	if x.ref9cd90ade == nil {
		return
	}
	x.PresentID = (uint32)(x.ref9cd90ade.presentID)
	x.DesiredPresentTime = (uint64)(x.ref9cd90ade.desiredPresentTime)
}

// allocPresentTimesInfoGOOGLEMemory allocates memory for type C.VkPresentTimesInfoGOOGLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentTimesInfoGOOGLEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentTimesInfoGOOGLEValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPresentTimesInfoGOOGLEValue = unsafe.Sizeof([1]C.VkPresentTimesInfoGOOGLE{})

// unpackSPresentTimeGOOGLE transforms a sliced Go data structure into plain C format.
func unpackSPresentTimeGOOGLE(x []PresentTimeGOOGLE) (unpacked *C.VkPresentTimeGOOGLE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkPresentTimeGOOGLE) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPresentTimeGOOGLEMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPresentTimeGOOGLE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPresentTimeGOOGLE)(h.Data)
	return
}

// packSPresentTimeGOOGLE reads sliced Go data structure out from plain C format.
func packSPresentTimeGOOGLE(v []PresentTimeGOOGLE, ptr0 *C.VkPresentTimeGOOGLE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPresentTimeGOOGLEValue]C.VkPresentTimeGOOGLE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPresentTimeGOOGLERef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentTimesInfoGOOGLE) Ref() *C.VkPresentTimesInfoGOOGLE {
	if x == nil {
		return nil
	}
	return x.ref70eb8ab3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentTimesInfoGOOGLE) Free() {
	if x != nil && x.allocs70eb8ab3 != nil {
		x.allocs70eb8ab3.(*cgoAllocMap).Free()
		x.ref70eb8ab3 = nil
	}
}

// NewPresentTimesInfoGOOGLERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentTimesInfoGOOGLERef(ref unsafe.Pointer) *PresentTimesInfoGOOGLE {
	if ref == nil {
		return nil
	}
	obj := new(PresentTimesInfoGOOGLE)
	obj.ref70eb8ab3 = (*C.VkPresentTimesInfoGOOGLE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentTimesInfoGOOGLE) PassRef() (*C.VkPresentTimesInfoGOOGLE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref70eb8ab3 != nil {
		return x.ref70eb8ab3, nil
	}
	mem70eb8ab3 := allocPresentTimesInfoGOOGLEMemory(1)
	ref70eb8ab3 := (*C.VkPresentTimesInfoGOOGLE)(mem70eb8ab3)
	allocs70eb8ab3 := new(cgoAllocMap)
	allocs70eb8ab3.Add(mem70eb8ab3)

	var csType_allocs *cgoAllocMap
	ref70eb8ab3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs70eb8ab3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref70eb8ab3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs70eb8ab3.Borrow(cpNext_allocs)

	var cswapchainCount_allocs *cgoAllocMap
	ref70eb8ab3.swapchainCount, cswapchainCount_allocs = (C.uint32_t)(x.SwapchainCount), cgoAllocsUnknown
	allocs70eb8ab3.Borrow(cswapchainCount_allocs)

	var cpTimes_allocs *cgoAllocMap
	ref70eb8ab3.pTimes, cpTimes_allocs = unpackSPresentTimeGOOGLE(x.PTimes)
	allocs70eb8ab3.Borrow(cpTimes_allocs)

	x.ref70eb8ab3 = ref70eb8ab3
	x.allocs70eb8ab3 = allocs70eb8ab3
	return ref70eb8ab3, allocs70eb8ab3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentTimesInfoGOOGLE) PassValue() (C.VkPresentTimesInfoGOOGLE, *cgoAllocMap) {
	if x.ref70eb8ab3 != nil {
		return *x.ref70eb8ab3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentTimesInfoGOOGLE) Deref() {
	if x.ref70eb8ab3 == nil {
		return
	}
	x.SType = (StructureType)(x.ref70eb8ab3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref70eb8ab3.pNext))
	x.SwapchainCount = (uint32)(x.ref70eb8ab3.swapchainCount)
	packSPresentTimeGOOGLE(x.PTimes, x.ref70eb8ab3.pTimes)
}

// allocPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXMemory allocates memory for type C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) Ref() *C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
	if x == nil {
		return nil
	}
	return x.refbaf399ad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) Free() {
	if x != nil && x.allocsbaf399ad != nil {
		x.allocsbaf399ad.(*cgoAllocMap).Free()
		x.refbaf399ad = nil
	}
}

// NewPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXRef(ref unsafe.Pointer) *PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX)
	obj.refbaf399ad = (*C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) PassRef() (*C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbaf399ad != nil {
		return x.refbaf399ad, nil
	}
	membaf399ad := allocPhysicalDeviceMultiviewPerViewAttributesPropertiesNVXMemory(1)
	refbaf399ad := (*C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX)(membaf399ad)
	allocsbaf399ad := new(cgoAllocMap)
	allocsbaf399ad.Add(membaf399ad)

	var csType_allocs *cgoAllocMap
	refbaf399ad.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbaf399ad.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbaf399ad.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbaf399ad.Borrow(cpNext_allocs)

	var cperViewPositionAllComponents_allocs *cgoAllocMap
	refbaf399ad.perViewPositionAllComponents, cperViewPositionAllComponents_allocs = (C.VkBool32)(x.PerViewPositionAllComponents), cgoAllocsUnknown
	allocsbaf399ad.Borrow(cperViewPositionAllComponents_allocs)

	x.refbaf399ad = refbaf399ad
	x.allocsbaf399ad = allocsbaf399ad
	return refbaf399ad, allocsbaf399ad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) PassValue() (C.VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, *cgoAllocMap) {
	if x.refbaf399ad != nil {
		return *x.refbaf399ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) Deref() {
	if x.refbaf399ad == nil {
		return
	}
	x.SType = (StructureType)(x.refbaf399ad.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbaf399ad.pNext))
	x.PerViewPositionAllComponents = (Bool32)(x.refbaf399ad.perViewPositionAllComponents)
}

// allocViewportSwizzleNVMemory allocates memory for type C.VkViewportSwizzleNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocViewportSwizzleNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfViewportSwizzleNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfViewportSwizzleNVValue = unsafe.Sizeof([1]C.VkViewportSwizzleNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ViewportSwizzleNV) Ref() *C.VkViewportSwizzleNV {
	if x == nil {
		return nil
	}
	return x.ref74ff2887
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ViewportSwizzleNV) Free() {
	if x != nil && x.allocs74ff2887 != nil {
		x.allocs74ff2887.(*cgoAllocMap).Free()
		x.ref74ff2887 = nil
	}
}

// NewViewportSwizzleNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewViewportSwizzleNVRef(ref unsafe.Pointer) *ViewportSwizzleNV {
	if ref == nil {
		return nil
	}
	obj := new(ViewportSwizzleNV)
	obj.ref74ff2887 = (*C.VkViewportSwizzleNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ViewportSwizzleNV) PassRef() (*C.VkViewportSwizzleNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref74ff2887 != nil {
		return x.ref74ff2887, nil
	}
	mem74ff2887 := allocViewportSwizzleNVMemory(1)
	ref74ff2887 := (*C.VkViewportSwizzleNV)(mem74ff2887)
	allocs74ff2887 := new(cgoAllocMap)
	allocs74ff2887.Add(mem74ff2887)

	var cx_allocs *cgoAllocMap
	ref74ff2887.x, cx_allocs = (C.VkViewportCoordinateSwizzleNV)(x.X), cgoAllocsUnknown
	allocs74ff2887.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref74ff2887.y, cy_allocs = (C.VkViewportCoordinateSwizzleNV)(x.Y), cgoAllocsUnknown
	allocs74ff2887.Borrow(cy_allocs)

	var cz_allocs *cgoAllocMap
	ref74ff2887.z, cz_allocs = (C.VkViewportCoordinateSwizzleNV)(x.Z), cgoAllocsUnknown
	allocs74ff2887.Borrow(cz_allocs)

	var cw_allocs *cgoAllocMap
	ref74ff2887.w, cw_allocs = (C.VkViewportCoordinateSwizzleNV)(x.W), cgoAllocsUnknown
	allocs74ff2887.Borrow(cw_allocs)

	x.ref74ff2887 = ref74ff2887
	x.allocs74ff2887 = allocs74ff2887
	return ref74ff2887, allocs74ff2887

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ViewportSwizzleNV) PassValue() (C.VkViewportSwizzleNV, *cgoAllocMap) {
	if x.ref74ff2887 != nil {
		return *x.ref74ff2887, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ViewportSwizzleNV) Deref() {
	if x.ref74ff2887 == nil {
		return
	}
	x.X = (ViewportCoordinateSwizzleNV)(x.ref74ff2887.x)
	x.Y = (ViewportCoordinateSwizzleNV)(x.ref74ff2887.y)
	x.Z = (ViewportCoordinateSwizzleNV)(x.ref74ff2887.z)
	x.W = (ViewportCoordinateSwizzleNV)(x.ref74ff2887.w)
}

// allocPipelineViewportSwizzleStateCreateInfoNVMemory allocates memory for type C.VkPipelineViewportSwizzleStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportSwizzleStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportSwizzleStateCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineViewportSwizzleStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineViewportSwizzleStateCreateInfoNV{})

// unpackSViewportSwizzleNV transforms a sliced Go data structure into plain C format.
func unpackSViewportSwizzleNV(x []ViewportSwizzleNV) (unpacked *C.VkViewportSwizzleNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkViewportSwizzleNV) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocViewportSwizzleNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkViewportSwizzleNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkViewportSwizzleNV)(h.Data)
	return
}

// packSViewportSwizzleNV reads sliced Go data structure out from plain C format.
func packSViewportSwizzleNV(v []ViewportSwizzleNV, ptr0 *C.VkViewportSwizzleNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfViewportSwizzleNVValue]C.VkViewportSwizzleNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewViewportSwizzleNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportSwizzleStateCreateInfoNV) Ref() *C.VkPipelineViewportSwizzleStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref5e90f24
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportSwizzleStateCreateInfoNV) Free() {
	if x != nil && x.allocs5e90f24 != nil {
		x.allocs5e90f24.(*cgoAllocMap).Free()
		x.ref5e90f24 = nil
	}
}

// NewPipelineViewportSwizzleStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportSwizzleStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineViewportSwizzleStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportSwizzleStateCreateInfoNV)
	obj.ref5e90f24 = (*C.VkPipelineViewportSwizzleStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportSwizzleStateCreateInfoNV) PassRef() (*C.VkPipelineViewportSwizzleStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5e90f24 != nil {
		return x.ref5e90f24, nil
	}
	mem5e90f24 := allocPipelineViewportSwizzleStateCreateInfoNVMemory(1)
	ref5e90f24 := (*C.VkPipelineViewportSwizzleStateCreateInfoNV)(mem5e90f24)
	allocs5e90f24 := new(cgoAllocMap)
	allocs5e90f24.Add(mem5e90f24)

	var csType_allocs *cgoAllocMap
	ref5e90f24.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5e90f24.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5e90f24.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5e90f24.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref5e90f24.flags, cflags_allocs = (C.VkPipelineViewportSwizzleStateCreateFlagsNV)(x.Flags), cgoAllocsUnknown
	allocs5e90f24.Borrow(cflags_allocs)

	var cviewportCount_allocs *cgoAllocMap
	ref5e90f24.viewportCount, cviewportCount_allocs = (C.uint32_t)(x.ViewportCount), cgoAllocsUnknown
	allocs5e90f24.Borrow(cviewportCount_allocs)

	var cpViewportSwizzles_allocs *cgoAllocMap
	ref5e90f24.pViewportSwizzles, cpViewportSwizzles_allocs = unpackSViewportSwizzleNV(x.PViewportSwizzles)
	allocs5e90f24.Borrow(cpViewportSwizzles_allocs)

	x.ref5e90f24 = ref5e90f24
	x.allocs5e90f24 = allocs5e90f24
	return ref5e90f24, allocs5e90f24

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportSwizzleStateCreateInfoNV) PassValue() (C.VkPipelineViewportSwizzleStateCreateInfoNV, *cgoAllocMap) {
	if x.ref5e90f24 != nil {
		return *x.ref5e90f24, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportSwizzleStateCreateInfoNV) Deref() {
	if x.ref5e90f24 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5e90f24.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5e90f24.pNext))
	x.Flags = (PipelineViewportSwizzleStateCreateFlagsNV)(x.ref5e90f24.flags)
	x.ViewportCount = (uint32)(x.ref5e90f24.viewportCount)
	packSViewportSwizzleNV(x.PViewportSwizzles, x.ref5e90f24.pViewportSwizzles)
}

// allocPhysicalDeviceDiscardRectanglePropertiesMemory allocates memory for type C.VkPhysicalDeviceDiscardRectanglePropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDiscardRectanglePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDiscardRectanglePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceDiscardRectanglePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDiscardRectanglePropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDiscardRectangleProperties) Ref() *C.VkPhysicalDeviceDiscardRectanglePropertiesEXT {
	if x == nil {
		return nil
	}
	return x.reffe8591da
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDiscardRectangleProperties) Free() {
	if x != nil && x.allocsfe8591da != nil {
		x.allocsfe8591da.(*cgoAllocMap).Free()
		x.reffe8591da = nil
	}
}

// NewPhysicalDeviceDiscardRectanglePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDiscardRectanglePropertiesRef(ref unsafe.Pointer) *PhysicalDeviceDiscardRectangleProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDiscardRectangleProperties)
	obj.reffe8591da = (*C.VkPhysicalDeviceDiscardRectanglePropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDiscardRectangleProperties) PassRef() (*C.VkPhysicalDeviceDiscardRectanglePropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe8591da != nil {
		return x.reffe8591da, nil
	}
	memfe8591da := allocPhysicalDeviceDiscardRectanglePropertiesMemory(1)
	reffe8591da := (*C.VkPhysicalDeviceDiscardRectanglePropertiesEXT)(memfe8591da)
	allocsfe8591da := new(cgoAllocMap)
	allocsfe8591da.Add(memfe8591da)

	var csType_allocs *cgoAllocMap
	reffe8591da.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfe8591da.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffe8591da.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfe8591da.Borrow(cpNext_allocs)

	var cmaxDiscardRectangles_allocs *cgoAllocMap
	reffe8591da.maxDiscardRectangles, cmaxDiscardRectangles_allocs = (C.uint32_t)(x.MaxDiscardRectangles), cgoAllocsUnknown
	allocsfe8591da.Borrow(cmaxDiscardRectangles_allocs)

	x.reffe8591da = reffe8591da
	x.allocsfe8591da = allocsfe8591da
	return reffe8591da, allocsfe8591da

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDiscardRectangleProperties) PassValue() (C.VkPhysicalDeviceDiscardRectanglePropertiesEXT, *cgoAllocMap) {
	if x.reffe8591da != nil {
		return *x.reffe8591da, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDiscardRectangleProperties) Deref() {
	if x.reffe8591da == nil {
		return
	}
	x.SType = (StructureType)(x.reffe8591da.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe8591da.pNext))
	x.MaxDiscardRectangles = (uint32)(x.reffe8591da.maxDiscardRectangles)
}

// allocPipelineDiscardRectangleStateCreateInfoMemory allocates memory for type C.VkPipelineDiscardRectangleStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineDiscardRectangleStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineDiscardRectangleStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineDiscardRectangleStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineDiscardRectangleStateCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineDiscardRectangleStateCreateInfo) Ref() *C.VkPipelineDiscardRectangleStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refcdbb125e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineDiscardRectangleStateCreateInfo) Free() {
	if x != nil && x.allocscdbb125e != nil {
		x.allocscdbb125e.(*cgoAllocMap).Free()
		x.refcdbb125e = nil
	}
}

// NewPipelineDiscardRectangleStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineDiscardRectangleStateCreateInfoRef(ref unsafe.Pointer) *PipelineDiscardRectangleStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineDiscardRectangleStateCreateInfo)
	obj.refcdbb125e = (*C.VkPipelineDiscardRectangleStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineDiscardRectangleStateCreateInfo) PassRef() (*C.VkPipelineDiscardRectangleStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcdbb125e != nil {
		return x.refcdbb125e, nil
	}
	memcdbb125e := allocPipelineDiscardRectangleStateCreateInfoMemory(1)
	refcdbb125e := (*C.VkPipelineDiscardRectangleStateCreateInfoEXT)(memcdbb125e)
	allocscdbb125e := new(cgoAllocMap)
	allocscdbb125e.Add(memcdbb125e)

	var csType_allocs *cgoAllocMap
	refcdbb125e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscdbb125e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcdbb125e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscdbb125e.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refcdbb125e.flags, cflags_allocs = (C.VkPipelineDiscardRectangleStateCreateFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocscdbb125e.Borrow(cflags_allocs)

	var cdiscardRectangleMode_allocs *cgoAllocMap
	refcdbb125e.discardRectangleMode, cdiscardRectangleMode_allocs = (C.VkDiscardRectangleModeEXT)(x.DiscardRectangleMode), cgoAllocsUnknown
	allocscdbb125e.Borrow(cdiscardRectangleMode_allocs)

	var cdiscardRectangleCount_allocs *cgoAllocMap
	refcdbb125e.discardRectangleCount, cdiscardRectangleCount_allocs = (C.uint32_t)(x.DiscardRectangleCount), cgoAllocsUnknown
	allocscdbb125e.Borrow(cdiscardRectangleCount_allocs)

	var cpDiscardRectangles_allocs *cgoAllocMap
	refcdbb125e.pDiscardRectangles, cpDiscardRectangles_allocs = unpackSRect2D(x.PDiscardRectangles)
	allocscdbb125e.Borrow(cpDiscardRectangles_allocs)

	x.refcdbb125e = refcdbb125e
	x.allocscdbb125e = allocscdbb125e
	return refcdbb125e, allocscdbb125e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineDiscardRectangleStateCreateInfo) PassValue() (C.VkPipelineDiscardRectangleStateCreateInfoEXT, *cgoAllocMap) {
	if x.refcdbb125e != nil {
		return *x.refcdbb125e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineDiscardRectangleStateCreateInfo) Deref() {
	if x.refcdbb125e == nil {
		return
	}
	x.SType = (StructureType)(x.refcdbb125e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcdbb125e.pNext))
	x.Flags = (PipelineDiscardRectangleStateCreateFlags)(x.refcdbb125e.flags)
	x.DiscardRectangleMode = (DiscardRectangleMode)(x.refcdbb125e.discardRectangleMode)
	x.DiscardRectangleCount = (uint32)(x.refcdbb125e.discardRectangleCount)
	packSRect2D(x.PDiscardRectangles, x.refcdbb125e.pDiscardRectangles)
}

// allocPhysicalDeviceConservativeRasterizationPropertiesMemory allocates memory for type C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceConservativeRasterizationPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceConservativeRasterizationPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceConservativeRasterizationPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceConservativeRasterizationProperties) Ref() *C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref878f819c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceConservativeRasterizationProperties) Free() {
	if x != nil && x.allocs878f819c != nil {
		x.allocs878f819c.(*cgoAllocMap).Free()
		x.ref878f819c = nil
	}
}

// NewPhysicalDeviceConservativeRasterizationPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceConservativeRasterizationPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceConservativeRasterizationProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceConservativeRasterizationProperties)
	obj.ref878f819c = (*C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceConservativeRasterizationProperties) PassRef() (*C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref878f819c != nil {
		return x.ref878f819c, nil
	}
	mem878f819c := allocPhysicalDeviceConservativeRasterizationPropertiesMemory(1)
	ref878f819c := (*C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT)(mem878f819c)
	allocs878f819c := new(cgoAllocMap)
	allocs878f819c.Add(mem878f819c)

	var csType_allocs *cgoAllocMap
	ref878f819c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs878f819c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref878f819c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs878f819c.Borrow(cpNext_allocs)

	var cprimitiveOverestimationSize_allocs *cgoAllocMap
	ref878f819c.primitiveOverestimationSize, cprimitiveOverestimationSize_allocs = (C.float)(x.PrimitiveOverestimationSize), cgoAllocsUnknown
	allocs878f819c.Borrow(cprimitiveOverestimationSize_allocs)

	var cmaxExtraPrimitiveOverestimationSize_allocs *cgoAllocMap
	ref878f819c.maxExtraPrimitiveOverestimationSize, cmaxExtraPrimitiveOverestimationSize_allocs = (C.float)(x.MaxExtraPrimitiveOverestimationSize), cgoAllocsUnknown
	allocs878f819c.Borrow(cmaxExtraPrimitiveOverestimationSize_allocs)

	var cextraPrimitiveOverestimationSizeGranularity_allocs *cgoAllocMap
	ref878f819c.extraPrimitiveOverestimationSizeGranularity, cextraPrimitiveOverestimationSizeGranularity_allocs = (C.float)(x.ExtraPrimitiveOverestimationSizeGranularity), cgoAllocsUnknown
	allocs878f819c.Borrow(cextraPrimitiveOverestimationSizeGranularity_allocs)

	var cprimitiveUnderestimation_allocs *cgoAllocMap
	ref878f819c.primitiveUnderestimation, cprimitiveUnderestimation_allocs = (C.VkBool32)(x.PrimitiveUnderestimation), cgoAllocsUnknown
	allocs878f819c.Borrow(cprimitiveUnderestimation_allocs)

	var cconservativePointAndLineRasterization_allocs *cgoAllocMap
	ref878f819c.conservativePointAndLineRasterization, cconservativePointAndLineRasterization_allocs = (C.VkBool32)(x.ConservativePointAndLineRasterization), cgoAllocsUnknown
	allocs878f819c.Borrow(cconservativePointAndLineRasterization_allocs)

	var cdegenerateTrianglesRasterized_allocs *cgoAllocMap
	ref878f819c.degenerateTrianglesRasterized, cdegenerateTrianglesRasterized_allocs = (C.VkBool32)(x.DegenerateTrianglesRasterized), cgoAllocsUnknown
	allocs878f819c.Borrow(cdegenerateTrianglesRasterized_allocs)

	var cdegenerateLinesRasterized_allocs *cgoAllocMap
	ref878f819c.degenerateLinesRasterized, cdegenerateLinesRasterized_allocs = (C.VkBool32)(x.DegenerateLinesRasterized), cgoAllocsUnknown
	allocs878f819c.Borrow(cdegenerateLinesRasterized_allocs)

	var cfullyCoveredFragmentShaderInputVariable_allocs *cgoAllocMap
	ref878f819c.fullyCoveredFragmentShaderInputVariable, cfullyCoveredFragmentShaderInputVariable_allocs = (C.VkBool32)(x.FullyCoveredFragmentShaderInputVariable), cgoAllocsUnknown
	allocs878f819c.Borrow(cfullyCoveredFragmentShaderInputVariable_allocs)

	var cconservativeRasterizationPostDepthCoverage_allocs *cgoAllocMap
	ref878f819c.conservativeRasterizationPostDepthCoverage, cconservativeRasterizationPostDepthCoverage_allocs = (C.VkBool32)(x.ConservativeRasterizationPostDepthCoverage), cgoAllocsUnknown
	allocs878f819c.Borrow(cconservativeRasterizationPostDepthCoverage_allocs)

	x.ref878f819c = ref878f819c
	x.allocs878f819c = allocs878f819c
	return ref878f819c, allocs878f819c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceConservativeRasterizationProperties) PassValue() (C.VkPhysicalDeviceConservativeRasterizationPropertiesEXT, *cgoAllocMap) {
	if x.ref878f819c != nil {
		return *x.ref878f819c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceConservativeRasterizationProperties) Deref() {
	if x.ref878f819c == nil {
		return
	}
	x.SType = (StructureType)(x.ref878f819c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref878f819c.pNext))
	x.PrimitiveOverestimationSize = (float32)(x.ref878f819c.primitiveOverestimationSize)
	x.MaxExtraPrimitiveOverestimationSize = (float32)(x.ref878f819c.maxExtraPrimitiveOverestimationSize)
	x.ExtraPrimitiveOverestimationSizeGranularity = (float32)(x.ref878f819c.extraPrimitiveOverestimationSizeGranularity)
	x.PrimitiveUnderestimation = (Bool32)(x.ref878f819c.primitiveUnderestimation)
	x.ConservativePointAndLineRasterization = (Bool32)(x.ref878f819c.conservativePointAndLineRasterization)
	x.DegenerateTrianglesRasterized = (Bool32)(x.ref878f819c.degenerateTrianglesRasterized)
	x.DegenerateLinesRasterized = (Bool32)(x.ref878f819c.degenerateLinesRasterized)
	x.FullyCoveredFragmentShaderInputVariable = (Bool32)(x.ref878f819c.fullyCoveredFragmentShaderInputVariable)
	x.ConservativeRasterizationPostDepthCoverage = (Bool32)(x.ref878f819c.conservativeRasterizationPostDepthCoverage)
}

// allocPipelineRasterizationConservativeStateCreateInfoMemory allocates memory for type C.VkPipelineRasterizationConservativeStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRasterizationConservativeStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRasterizationConservativeStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineRasterizationConservativeStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineRasterizationConservativeStateCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineRasterizationConservativeStateCreateInfo) Ref() *C.VkPipelineRasterizationConservativeStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refe3cd0046
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineRasterizationConservativeStateCreateInfo) Free() {
	if x != nil && x.allocse3cd0046 != nil {
		x.allocse3cd0046.(*cgoAllocMap).Free()
		x.refe3cd0046 = nil
	}
}

// NewPipelineRasterizationConservativeStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineRasterizationConservativeStateCreateInfoRef(ref unsafe.Pointer) *PipelineRasterizationConservativeStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRasterizationConservativeStateCreateInfo)
	obj.refe3cd0046 = (*C.VkPipelineRasterizationConservativeStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineRasterizationConservativeStateCreateInfo) PassRef() (*C.VkPipelineRasterizationConservativeStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe3cd0046 != nil {
		return x.refe3cd0046, nil
	}
	meme3cd0046 := allocPipelineRasterizationConservativeStateCreateInfoMemory(1)
	refe3cd0046 := (*C.VkPipelineRasterizationConservativeStateCreateInfoEXT)(meme3cd0046)
	allocse3cd0046 := new(cgoAllocMap)
	allocse3cd0046.Add(meme3cd0046)

	var csType_allocs *cgoAllocMap
	refe3cd0046.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocse3cd0046.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refe3cd0046.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocse3cd0046.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refe3cd0046.flags, cflags_allocs = (C.VkPipelineRasterizationConservativeStateCreateFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocse3cd0046.Borrow(cflags_allocs)

	var cconservativeRasterizationMode_allocs *cgoAllocMap
	refe3cd0046.conservativeRasterizationMode, cconservativeRasterizationMode_allocs = (C.VkConservativeRasterizationModeEXT)(x.ConservativeRasterizationMode), cgoAllocsUnknown
	allocse3cd0046.Borrow(cconservativeRasterizationMode_allocs)

	var cextraPrimitiveOverestimationSize_allocs *cgoAllocMap
	refe3cd0046.extraPrimitiveOverestimationSize, cextraPrimitiveOverestimationSize_allocs = (C.float)(x.ExtraPrimitiveOverestimationSize), cgoAllocsUnknown
	allocse3cd0046.Borrow(cextraPrimitiveOverestimationSize_allocs)

	x.refe3cd0046 = refe3cd0046
	x.allocse3cd0046 = allocse3cd0046
	return refe3cd0046, allocse3cd0046

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineRasterizationConservativeStateCreateInfo) PassValue() (C.VkPipelineRasterizationConservativeStateCreateInfoEXT, *cgoAllocMap) {
	if x.refe3cd0046 != nil {
		return *x.refe3cd0046, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineRasterizationConservativeStateCreateInfo) Deref() {
	if x.refe3cd0046 == nil {
		return
	}
	x.SType = (StructureType)(x.refe3cd0046.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe3cd0046.pNext))
	x.Flags = (PipelineRasterizationConservativeStateCreateFlags)(x.refe3cd0046.flags)
	x.ConservativeRasterizationMode = (ConservativeRasterizationMode)(x.refe3cd0046.conservativeRasterizationMode)
	x.ExtraPrimitiveOverestimationSize = (float32)(x.refe3cd0046.extraPrimitiveOverestimationSize)
}

// allocXYColorMemory allocates memory for type C.VkXYColorEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXYColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXYColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfXYColorValue = unsafe.Sizeof([1]C.VkXYColorEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *XYColor) Ref() *C.VkXYColorEXT {
	if x == nil {
		return nil
	}
	return x.refb8efaa5c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *XYColor) Free() {
	if x != nil && x.allocsb8efaa5c != nil {
		x.allocsb8efaa5c.(*cgoAllocMap).Free()
		x.refb8efaa5c = nil
	}
}

// NewXYColorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewXYColorRef(ref unsafe.Pointer) *XYColor {
	if ref == nil {
		return nil
	}
	obj := new(XYColor)
	obj.refb8efaa5c = (*C.VkXYColorEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *XYColor) PassRef() (*C.VkXYColorEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8efaa5c != nil {
		return x.refb8efaa5c, nil
	}
	memb8efaa5c := allocXYColorMemory(1)
	refb8efaa5c := (*C.VkXYColorEXT)(memb8efaa5c)
	allocsb8efaa5c := new(cgoAllocMap)
	allocsb8efaa5c.Add(memb8efaa5c)

	var cx_allocs *cgoAllocMap
	refb8efaa5c.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocsb8efaa5c.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refb8efaa5c.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocsb8efaa5c.Borrow(cy_allocs)

	x.refb8efaa5c = refb8efaa5c
	x.allocsb8efaa5c = allocsb8efaa5c
	return refb8efaa5c, allocsb8efaa5c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x XYColor) PassValue() (C.VkXYColorEXT, *cgoAllocMap) {
	if x.refb8efaa5c != nil {
		return *x.refb8efaa5c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *XYColor) Deref() {
	if x.refb8efaa5c == nil {
		return
	}
	x.X = (float32)(x.refb8efaa5c.x)
	x.Y = (float32)(x.refb8efaa5c.y)
}

// allocHdrMetadataMemory allocates memory for type C.VkHdrMetadataEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocHdrMetadataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfHdrMetadataValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfHdrMetadataValue = unsafe.Sizeof([1]C.VkHdrMetadataEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *HdrMetadata) Ref() *C.VkHdrMetadataEXT {
	if x == nil {
		return nil
	}
	return x.ref5fd28976
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *HdrMetadata) Free() {
	if x != nil && x.allocs5fd28976 != nil {
		x.allocs5fd28976.(*cgoAllocMap).Free()
		x.ref5fd28976 = nil
	}
}

// NewHdrMetadataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewHdrMetadataRef(ref unsafe.Pointer) *HdrMetadata {
	if ref == nil {
		return nil
	}
	obj := new(HdrMetadata)
	obj.ref5fd28976 = (*C.VkHdrMetadataEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *HdrMetadata) PassRef() (*C.VkHdrMetadataEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5fd28976 != nil {
		return x.ref5fd28976, nil
	}
	mem5fd28976 := allocHdrMetadataMemory(1)
	ref5fd28976 := (*C.VkHdrMetadataEXT)(mem5fd28976)
	allocs5fd28976 := new(cgoAllocMap)
	allocs5fd28976.Add(mem5fd28976)

	var csType_allocs *cgoAllocMap
	ref5fd28976.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5fd28976.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5fd28976.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5fd28976.Borrow(cpNext_allocs)

	var cdisplayPrimaryRed_allocs *cgoAllocMap
	ref5fd28976.displayPrimaryRed, cdisplayPrimaryRed_allocs = x.DisplayPrimaryRed.PassValue()
	allocs5fd28976.Borrow(cdisplayPrimaryRed_allocs)

	var cdisplayPrimaryGreen_allocs *cgoAllocMap
	ref5fd28976.displayPrimaryGreen, cdisplayPrimaryGreen_allocs = x.DisplayPrimaryGreen.PassValue()
	allocs5fd28976.Borrow(cdisplayPrimaryGreen_allocs)

	var cdisplayPrimaryBlue_allocs *cgoAllocMap
	ref5fd28976.displayPrimaryBlue, cdisplayPrimaryBlue_allocs = x.DisplayPrimaryBlue.PassValue()
	allocs5fd28976.Borrow(cdisplayPrimaryBlue_allocs)

	var cwhitePoint_allocs *cgoAllocMap
	ref5fd28976.whitePoint, cwhitePoint_allocs = x.WhitePoint.PassValue()
	allocs5fd28976.Borrow(cwhitePoint_allocs)

	var cmaxLuminance_allocs *cgoAllocMap
	ref5fd28976.maxLuminance, cmaxLuminance_allocs = (C.float)(x.MaxLuminance), cgoAllocsUnknown
	allocs5fd28976.Borrow(cmaxLuminance_allocs)

	var cminLuminance_allocs *cgoAllocMap
	ref5fd28976.minLuminance, cminLuminance_allocs = (C.float)(x.MinLuminance), cgoAllocsUnknown
	allocs5fd28976.Borrow(cminLuminance_allocs)

	var cmaxContentLightLevel_allocs *cgoAllocMap
	ref5fd28976.maxContentLightLevel, cmaxContentLightLevel_allocs = (C.float)(x.MaxContentLightLevel), cgoAllocsUnknown
	allocs5fd28976.Borrow(cmaxContentLightLevel_allocs)

	var cmaxFrameAverageLightLevel_allocs *cgoAllocMap
	ref5fd28976.maxFrameAverageLightLevel, cmaxFrameAverageLightLevel_allocs = (C.float)(x.MaxFrameAverageLightLevel), cgoAllocsUnknown
	allocs5fd28976.Borrow(cmaxFrameAverageLightLevel_allocs)

	x.ref5fd28976 = ref5fd28976
	x.allocs5fd28976 = allocs5fd28976
	return ref5fd28976, allocs5fd28976

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x HdrMetadata) PassValue() (C.VkHdrMetadataEXT, *cgoAllocMap) {
	if x.ref5fd28976 != nil {
		return *x.ref5fd28976, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *HdrMetadata) Deref() {
	if x.ref5fd28976 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5fd28976.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5fd28976.pNext))
	x.DisplayPrimaryRed = *NewXYColorRef(unsafe.Pointer(&x.ref5fd28976.displayPrimaryRed))
	x.DisplayPrimaryGreen = *NewXYColorRef(unsafe.Pointer(&x.ref5fd28976.displayPrimaryGreen))
	x.DisplayPrimaryBlue = *NewXYColorRef(unsafe.Pointer(&x.ref5fd28976.displayPrimaryBlue))
	x.WhitePoint = *NewXYColorRef(unsafe.Pointer(&x.ref5fd28976.whitePoint))
	x.MaxLuminance = (float32)(x.ref5fd28976.maxLuminance)
	x.MinLuminance = (float32)(x.ref5fd28976.minLuminance)
	x.MaxContentLightLevel = (float32)(x.ref5fd28976.maxContentLightLevel)
	x.MaxFrameAverageLightLevel = (float32)(x.ref5fd28976.maxFrameAverageLightLevel)
}

// allocDebugUtilsObjectNameInfoMemory allocates memory for type C.VkDebugUtilsObjectNameInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugUtilsObjectNameInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugUtilsObjectNameInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugUtilsObjectNameInfoValue = unsafe.Sizeof([1]C.VkDebugUtilsObjectNameInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugUtilsObjectNameInfo) Ref() *C.VkDebugUtilsObjectNameInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref5e73c2db
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugUtilsObjectNameInfo) Free() {
	if x != nil && x.allocs5e73c2db != nil {
		x.allocs5e73c2db.(*cgoAllocMap).Free()
		x.ref5e73c2db = nil
	}
}

// NewDebugUtilsObjectNameInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugUtilsObjectNameInfoRef(ref unsafe.Pointer) *DebugUtilsObjectNameInfo {
	if ref == nil {
		return nil
	}
	obj := new(DebugUtilsObjectNameInfo)
	obj.ref5e73c2db = (*C.VkDebugUtilsObjectNameInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugUtilsObjectNameInfo) PassRef() (*C.VkDebugUtilsObjectNameInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5e73c2db != nil {
		return x.ref5e73c2db, nil
	}
	mem5e73c2db := allocDebugUtilsObjectNameInfoMemory(1)
	ref5e73c2db := (*C.VkDebugUtilsObjectNameInfoEXT)(mem5e73c2db)
	allocs5e73c2db := new(cgoAllocMap)
	allocs5e73c2db.Add(mem5e73c2db)

	var csType_allocs *cgoAllocMap
	ref5e73c2db.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5e73c2db.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5e73c2db.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5e73c2db.Borrow(cpNext_allocs)

	var cobjectType_allocs *cgoAllocMap
	ref5e73c2db.objectType, cobjectType_allocs = (C.VkObjectType)(x.ObjectType), cgoAllocsUnknown
	allocs5e73c2db.Borrow(cobjectType_allocs)

	var cobjectHandle_allocs *cgoAllocMap
	ref5e73c2db.objectHandle, cobjectHandle_allocs = (C.uint64_t)(x.ObjectHandle), cgoAllocsUnknown
	allocs5e73c2db.Borrow(cobjectHandle_allocs)

	var cpObjectName_allocs *cgoAllocMap
	ref5e73c2db.pObjectName, cpObjectName_allocs = unpackPCharString(x.PObjectName)
	allocs5e73c2db.Borrow(cpObjectName_allocs)

	x.ref5e73c2db = ref5e73c2db
	x.allocs5e73c2db = allocs5e73c2db
	return ref5e73c2db, allocs5e73c2db

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugUtilsObjectNameInfo) PassValue() (C.VkDebugUtilsObjectNameInfoEXT, *cgoAllocMap) {
	if x.ref5e73c2db != nil {
		return *x.ref5e73c2db, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugUtilsObjectNameInfo) Deref() {
	if x.ref5e73c2db == nil {
		return
	}
	x.SType = (StructureType)(x.ref5e73c2db.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5e73c2db.pNext))
	x.ObjectType = (ObjectType)(x.ref5e73c2db.objectType)
	x.ObjectHandle = (uint64)(x.ref5e73c2db.objectHandle)
	x.PObjectName = packPCharString(x.ref5e73c2db.pObjectName)
}

// allocDebugUtilsObjectTagInfoMemory allocates memory for type C.VkDebugUtilsObjectTagInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugUtilsObjectTagInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugUtilsObjectTagInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugUtilsObjectTagInfoValue = unsafe.Sizeof([1]C.VkDebugUtilsObjectTagInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugUtilsObjectTagInfo) Ref() *C.VkDebugUtilsObjectTagInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref9fd129cf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugUtilsObjectTagInfo) Free() {
	if x != nil && x.allocs9fd129cf != nil {
		x.allocs9fd129cf.(*cgoAllocMap).Free()
		x.ref9fd129cf = nil
	}
}

// NewDebugUtilsObjectTagInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugUtilsObjectTagInfoRef(ref unsafe.Pointer) *DebugUtilsObjectTagInfo {
	if ref == nil {
		return nil
	}
	obj := new(DebugUtilsObjectTagInfo)
	obj.ref9fd129cf = (*C.VkDebugUtilsObjectTagInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugUtilsObjectTagInfo) PassRef() (*C.VkDebugUtilsObjectTagInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9fd129cf != nil {
		return x.ref9fd129cf, nil
	}
	mem9fd129cf := allocDebugUtilsObjectTagInfoMemory(1)
	ref9fd129cf := (*C.VkDebugUtilsObjectTagInfoEXT)(mem9fd129cf)
	allocs9fd129cf := new(cgoAllocMap)
	allocs9fd129cf.Add(mem9fd129cf)

	var csType_allocs *cgoAllocMap
	ref9fd129cf.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9fd129cf.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9fd129cf.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9fd129cf.Borrow(cpNext_allocs)

	var cobjectType_allocs *cgoAllocMap
	ref9fd129cf.objectType, cobjectType_allocs = (C.VkObjectType)(x.ObjectType), cgoAllocsUnknown
	allocs9fd129cf.Borrow(cobjectType_allocs)

	var cobjectHandle_allocs *cgoAllocMap
	ref9fd129cf.objectHandle, cobjectHandle_allocs = (C.uint64_t)(x.ObjectHandle), cgoAllocsUnknown
	allocs9fd129cf.Borrow(cobjectHandle_allocs)

	var ctagName_allocs *cgoAllocMap
	ref9fd129cf.tagName, ctagName_allocs = (C.uint64_t)(x.TagName), cgoAllocsUnknown
	allocs9fd129cf.Borrow(ctagName_allocs)

	var ctagSize_allocs *cgoAllocMap
	ref9fd129cf.tagSize, ctagSize_allocs = (C.size_t)(x.TagSize), cgoAllocsUnknown
	allocs9fd129cf.Borrow(ctagSize_allocs)

	var cpTag_allocs *cgoAllocMap
	ref9fd129cf.pTag, cpTag_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PTag)), cgoAllocsUnknown
	allocs9fd129cf.Borrow(cpTag_allocs)

	x.ref9fd129cf = ref9fd129cf
	x.allocs9fd129cf = allocs9fd129cf
	return ref9fd129cf, allocs9fd129cf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugUtilsObjectTagInfo) PassValue() (C.VkDebugUtilsObjectTagInfoEXT, *cgoAllocMap) {
	if x.ref9fd129cf != nil {
		return *x.ref9fd129cf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugUtilsObjectTagInfo) Deref() {
	if x.ref9fd129cf == nil {
		return
	}
	x.SType = (StructureType)(x.ref9fd129cf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9fd129cf.pNext))
	x.ObjectType = (ObjectType)(x.ref9fd129cf.objectType)
	x.ObjectHandle = (uint64)(x.ref9fd129cf.objectHandle)
	x.TagName = (uint64)(x.ref9fd129cf.tagName)
	x.TagSize = (uint64)(x.ref9fd129cf.tagSize)
	x.PTag = (unsafe.Pointer)(unsafe.Pointer(x.ref9fd129cf.pTag))
}

// allocDebugUtilsLabelMemory allocates memory for type C.VkDebugUtilsLabelEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugUtilsLabelMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugUtilsLabelValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDebugUtilsLabelValue = unsafe.Sizeof([1]C.VkDebugUtilsLabelEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugUtilsLabel) Ref() *C.VkDebugUtilsLabelEXT {
	if x == nil {
		return nil
	}
	return x.ref8faaf7b1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugUtilsLabel) Free() {
	if x != nil && x.allocs8faaf7b1 != nil {
		x.allocs8faaf7b1.(*cgoAllocMap).Free()
		x.ref8faaf7b1 = nil
	}
}

// NewDebugUtilsLabelRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugUtilsLabelRef(ref unsafe.Pointer) *DebugUtilsLabel {
	if ref == nil {
		return nil
	}
	obj := new(DebugUtilsLabel)
	obj.ref8faaf7b1 = (*C.VkDebugUtilsLabelEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugUtilsLabel) PassRef() (*C.VkDebugUtilsLabelEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8faaf7b1 != nil {
		return x.ref8faaf7b1, nil
	}
	mem8faaf7b1 := allocDebugUtilsLabelMemory(1)
	ref8faaf7b1 := (*C.VkDebugUtilsLabelEXT)(mem8faaf7b1)
	allocs8faaf7b1 := new(cgoAllocMap)
	allocs8faaf7b1.Add(mem8faaf7b1)

	var csType_allocs *cgoAllocMap
	ref8faaf7b1.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8faaf7b1.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8faaf7b1.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8faaf7b1.Borrow(cpNext_allocs)

	var cpLabelName_allocs *cgoAllocMap
	ref8faaf7b1.pLabelName, cpLabelName_allocs = unpackPCharString(x.PLabelName)
	allocs8faaf7b1.Borrow(cpLabelName_allocs)

	var ccolor_allocs *cgoAllocMap
	ref8faaf7b1.color, ccolor_allocs = *(*[4]C.float)(unsafe.Pointer(&x.Color)), cgoAllocsUnknown
	allocs8faaf7b1.Borrow(ccolor_allocs)

	x.ref8faaf7b1 = ref8faaf7b1
	x.allocs8faaf7b1 = allocs8faaf7b1
	return ref8faaf7b1, allocs8faaf7b1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugUtilsLabel) PassValue() (C.VkDebugUtilsLabelEXT, *cgoAllocMap) {
	if x.ref8faaf7b1 != nil {
		return *x.ref8faaf7b1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugUtilsLabel) Deref() {
	if x.ref8faaf7b1 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8faaf7b1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8faaf7b1.pNext))
	x.PLabelName = packPCharString(x.ref8faaf7b1.pLabelName)
	x.Color = *(*[4]float32)(unsafe.Pointer(&x.ref8faaf7b1.color))
}

// allocSamplerReductionModeCreateInfoMemory allocates memory for type C.VkSamplerReductionModeCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerReductionModeCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerReductionModeCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSamplerReductionModeCreateInfoValue = unsafe.Sizeof([1]C.VkSamplerReductionModeCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerReductionModeCreateInfo) Ref() *C.VkSamplerReductionModeCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.reff1cfd4e3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerReductionModeCreateInfo) Free() {
	if x != nil && x.allocsf1cfd4e3 != nil {
		x.allocsf1cfd4e3.(*cgoAllocMap).Free()
		x.reff1cfd4e3 = nil
	}
}

// NewSamplerReductionModeCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerReductionModeCreateInfoRef(ref unsafe.Pointer) *SamplerReductionModeCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SamplerReductionModeCreateInfo)
	obj.reff1cfd4e3 = (*C.VkSamplerReductionModeCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerReductionModeCreateInfo) PassRef() (*C.VkSamplerReductionModeCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff1cfd4e3 != nil {
		return x.reff1cfd4e3, nil
	}
	memf1cfd4e3 := allocSamplerReductionModeCreateInfoMemory(1)
	reff1cfd4e3 := (*C.VkSamplerReductionModeCreateInfoEXT)(memf1cfd4e3)
	allocsf1cfd4e3 := new(cgoAllocMap)
	allocsf1cfd4e3.Add(memf1cfd4e3)

	var csType_allocs *cgoAllocMap
	reff1cfd4e3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf1cfd4e3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff1cfd4e3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf1cfd4e3.Borrow(cpNext_allocs)

	var creductionMode_allocs *cgoAllocMap
	reff1cfd4e3.reductionMode, creductionMode_allocs = (C.VkSamplerReductionModeEXT)(x.ReductionMode), cgoAllocsUnknown
	allocsf1cfd4e3.Borrow(creductionMode_allocs)

	x.reff1cfd4e3 = reff1cfd4e3
	x.allocsf1cfd4e3 = allocsf1cfd4e3
	return reff1cfd4e3, allocsf1cfd4e3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerReductionModeCreateInfo) PassValue() (C.VkSamplerReductionModeCreateInfoEXT, *cgoAllocMap) {
	if x.reff1cfd4e3 != nil {
		return *x.reff1cfd4e3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerReductionModeCreateInfo) Deref() {
	if x.reff1cfd4e3 == nil {
		return
	}
	x.SType = (StructureType)(x.reff1cfd4e3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff1cfd4e3.pNext))
	x.ReductionMode = (SamplerReductionMode)(x.reff1cfd4e3.reductionMode)
}

// allocPhysicalDeviceSamplerFilterMinmaxPropertiesMemory allocates memory for type C.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSamplerFilterMinmaxPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSamplerFilterMinmaxPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceSamplerFilterMinmaxPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSamplerFilterMinmaxProperties) Ref() *C.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refcc32d100
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSamplerFilterMinmaxProperties) Free() {
	if x != nil && x.allocscc32d100 != nil {
		x.allocscc32d100.(*cgoAllocMap).Free()
		x.refcc32d100 = nil
	}
}

// NewPhysicalDeviceSamplerFilterMinmaxPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSamplerFilterMinmaxPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceSamplerFilterMinmaxProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSamplerFilterMinmaxProperties)
	obj.refcc32d100 = (*C.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSamplerFilterMinmaxProperties) PassRef() (*C.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcc32d100 != nil {
		return x.refcc32d100, nil
	}
	memcc32d100 := allocPhysicalDeviceSamplerFilterMinmaxPropertiesMemory(1)
	refcc32d100 := (*C.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT)(memcc32d100)
	allocscc32d100 := new(cgoAllocMap)
	allocscc32d100.Add(memcc32d100)

	var csType_allocs *cgoAllocMap
	refcc32d100.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscc32d100.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcc32d100.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscc32d100.Borrow(cpNext_allocs)

	var cfilterMinmaxSingleComponentFormats_allocs *cgoAllocMap
	refcc32d100.filterMinmaxSingleComponentFormats, cfilterMinmaxSingleComponentFormats_allocs = (C.VkBool32)(x.FilterMinmaxSingleComponentFormats), cgoAllocsUnknown
	allocscc32d100.Borrow(cfilterMinmaxSingleComponentFormats_allocs)

	var cfilterMinmaxImageComponentMapping_allocs *cgoAllocMap
	refcc32d100.filterMinmaxImageComponentMapping, cfilterMinmaxImageComponentMapping_allocs = (C.VkBool32)(x.FilterMinmaxImageComponentMapping), cgoAllocsUnknown
	allocscc32d100.Borrow(cfilterMinmaxImageComponentMapping_allocs)

	x.refcc32d100 = refcc32d100
	x.allocscc32d100 = allocscc32d100
	return refcc32d100, allocscc32d100

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSamplerFilterMinmaxProperties) PassValue() (C.VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT, *cgoAllocMap) {
	if x.refcc32d100 != nil {
		return *x.refcc32d100, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSamplerFilterMinmaxProperties) Deref() {
	if x.refcc32d100 == nil {
		return
	}
	x.SType = (StructureType)(x.refcc32d100.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcc32d100.pNext))
	x.FilterMinmaxSingleComponentFormats = (Bool32)(x.refcc32d100.filterMinmaxSingleComponentFormats)
	x.FilterMinmaxImageComponentMapping = (Bool32)(x.refcc32d100.filterMinmaxImageComponentMapping)
}

// allocPhysicalDeviceInlineUniformBlockFeaturesMemory allocates memory for type C.VkPhysicalDeviceInlineUniformBlockFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceInlineUniformBlockFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceInlineUniformBlockFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceInlineUniformBlockFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceInlineUniformBlockFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceInlineUniformBlockFeatures) Ref() *C.VkPhysicalDeviceInlineUniformBlockFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref5054bc6c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceInlineUniformBlockFeatures) Free() {
	if x != nil && x.allocs5054bc6c != nil {
		x.allocs5054bc6c.(*cgoAllocMap).Free()
		x.ref5054bc6c = nil
	}
}

// NewPhysicalDeviceInlineUniformBlockFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceInlineUniformBlockFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceInlineUniformBlockFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceInlineUniformBlockFeatures)
	obj.ref5054bc6c = (*C.VkPhysicalDeviceInlineUniformBlockFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceInlineUniformBlockFeatures) PassRef() (*C.VkPhysicalDeviceInlineUniformBlockFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5054bc6c != nil {
		return x.ref5054bc6c, nil
	}
	mem5054bc6c := allocPhysicalDeviceInlineUniformBlockFeaturesMemory(1)
	ref5054bc6c := (*C.VkPhysicalDeviceInlineUniformBlockFeaturesEXT)(mem5054bc6c)
	allocs5054bc6c := new(cgoAllocMap)
	allocs5054bc6c.Add(mem5054bc6c)

	var csType_allocs *cgoAllocMap
	ref5054bc6c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5054bc6c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5054bc6c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5054bc6c.Borrow(cpNext_allocs)

	var cinlineUniformBlock_allocs *cgoAllocMap
	ref5054bc6c.inlineUniformBlock, cinlineUniformBlock_allocs = (C.VkBool32)(x.InlineUniformBlock), cgoAllocsUnknown
	allocs5054bc6c.Borrow(cinlineUniformBlock_allocs)

	var cdescriptorBindingInlineUniformBlockUpdateAfterBind_allocs *cgoAllocMap
	ref5054bc6c.descriptorBindingInlineUniformBlockUpdateAfterBind, cdescriptorBindingInlineUniformBlockUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingInlineUniformBlockUpdateAfterBind), cgoAllocsUnknown
	allocs5054bc6c.Borrow(cdescriptorBindingInlineUniformBlockUpdateAfterBind_allocs)

	x.ref5054bc6c = ref5054bc6c
	x.allocs5054bc6c = allocs5054bc6c
	return ref5054bc6c, allocs5054bc6c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceInlineUniformBlockFeatures) PassValue() (C.VkPhysicalDeviceInlineUniformBlockFeaturesEXT, *cgoAllocMap) {
	if x.ref5054bc6c != nil {
		return *x.ref5054bc6c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceInlineUniformBlockFeatures) Deref() {
	if x.ref5054bc6c == nil {
		return
	}
	x.SType = (StructureType)(x.ref5054bc6c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5054bc6c.pNext))
	x.InlineUniformBlock = (Bool32)(x.ref5054bc6c.inlineUniformBlock)
	x.DescriptorBindingInlineUniformBlockUpdateAfterBind = (Bool32)(x.ref5054bc6c.descriptorBindingInlineUniformBlockUpdateAfterBind)
}

// allocPhysicalDeviceInlineUniformBlockPropertiesMemory allocates memory for type C.VkPhysicalDeviceInlineUniformBlockPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceInlineUniformBlockPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceInlineUniformBlockPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceInlineUniformBlockPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceInlineUniformBlockPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceInlineUniformBlockProperties) Ref() *C.VkPhysicalDeviceInlineUniformBlockPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref7ef1794
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceInlineUniformBlockProperties) Free() {
	if x != nil && x.allocs7ef1794 != nil {
		x.allocs7ef1794.(*cgoAllocMap).Free()
		x.ref7ef1794 = nil
	}
}

// NewPhysicalDeviceInlineUniformBlockPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceInlineUniformBlockPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceInlineUniformBlockProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceInlineUniformBlockProperties)
	obj.ref7ef1794 = (*C.VkPhysicalDeviceInlineUniformBlockPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceInlineUniformBlockProperties) PassRef() (*C.VkPhysicalDeviceInlineUniformBlockPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7ef1794 != nil {
		return x.ref7ef1794, nil
	}
	mem7ef1794 := allocPhysicalDeviceInlineUniformBlockPropertiesMemory(1)
	ref7ef1794 := (*C.VkPhysicalDeviceInlineUniformBlockPropertiesEXT)(mem7ef1794)
	allocs7ef1794 := new(cgoAllocMap)
	allocs7ef1794.Add(mem7ef1794)

	var csType_allocs *cgoAllocMap
	ref7ef1794.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7ef1794.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7ef1794.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7ef1794.Borrow(cpNext_allocs)

	var cmaxInlineUniformBlockSize_allocs *cgoAllocMap
	ref7ef1794.maxInlineUniformBlockSize, cmaxInlineUniformBlockSize_allocs = (C.uint32_t)(x.MaxInlineUniformBlockSize), cgoAllocsUnknown
	allocs7ef1794.Borrow(cmaxInlineUniformBlockSize_allocs)

	var cmaxPerStageDescriptorInlineUniformBlocks_allocs *cgoAllocMap
	ref7ef1794.maxPerStageDescriptorInlineUniformBlocks, cmaxPerStageDescriptorInlineUniformBlocks_allocs = (C.uint32_t)(x.MaxPerStageDescriptorInlineUniformBlocks), cgoAllocsUnknown
	allocs7ef1794.Borrow(cmaxPerStageDescriptorInlineUniformBlocks_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_allocs *cgoAllocMap
	ref7ef1794.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks, cmaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks), cgoAllocsUnknown
	allocs7ef1794.Borrow(cmaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_allocs)

	var cmaxDescriptorSetInlineUniformBlocks_allocs *cgoAllocMap
	ref7ef1794.maxDescriptorSetInlineUniformBlocks, cmaxDescriptorSetInlineUniformBlocks_allocs = (C.uint32_t)(x.MaxDescriptorSetInlineUniformBlocks), cgoAllocsUnknown
	allocs7ef1794.Borrow(cmaxDescriptorSetInlineUniformBlocks_allocs)

	var cmaxDescriptorSetUpdateAfterBindInlineUniformBlocks_allocs *cgoAllocMap
	ref7ef1794.maxDescriptorSetUpdateAfterBindInlineUniformBlocks, cmaxDescriptorSetUpdateAfterBindInlineUniformBlocks_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindInlineUniformBlocks), cgoAllocsUnknown
	allocs7ef1794.Borrow(cmaxDescriptorSetUpdateAfterBindInlineUniformBlocks_allocs)

	x.ref7ef1794 = ref7ef1794
	x.allocs7ef1794 = allocs7ef1794
	return ref7ef1794, allocs7ef1794

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceInlineUniformBlockProperties) PassValue() (C.VkPhysicalDeviceInlineUniformBlockPropertiesEXT, *cgoAllocMap) {
	if x.ref7ef1794 != nil {
		return *x.ref7ef1794, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceInlineUniformBlockProperties) Deref() {
	if x.ref7ef1794 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7ef1794.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7ef1794.pNext))
	x.MaxInlineUniformBlockSize = (uint32)(x.ref7ef1794.maxInlineUniformBlockSize)
	x.MaxPerStageDescriptorInlineUniformBlocks = (uint32)(x.ref7ef1794.maxPerStageDescriptorInlineUniformBlocks)
	x.MaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = (uint32)(x.ref7ef1794.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks)
	x.MaxDescriptorSetInlineUniformBlocks = (uint32)(x.ref7ef1794.maxDescriptorSetInlineUniformBlocks)
	x.MaxDescriptorSetUpdateAfterBindInlineUniformBlocks = (uint32)(x.ref7ef1794.maxDescriptorSetUpdateAfterBindInlineUniformBlocks)
}

// allocWriteDescriptorSetInlineUniformBlockMemory allocates memory for type C.VkWriteDescriptorSetInlineUniformBlockEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWriteDescriptorSetInlineUniformBlockMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWriteDescriptorSetInlineUniformBlockValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfWriteDescriptorSetInlineUniformBlockValue = unsafe.Sizeof([1]C.VkWriteDescriptorSetInlineUniformBlockEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *WriteDescriptorSetInlineUniformBlock) Ref() *C.VkWriteDescriptorSetInlineUniformBlockEXT {
	if x == nil {
		return nil
	}
	return x.ref18d00656
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *WriteDescriptorSetInlineUniformBlock) Free() {
	if x != nil && x.allocs18d00656 != nil {
		x.allocs18d00656.(*cgoAllocMap).Free()
		x.ref18d00656 = nil
	}
}

// NewWriteDescriptorSetInlineUniformBlockRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWriteDescriptorSetInlineUniformBlockRef(ref unsafe.Pointer) *WriteDescriptorSetInlineUniformBlock {
	if ref == nil {
		return nil
	}
	obj := new(WriteDescriptorSetInlineUniformBlock)
	obj.ref18d00656 = (*C.VkWriteDescriptorSetInlineUniformBlockEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *WriteDescriptorSetInlineUniformBlock) PassRef() (*C.VkWriteDescriptorSetInlineUniformBlockEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref18d00656 != nil {
		return x.ref18d00656, nil
	}
	mem18d00656 := allocWriteDescriptorSetInlineUniformBlockMemory(1)
	ref18d00656 := (*C.VkWriteDescriptorSetInlineUniformBlockEXT)(mem18d00656)
	allocs18d00656 := new(cgoAllocMap)
	allocs18d00656.Add(mem18d00656)

	var csType_allocs *cgoAllocMap
	ref18d00656.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs18d00656.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref18d00656.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs18d00656.Borrow(cpNext_allocs)

	var cdataSize_allocs *cgoAllocMap
	ref18d00656.dataSize, cdataSize_allocs = (C.uint32_t)(x.DataSize), cgoAllocsUnknown
	allocs18d00656.Borrow(cdataSize_allocs)

	var cpData_allocs *cgoAllocMap
	ref18d00656.pData, cpData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PData)), cgoAllocsUnknown
	allocs18d00656.Borrow(cpData_allocs)

	x.ref18d00656 = ref18d00656
	x.allocs18d00656 = allocs18d00656
	return ref18d00656, allocs18d00656

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x WriteDescriptorSetInlineUniformBlock) PassValue() (C.VkWriteDescriptorSetInlineUniformBlockEXT, *cgoAllocMap) {
	if x.ref18d00656 != nil {
		return *x.ref18d00656, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *WriteDescriptorSetInlineUniformBlock) Deref() {
	if x.ref18d00656 == nil {
		return
	}
	x.SType = (StructureType)(x.ref18d00656.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref18d00656.pNext))
	x.DataSize = (uint32)(x.ref18d00656.dataSize)
	x.PData = (unsafe.Pointer)(unsafe.Pointer(x.ref18d00656.pData))
}

// allocDescriptorPoolInlineUniformBlockCreateInfoMemory allocates memory for type C.VkDescriptorPoolInlineUniformBlockCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorPoolInlineUniformBlockCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorPoolInlineUniformBlockCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorPoolInlineUniformBlockCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorPoolInlineUniformBlockCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorPoolInlineUniformBlockCreateInfo) Ref() *C.VkDescriptorPoolInlineUniformBlockCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refbc7edaa3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorPoolInlineUniformBlockCreateInfo) Free() {
	if x != nil && x.allocsbc7edaa3 != nil {
		x.allocsbc7edaa3.(*cgoAllocMap).Free()
		x.refbc7edaa3 = nil
	}
}

// NewDescriptorPoolInlineUniformBlockCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorPoolInlineUniformBlockCreateInfoRef(ref unsafe.Pointer) *DescriptorPoolInlineUniformBlockCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorPoolInlineUniformBlockCreateInfo)
	obj.refbc7edaa3 = (*C.VkDescriptorPoolInlineUniformBlockCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorPoolInlineUniformBlockCreateInfo) PassRef() (*C.VkDescriptorPoolInlineUniformBlockCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbc7edaa3 != nil {
		return x.refbc7edaa3, nil
	}
	membc7edaa3 := allocDescriptorPoolInlineUniformBlockCreateInfoMemory(1)
	refbc7edaa3 := (*C.VkDescriptorPoolInlineUniformBlockCreateInfoEXT)(membc7edaa3)
	allocsbc7edaa3 := new(cgoAllocMap)
	allocsbc7edaa3.Add(membc7edaa3)

	var csType_allocs *cgoAllocMap
	refbc7edaa3.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbc7edaa3.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbc7edaa3.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbc7edaa3.Borrow(cpNext_allocs)

	var cmaxInlineUniformBlockBindings_allocs *cgoAllocMap
	refbc7edaa3.maxInlineUniformBlockBindings, cmaxInlineUniformBlockBindings_allocs = (C.uint32_t)(x.MaxInlineUniformBlockBindings), cgoAllocsUnknown
	allocsbc7edaa3.Borrow(cmaxInlineUniformBlockBindings_allocs)

	x.refbc7edaa3 = refbc7edaa3
	x.allocsbc7edaa3 = allocsbc7edaa3
	return refbc7edaa3, allocsbc7edaa3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorPoolInlineUniformBlockCreateInfo) PassValue() (C.VkDescriptorPoolInlineUniformBlockCreateInfoEXT, *cgoAllocMap) {
	if x.refbc7edaa3 != nil {
		return *x.refbc7edaa3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorPoolInlineUniformBlockCreateInfo) Deref() {
	if x.refbc7edaa3 == nil {
		return
	}
	x.SType = (StructureType)(x.refbc7edaa3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbc7edaa3.pNext))
	x.MaxInlineUniformBlockBindings = (uint32)(x.refbc7edaa3.maxInlineUniformBlockBindings)
}

// allocSampleLocationMemory allocates memory for type C.VkSampleLocationEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSampleLocationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSampleLocationValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSampleLocationValue = unsafe.Sizeof([1]C.VkSampleLocationEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SampleLocation) Ref() *C.VkSampleLocationEXT {
	if x == nil {
		return nil
	}
	return x.refe7a2e761
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SampleLocation) Free() {
	if x != nil && x.allocse7a2e761 != nil {
		x.allocse7a2e761.(*cgoAllocMap).Free()
		x.refe7a2e761 = nil
	}
}

// NewSampleLocationRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSampleLocationRef(ref unsafe.Pointer) *SampleLocation {
	if ref == nil {
		return nil
	}
	obj := new(SampleLocation)
	obj.refe7a2e761 = (*C.VkSampleLocationEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SampleLocation) PassRef() (*C.VkSampleLocationEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe7a2e761 != nil {
		return x.refe7a2e761, nil
	}
	meme7a2e761 := allocSampleLocationMemory(1)
	refe7a2e761 := (*C.VkSampleLocationEXT)(meme7a2e761)
	allocse7a2e761 := new(cgoAllocMap)
	allocse7a2e761.Add(meme7a2e761)

	var cx_allocs *cgoAllocMap
	refe7a2e761.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocse7a2e761.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refe7a2e761.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocse7a2e761.Borrow(cy_allocs)

	x.refe7a2e761 = refe7a2e761
	x.allocse7a2e761 = allocse7a2e761
	return refe7a2e761, allocse7a2e761

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SampleLocation) PassValue() (C.VkSampleLocationEXT, *cgoAllocMap) {
	if x.refe7a2e761 != nil {
		return *x.refe7a2e761, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SampleLocation) Deref() {
	if x.refe7a2e761 == nil {
		return
	}
	x.X = (float32)(x.refe7a2e761.x)
	x.Y = (float32)(x.refe7a2e761.y)
}

// allocSampleLocationsInfoMemory allocates memory for type C.VkSampleLocationsInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSampleLocationsInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSampleLocationsInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSampleLocationsInfoValue = unsafe.Sizeof([1]C.VkSampleLocationsInfoEXT{})

// unpackSSampleLocation transforms a sliced Go data structure into plain C format.
func unpackSSampleLocation(x []SampleLocation) (unpacked *C.VkSampleLocationEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSampleLocationEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSampleLocationMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSampleLocationEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSampleLocationEXT)(h.Data)
	return
}

// packSSampleLocation reads sliced Go data structure out from plain C format.
func packSSampleLocation(v []SampleLocation, ptr0 *C.VkSampleLocationEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSampleLocationValue]C.VkSampleLocationEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSampleLocationRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SampleLocationsInfo) Ref() *C.VkSampleLocationsInfoEXT {
	if x == nil {
		return nil
	}
	return x.refd8f3bd2d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SampleLocationsInfo) Free() {
	if x != nil && x.allocsd8f3bd2d != nil {
		x.allocsd8f3bd2d.(*cgoAllocMap).Free()
		x.refd8f3bd2d = nil
	}
}

// NewSampleLocationsInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSampleLocationsInfoRef(ref unsafe.Pointer) *SampleLocationsInfo {
	if ref == nil {
		return nil
	}
	obj := new(SampleLocationsInfo)
	obj.refd8f3bd2d = (*C.VkSampleLocationsInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SampleLocationsInfo) PassRef() (*C.VkSampleLocationsInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd8f3bd2d != nil {
		return x.refd8f3bd2d, nil
	}
	memd8f3bd2d := allocSampleLocationsInfoMemory(1)
	refd8f3bd2d := (*C.VkSampleLocationsInfoEXT)(memd8f3bd2d)
	allocsd8f3bd2d := new(cgoAllocMap)
	allocsd8f3bd2d.Add(memd8f3bd2d)

	var csType_allocs *cgoAllocMap
	refd8f3bd2d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd8f3bd2d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd8f3bd2d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd8f3bd2d.Borrow(cpNext_allocs)

	var csampleLocationsPerPixel_allocs *cgoAllocMap
	refd8f3bd2d.sampleLocationsPerPixel, csampleLocationsPerPixel_allocs = (C.VkSampleCountFlagBits)(x.SampleLocationsPerPixel), cgoAllocsUnknown
	allocsd8f3bd2d.Borrow(csampleLocationsPerPixel_allocs)

	var csampleLocationGridSize_allocs *cgoAllocMap
	refd8f3bd2d.sampleLocationGridSize, csampleLocationGridSize_allocs = x.SampleLocationGridSize.PassValue()
	allocsd8f3bd2d.Borrow(csampleLocationGridSize_allocs)

	var csampleLocationsCount_allocs *cgoAllocMap
	refd8f3bd2d.sampleLocationsCount, csampleLocationsCount_allocs = (C.uint32_t)(x.SampleLocationsCount), cgoAllocsUnknown
	allocsd8f3bd2d.Borrow(csampleLocationsCount_allocs)

	var cpSampleLocations_allocs *cgoAllocMap
	refd8f3bd2d.pSampleLocations, cpSampleLocations_allocs = unpackSSampleLocation(x.PSampleLocations)
	allocsd8f3bd2d.Borrow(cpSampleLocations_allocs)

	x.refd8f3bd2d = refd8f3bd2d
	x.allocsd8f3bd2d = allocsd8f3bd2d
	return refd8f3bd2d, allocsd8f3bd2d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SampleLocationsInfo) PassValue() (C.VkSampleLocationsInfoEXT, *cgoAllocMap) {
	if x.refd8f3bd2d != nil {
		return *x.refd8f3bd2d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SampleLocationsInfo) Deref() {
	if x.refd8f3bd2d == nil {
		return
	}
	x.SType = (StructureType)(x.refd8f3bd2d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd8f3bd2d.pNext))
	x.SampleLocationsPerPixel = (SampleCountFlagBits)(x.refd8f3bd2d.sampleLocationsPerPixel)
	x.SampleLocationGridSize = *NewExtent2DRef(unsafe.Pointer(&x.refd8f3bd2d.sampleLocationGridSize))
	x.SampleLocationsCount = (uint32)(x.refd8f3bd2d.sampleLocationsCount)
	packSSampleLocation(x.PSampleLocations, x.refd8f3bd2d.pSampleLocations)
}

// allocAttachmentSampleLocationsMemory allocates memory for type C.VkAttachmentSampleLocationsEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentSampleLocationsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentSampleLocationsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAttachmentSampleLocationsValue = unsafe.Sizeof([1]C.VkAttachmentSampleLocationsEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentSampleLocations) Ref() *C.VkAttachmentSampleLocationsEXT {
	if x == nil {
		return nil
	}
	return x.ref6a3dd41e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentSampleLocations) Free() {
	if x != nil && x.allocs6a3dd41e != nil {
		x.allocs6a3dd41e.(*cgoAllocMap).Free()
		x.ref6a3dd41e = nil
	}
}

// NewAttachmentSampleLocationsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentSampleLocationsRef(ref unsafe.Pointer) *AttachmentSampleLocations {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentSampleLocations)
	obj.ref6a3dd41e = (*C.VkAttachmentSampleLocationsEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentSampleLocations) PassRef() (*C.VkAttachmentSampleLocationsEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6a3dd41e != nil {
		return x.ref6a3dd41e, nil
	}
	mem6a3dd41e := allocAttachmentSampleLocationsMemory(1)
	ref6a3dd41e := (*C.VkAttachmentSampleLocationsEXT)(mem6a3dd41e)
	allocs6a3dd41e := new(cgoAllocMap)
	allocs6a3dd41e.Add(mem6a3dd41e)

	var cattachmentIndex_allocs *cgoAllocMap
	ref6a3dd41e.attachmentIndex, cattachmentIndex_allocs = (C.uint32_t)(x.AttachmentIndex), cgoAllocsUnknown
	allocs6a3dd41e.Borrow(cattachmentIndex_allocs)

	var csampleLocationsInfo_allocs *cgoAllocMap
	ref6a3dd41e.sampleLocationsInfo, csampleLocationsInfo_allocs = x.SampleLocationsInfo.PassValue()
	allocs6a3dd41e.Borrow(csampleLocationsInfo_allocs)

	x.ref6a3dd41e = ref6a3dd41e
	x.allocs6a3dd41e = allocs6a3dd41e
	return ref6a3dd41e, allocs6a3dd41e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentSampleLocations) PassValue() (C.VkAttachmentSampleLocationsEXT, *cgoAllocMap) {
	if x.ref6a3dd41e != nil {
		return *x.ref6a3dd41e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentSampleLocations) Deref() {
	if x.ref6a3dd41e == nil {
		return
	}
	x.AttachmentIndex = (uint32)(x.ref6a3dd41e.attachmentIndex)
	x.SampleLocationsInfo = *NewSampleLocationsInfoRef(unsafe.Pointer(&x.ref6a3dd41e.sampleLocationsInfo))
}

// allocSubpassSampleLocationsMemory allocates memory for type C.VkSubpassSampleLocationsEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassSampleLocationsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassSampleLocationsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubpassSampleLocationsValue = unsafe.Sizeof([1]C.VkSubpassSampleLocationsEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassSampleLocations) Ref() *C.VkSubpassSampleLocationsEXT {
	if x == nil {
		return nil
	}
	return x.ref1f612812
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassSampleLocations) Free() {
	if x != nil && x.allocs1f612812 != nil {
		x.allocs1f612812.(*cgoAllocMap).Free()
		x.ref1f612812 = nil
	}
}

// NewSubpassSampleLocationsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassSampleLocationsRef(ref unsafe.Pointer) *SubpassSampleLocations {
	if ref == nil {
		return nil
	}
	obj := new(SubpassSampleLocations)
	obj.ref1f612812 = (*C.VkSubpassSampleLocationsEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassSampleLocations) PassRef() (*C.VkSubpassSampleLocationsEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1f612812 != nil {
		return x.ref1f612812, nil
	}
	mem1f612812 := allocSubpassSampleLocationsMemory(1)
	ref1f612812 := (*C.VkSubpassSampleLocationsEXT)(mem1f612812)
	allocs1f612812 := new(cgoAllocMap)
	allocs1f612812.Add(mem1f612812)

	var csubpassIndex_allocs *cgoAllocMap
	ref1f612812.subpassIndex, csubpassIndex_allocs = (C.uint32_t)(x.SubpassIndex), cgoAllocsUnknown
	allocs1f612812.Borrow(csubpassIndex_allocs)

	var csampleLocationsInfo_allocs *cgoAllocMap
	ref1f612812.sampleLocationsInfo, csampleLocationsInfo_allocs = x.SampleLocationsInfo.PassValue()
	allocs1f612812.Borrow(csampleLocationsInfo_allocs)

	x.ref1f612812 = ref1f612812
	x.allocs1f612812 = allocs1f612812
	return ref1f612812, allocs1f612812

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassSampleLocations) PassValue() (C.VkSubpassSampleLocationsEXT, *cgoAllocMap) {
	if x.ref1f612812 != nil {
		return *x.ref1f612812, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassSampleLocations) Deref() {
	if x.ref1f612812 == nil {
		return
	}
	x.SubpassIndex = (uint32)(x.ref1f612812.subpassIndex)
	x.SampleLocationsInfo = *NewSampleLocationsInfoRef(unsafe.Pointer(&x.ref1f612812.sampleLocationsInfo))
}

// allocRenderPassSampleLocationsBeginInfoMemory allocates memory for type C.VkRenderPassSampleLocationsBeginInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassSampleLocationsBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassSampleLocationsBeginInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderPassSampleLocationsBeginInfoValue = unsafe.Sizeof([1]C.VkRenderPassSampleLocationsBeginInfoEXT{})

// unpackSAttachmentSampleLocations transforms a sliced Go data structure into plain C format.
func unpackSAttachmentSampleLocations(x []AttachmentSampleLocations) (unpacked *C.VkAttachmentSampleLocationsEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkAttachmentSampleLocationsEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAttachmentSampleLocationsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkAttachmentSampleLocationsEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkAttachmentSampleLocationsEXT)(h.Data)
	return
}

// unpackSSubpassSampleLocations transforms a sliced Go data structure into plain C format.
func unpackSSubpassSampleLocations(x []SubpassSampleLocations) (unpacked *C.VkSubpassSampleLocationsEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubpassSampleLocationsEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassSampleLocationsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassSampleLocationsEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassSampleLocationsEXT)(h.Data)
	return
}

// packSAttachmentSampleLocations reads sliced Go data structure out from plain C format.
func packSAttachmentSampleLocations(v []AttachmentSampleLocations, ptr0 *C.VkAttachmentSampleLocationsEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAttachmentSampleLocationsValue]C.VkAttachmentSampleLocationsEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAttachmentSampleLocationsRef(unsafe.Pointer(&ptr1))
	}
}

// packSSubpassSampleLocations reads sliced Go data structure out from plain C format.
func packSSubpassSampleLocations(v []SubpassSampleLocations, ptr0 *C.VkSubpassSampleLocationsEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassSampleLocationsValue]C.VkSubpassSampleLocationsEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassSampleLocationsRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassSampleLocationsBeginInfo) Ref() *C.VkRenderPassSampleLocationsBeginInfoEXT {
	if x == nil {
		return nil
	}
	return x.refb61b51d4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassSampleLocationsBeginInfo) Free() {
	if x != nil && x.allocsb61b51d4 != nil {
		x.allocsb61b51d4.(*cgoAllocMap).Free()
		x.refb61b51d4 = nil
	}
}

// NewRenderPassSampleLocationsBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassSampleLocationsBeginInfoRef(ref unsafe.Pointer) *RenderPassSampleLocationsBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassSampleLocationsBeginInfo)
	obj.refb61b51d4 = (*C.VkRenderPassSampleLocationsBeginInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassSampleLocationsBeginInfo) PassRef() (*C.VkRenderPassSampleLocationsBeginInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb61b51d4 != nil {
		return x.refb61b51d4, nil
	}
	memb61b51d4 := allocRenderPassSampleLocationsBeginInfoMemory(1)
	refb61b51d4 := (*C.VkRenderPassSampleLocationsBeginInfoEXT)(memb61b51d4)
	allocsb61b51d4 := new(cgoAllocMap)
	allocsb61b51d4.Add(memb61b51d4)

	var csType_allocs *cgoAllocMap
	refb61b51d4.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb61b51d4.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb61b51d4.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb61b51d4.Borrow(cpNext_allocs)

	var cattachmentInitialSampleLocationsCount_allocs *cgoAllocMap
	refb61b51d4.attachmentInitialSampleLocationsCount, cattachmentInitialSampleLocationsCount_allocs = (C.uint32_t)(x.AttachmentInitialSampleLocationsCount), cgoAllocsUnknown
	allocsb61b51d4.Borrow(cattachmentInitialSampleLocationsCount_allocs)

	var cpAttachmentInitialSampleLocations_allocs *cgoAllocMap
	refb61b51d4.pAttachmentInitialSampleLocations, cpAttachmentInitialSampleLocations_allocs = unpackSAttachmentSampleLocations(x.PAttachmentInitialSampleLocations)
	allocsb61b51d4.Borrow(cpAttachmentInitialSampleLocations_allocs)

	var cpostSubpassSampleLocationsCount_allocs *cgoAllocMap
	refb61b51d4.postSubpassSampleLocationsCount, cpostSubpassSampleLocationsCount_allocs = (C.uint32_t)(x.PostSubpassSampleLocationsCount), cgoAllocsUnknown
	allocsb61b51d4.Borrow(cpostSubpassSampleLocationsCount_allocs)

	var cpPostSubpassSampleLocations_allocs *cgoAllocMap
	refb61b51d4.pPostSubpassSampleLocations, cpPostSubpassSampleLocations_allocs = unpackSSubpassSampleLocations(x.PPostSubpassSampleLocations)
	allocsb61b51d4.Borrow(cpPostSubpassSampleLocations_allocs)

	x.refb61b51d4 = refb61b51d4
	x.allocsb61b51d4 = allocsb61b51d4
	return refb61b51d4, allocsb61b51d4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassSampleLocationsBeginInfo) PassValue() (C.VkRenderPassSampleLocationsBeginInfoEXT, *cgoAllocMap) {
	if x.refb61b51d4 != nil {
		return *x.refb61b51d4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassSampleLocationsBeginInfo) Deref() {
	if x.refb61b51d4 == nil {
		return
	}
	x.SType = (StructureType)(x.refb61b51d4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb61b51d4.pNext))
	x.AttachmentInitialSampleLocationsCount = (uint32)(x.refb61b51d4.attachmentInitialSampleLocationsCount)
	packSAttachmentSampleLocations(x.PAttachmentInitialSampleLocations, x.refb61b51d4.pAttachmentInitialSampleLocations)
	x.PostSubpassSampleLocationsCount = (uint32)(x.refb61b51d4.postSubpassSampleLocationsCount)
	packSSubpassSampleLocations(x.PPostSubpassSampleLocations, x.refb61b51d4.pPostSubpassSampleLocations)
}

// allocPipelineSampleLocationsStateCreateInfoMemory allocates memory for type C.VkPipelineSampleLocationsStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineSampleLocationsStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineSampleLocationsStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineSampleLocationsStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineSampleLocationsStateCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineSampleLocationsStateCreateInfo) Ref() *C.VkPipelineSampleLocationsStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref93a2968f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineSampleLocationsStateCreateInfo) Free() {
	if x != nil && x.allocs93a2968f != nil {
		x.allocs93a2968f.(*cgoAllocMap).Free()
		x.ref93a2968f = nil
	}
}

// NewPipelineSampleLocationsStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineSampleLocationsStateCreateInfoRef(ref unsafe.Pointer) *PipelineSampleLocationsStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineSampleLocationsStateCreateInfo)
	obj.ref93a2968f = (*C.VkPipelineSampleLocationsStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineSampleLocationsStateCreateInfo) PassRef() (*C.VkPipelineSampleLocationsStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref93a2968f != nil {
		return x.ref93a2968f, nil
	}
	mem93a2968f := allocPipelineSampleLocationsStateCreateInfoMemory(1)
	ref93a2968f := (*C.VkPipelineSampleLocationsStateCreateInfoEXT)(mem93a2968f)
	allocs93a2968f := new(cgoAllocMap)
	allocs93a2968f.Add(mem93a2968f)

	var csType_allocs *cgoAllocMap
	ref93a2968f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs93a2968f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref93a2968f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs93a2968f.Borrow(cpNext_allocs)

	var csampleLocationsEnable_allocs *cgoAllocMap
	ref93a2968f.sampleLocationsEnable, csampleLocationsEnable_allocs = (C.VkBool32)(x.SampleLocationsEnable), cgoAllocsUnknown
	allocs93a2968f.Borrow(csampleLocationsEnable_allocs)

	var csampleLocationsInfo_allocs *cgoAllocMap
	ref93a2968f.sampleLocationsInfo, csampleLocationsInfo_allocs = x.SampleLocationsInfo.PassValue()
	allocs93a2968f.Borrow(csampleLocationsInfo_allocs)

	x.ref93a2968f = ref93a2968f
	x.allocs93a2968f = allocs93a2968f
	return ref93a2968f, allocs93a2968f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineSampleLocationsStateCreateInfo) PassValue() (C.VkPipelineSampleLocationsStateCreateInfoEXT, *cgoAllocMap) {
	if x.ref93a2968f != nil {
		return *x.ref93a2968f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineSampleLocationsStateCreateInfo) Deref() {
	if x.ref93a2968f == nil {
		return
	}
	x.SType = (StructureType)(x.ref93a2968f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref93a2968f.pNext))
	x.SampleLocationsEnable = (Bool32)(x.ref93a2968f.sampleLocationsEnable)
	x.SampleLocationsInfo = *NewSampleLocationsInfoRef(unsafe.Pointer(&x.ref93a2968f.sampleLocationsInfo))
}

// allocPhysicalDeviceSampleLocationsPropertiesMemory allocates memory for type C.VkPhysicalDeviceSampleLocationsPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSampleLocationsPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSampleLocationsPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceSampleLocationsPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceSampleLocationsPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSampleLocationsProperties) Ref() *C.VkPhysicalDeviceSampleLocationsPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refaf801323
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSampleLocationsProperties) Free() {
	if x != nil && x.allocsaf801323 != nil {
		x.allocsaf801323.(*cgoAllocMap).Free()
		x.refaf801323 = nil
	}
}

// NewPhysicalDeviceSampleLocationsPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSampleLocationsPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceSampleLocationsProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSampleLocationsProperties)
	obj.refaf801323 = (*C.VkPhysicalDeviceSampleLocationsPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSampleLocationsProperties) PassRef() (*C.VkPhysicalDeviceSampleLocationsPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaf801323 != nil {
		return x.refaf801323, nil
	}
	memaf801323 := allocPhysicalDeviceSampleLocationsPropertiesMemory(1)
	refaf801323 := (*C.VkPhysicalDeviceSampleLocationsPropertiesEXT)(memaf801323)
	allocsaf801323 := new(cgoAllocMap)
	allocsaf801323.Add(memaf801323)

	var csType_allocs *cgoAllocMap
	refaf801323.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsaf801323.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refaf801323.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsaf801323.Borrow(cpNext_allocs)

	var csampleLocationSampleCounts_allocs *cgoAllocMap
	refaf801323.sampleLocationSampleCounts, csampleLocationSampleCounts_allocs = (C.VkSampleCountFlags)(x.SampleLocationSampleCounts), cgoAllocsUnknown
	allocsaf801323.Borrow(csampleLocationSampleCounts_allocs)

	var cmaxSampleLocationGridSize_allocs *cgoAllocMap
	refaf801323.maxSampleLocationGridSize, cmaxSampleLocationGridSize_allocs = x.MaxSampleLocationGridSize.PassValue()
	allocsaf801323.Borrow(cmaxSampleLocationGridSize_allocs)

	var csampleLocationCoordinateRange_allocs *cgoAllocMap
	refaf801323.sampleLocationCoordinateRange, csampleLocationCoordinateRange_allocs = *(*[2]C.float)(unsafe.Pointer(&x.SampleLocationCoordinateRange)), cgoAllocsUnknown
	allocsaf801323.Borrow(csampleLocationCoordinateRange_allocs)

	var csampleLocationSubPixelBits_allocs *cgoAllocMap
	refaf801323.sampleLocationSubPixelBits, csampleLocationSubPixelBits_allocs = (C.uint32_t)(x.SampleLocationSubPixelBits), cgoAllocsUnknown
	allocsaf801323.Borrow(csampleLocationSubPixelBits_allocs)

	var cvariableSampleLocations_allocs *cgoAllocMap
	refaf801323.variableSampleLocations, cvariableSampleLocations_allocs = (C.VkBool32)(x.VariableSampleLocations), cgoAllocsUnknown
	allocsaf801323.Borrow(cvariableSampleLocations_allocs)

	x.refaf801323 = refaf801323
	x.allocsaf801323 = allocsaf801323
	return refaf801323, allocsaf801323

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSampleLocationsProperties) PassValue() (C.VkPhysicalDeviceSampleLocationsPropertiesEXT, *cgoAllocMap) {
	if x.refaf801323 != nil {
		return *x.refaf801323, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSampleLocationsProperties) Deref() {
	if x.refaf801323 == nil {
		return
	}
	x.SType = (StructureType)(x.refaf801323.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refaf801323.pNext))
	x.SampleLocationSampleCounts = (SampleCountFlags)(x.refaf801323.sampleLocationSampleCounts)
	x.MaxSampleLocationGridSize = *NewExtent2DRef(unsafe.Pointer(&x.refaf801323.maxSampleLocationGridSize))
	x.SampleLocationCoordinateRange = *(*[2]float32)(unsafe.Pointer(&x.refaf801323.sampleLocationCoordinateRange))
	x.SampleLocationSubPixelBits = (uint32)(x.refaf801323.sampleLocationSubPixelBits)
	x.VariableSampleLocations = (Bool32)(x.refaf801323.variableSampleLocations)
}

// allocMultisamplePropertiesMemory allocates memory for type C.VkMultisamplePropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMultisamplePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMultisamplePropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMultisamplePropertiesValue = unsafe.Sizeof([1]C.VkMultisamplePropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MultisampleProperties) Ref() *C.VkMultisamplePropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref3e47f337
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MultisampleProperties) Free() {
	if x != nil && x.allocs3e47f337 != nil {
		x.allocs3e47f337.(*cgoAllocMap).Free()
		x.ref3e47f337 = nil
	}
}

// NewMultisamplePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMultisamplePropertiesRef(ref unsafe.Pointer) *MultisampleProperties {
	if ref == nil {
		return nil
	}
	obj := new(MultisampleProperties)
	obj.ref3e47f337 = (*C.VkMultisamplePropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MultisampleProperties) PassRef() (*C.VkMultisamplePropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3e47f337 != nil {
		return x.ref3e47f337, nil
	}
	mem3e47f337 := allocMultisamplePropertiesMemory(1)
	ref3e47f337 := (*C.VkMultisamplePropertiesEXT)(mem3e47f337)
	allocs3e47f337 := new(cgoAllocMap)
	allocs3e47f337.Add(mem3e47f337)

	var csType_allocs *cgoAllocMap
	ref3e47f337.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3e47f337.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3e47f337.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3e47f337.Borrow(cpNext_allocs)

	var cmaxSampleLocationGridSize_allocs *cgoAllocMap
	ref3e47f337.maxSampleLocationGridSize, cmaxSampleLocationGridSize_allocs = x.MaxSampleLocationGridSize.PassValue()
	allocs3e47f337.Borrow(cmaxSampleLocationGridSize_allocs)

	x.ref3e47f337 = ref3e47f337
	x.allocs3e47f337 = allocs3e47f337
	return ref3e47f337, allocs3e47f337

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MultisampleProperties) PassValue() (C.VkMultisamplePropertiesEXT, *cgoAllocMap) {
	if x.ref3e47f337 != nil {
		return *x.ref3e47f337, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MultisampleProperties) Deref() {
	if x.ref3e47f337 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3e47f337.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3e47f337.pNext))
	x.MaxSampleLocationGridSize = *NewExtent2DRef(unsafe.Pointer(&x.ref3e47f337.maxSampleLocationGridSize))
}

// allocPhysicalDeviceBlendOperationAdvancedFeaturesMemory allocates memory for type C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceBlendOperationAdvancedFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceBlendOperationAdvancedFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceBlendOperationAdvancedFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceBlendOperationAdvancedFeatures) Ref() *C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref8514bc93
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceBlendOperationAdvancedFeatures) Free() {
	if x != nil && x.allocs8514bc93 != nil {
		x.allocs8514bc93.(*cgoAllocMap).Free()
		x.ref8514bc93 = nil
	}
}

// NewPhysicalDeviceBlendOperationAdvancedFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceBlendOperationAdvancedFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceBlendOperationAdvancedFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceBlendOperationAdvancedFeatures)
	obj.ref8514bc93 = (*C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceBlendOperationAdvancedFeatures) PassRef() (*C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8514bc93 != nil {
		return x.ref8514bc93, nil
	}
	mem8514bc93 := allocPhysicalDeviceBlendOperationAdvancedFeaturesMemory(1)
	ref8514bc93 := (*C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT)(mem8514bc93)
	allocs8514bc93 := new(cgoAllocMap)
	allocs8514bc93.Add(mem8514bc93)

	var csType_allocs *cgoAllocMap
	ref8514bc93.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8514bc93.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8514bc93.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8514bc93.Borrow(cpNext_allocs)

	var cadvancedBlendCoherentOperations_allocs *cgoAllocMap
	ref8514bc93.advancedBlendCoherentOperations, cadvancedBlendCoherentOperations_allocs = (C.VkBool32)(x.AdvancedBlendCoherentOperations), cgoAllocsUnknown
	allocs8514bc93.Borrow(cadvancedBlendCoherentOperations_allocs)

	x.ref8514bc93 = ref8514bc93
	x.allocs8514bc93 = allocs8514bc93
	return ref8514bc93, allocs8514bc93

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceBlendOperationAdvancedFeatures) PassValue() (C.VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, *cgoAllocMap) {
	if x.ref8514bc93 != nil {
		return *x.ref8514bc93, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceBlendOperationAdvancedFeatures) Deref() {
	if x.ref8514bc93 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8514bc93.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8514bc93.pNext))
	x.AdvancedBlendCoherentOperations = (Bool32)(x.ref8514bc93.advancedBlendCoherentOperations)
}

// allocPhysicalDeviceBlendOperationAdvancedPropertiesMemory allocates memory for type C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceBlendOperationAdvancedPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceBlendOperationAdvancedPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceBlendOperationAdvancedPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceBlendOperationAdvancedProperties) Ref() *C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref94cb3fa6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceBlendOperationAdvancedProperties) Free() {
	if x != nil && x.allocs94cb3fa6 != nil {
		x.allocs94cb3fa6.(*cgoAllocMap).Free()
		x.ref94cb3fa6 = nil
	}
}

// NewPhysicalDeviceBlendOperationAdvancedPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceBlendOperationAdvancedPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceBlendOperationAdvancedProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceBlendOperationAdvancedProperties)
	obj.ref94cb3fa6 = (*C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceBlendOperationAdvancedProperties) PassRef() (*C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref94cb3fa6 != nil {
		return x.ref94cb3fa6, nil
	}
	mem94cb3fa6 := allocPhysicalDeviceBlendOperationAdvancedPropertiesMemory(1)
	ref94cb3fa6 := (*C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT)(mem94cb3fa6)
	allocs94cb3fa6 := new(cgoAllocMap)
	allocs94cb3fa6.Add(mem94cb3fa6)

	var csType_allocs *cgoAllocMap
	ref94cb3fa6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref94cb3fa6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cpNext_allocs)

	var cadvancedBlendMaxColorAttachments_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendMaxColorAttachments, cadvancedBlendMaxColorAttachments_allocs = (C.uint32_t)(x.AdvancedBlendMaxColorAttachments), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendMaxColorAttachments_allocs)

	var cadvancedBlendIndependentBlend_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendIndependentBlend, cadvancedBlendIndependentBlend_allocs = (C.VkBool32)(x.AdvancedBlendIndependentBlend), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendIndependentBlend_allocs)

	var cadvancedBlendNonPremultipliedSrcColor_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendNonPremultipliedSrcColor, cadvancedBlendNonPremultipliedSrcColor_allocs = (C.VkBool32)(x.AdvancedBlendNonPremultipliedSrcColor), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendNonPremultipliedSrcColor_allocs)

	var cadvancedBlendNonPremultipliedDstColor_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendNonPremultipliedDstColor, cadvancedBlendNonPremultipliedDstColor_allocs = (C.VkBool32)(x.AdvancedBlendNonPremultipliedDstColor), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendNonPremultipliedDstColor_allocs)

	var cadvancedBlendCorrelatedOverlap_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendCorrelatedOverlap, cadvancedBlendCorrelatedOverlap_allocs = (C.VkBool32)(x.AdvancedBlendCorrelatedOverlap), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendCorrelatedOverlap_allocs)

	var cadvancedBlendAllOperations_allocs *cgoAllocMap
	ref94cb3fa6.advancedBlendAllOperations, cadvancedBlendAllOperations_allocs = (C.VkBool32)(x.AdvancedBlendAllOperations), cgoAllocsUnknown
	allocs94cb3fa6.Borrow(cadvancedBlendAllOperations_allocs)

	x.ref94cb3fa6 = ref94cb3fa6
	x.allocs94cb3fa6 = allocs94cb3fa6
	return ref94cb3fa6, allocs94cb3fa6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceBlendOperationAdvancedProperties) PassValue() (C.VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, *cgoAllocMap) {
	if x.ref94cb3fa6 != nil {
		return *x.ref94cb3fa6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceBlendOperationAdvancedProperties) Deref() {
	if x.ref94cb3fa6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref94cb3fa6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref94cb3fa6.pNext))
	x.AdvancedBlendMaxColorAttachments = (uint32)(x.ref94cb3fa6.advancedBlendMaxColorAttachments)
	x.AdvancedBlendIndependentBlend = (Bool32)(x.ref94cb3fa6.advancedBlendIndependentBlend)
	x.AdvancedBlendNonPremultipliedSrcColor = (Bool32)(x.ref94cb3fa6.advancedBlendNonPremultipliedSrcColor)
	x.AdvancedBlendNonPremultipliedDstColor = (Bool32)(x.ref94cb3fa6.advancedBlendNonPremultipliedDstColor)
	x.AdvancedBlendCorrelatedOverlap = (Bool32)(x.ref94cb3fa6.advancedBlendCorrelatedOverlap)
	x.AdvancedBlendAllOperations = (Bool32)(x.ref94cb3fa6.advancedBlendAllOperations)
}

// allocPipelineColorBlendAdvancedStateCreateInfoMemory allocates memory for type C.VkPipelineColorBlendAdvancedStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineColorBlendAdvancedStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineColorBlendAdvancedStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineColorBlendAdvancedStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineColorBlendAdvancedStateCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineColorBlendAdvancedStateCreateInfo) Ref() *C.VkPipelineColorBlendAdvancedStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refcd374989
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineColorBlendAdvancedStateCreateInfo) Free() {
	if x != nil && x.allocscd374989 != nil {
		x.allocscd374989.(*cgoAllocMap).Free()
		x.refcd374989 = nil
	}
}

// NewPipelineColorBlendAdvancedStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineColorBlendAdvancedStateCreateInfoRef(ref unsafe.Pointer) *PipelineColorBlendAdvancedStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineColorBlendAdvancedStateCreateInfo)
	obj.refcd374989 = (*C.VkPipelineColorBlendAdvancedStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineColorBlendAdvancedStateCreateInfo) PassRef() (*C.VkPipelineColorBlendAdvancedStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcd374989 != nil {
		return x.refcd374989, nil
	}
	memcd374989 := allocPipelineColorBlendAdvancedStateCreateInfoMemory(1)
	refcd374989 := (*C.VkPipelineColorBlendAdvancedStateCreateInfoEXT)(memcd374989)
	allocscd374989 := new(cgoAllocMap)
	allocscd374989.Add(memcd374989)

	var csType_allocs *cgoAllocMap
	refcd374989.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscd374989.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcd374989.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscd374989.Borrow(cpNext_allocs)

	var csrcPremultiplied_allocs *cgoAllocMap
	refcd374989.srcPremultiplied, csrcPremultiplied_allocs = (C.VkBool32)(x.SrcPremultiplied), cgoAllocsUnknown
	allocscd374989.Borrow(csrcPremultiplied_allocs)

	var cdstPremultiplied_allocs *cgoAllocMap
	refcd374989.dstPremultiplied, cdstPremultiplied_allocs = (C.VkBool32)(x.DstPremultiplied), cgoAllocsUnknown
	allocscd374989.Borrow(cdstPremultiplied_allocs)

	var cblendOverlap_allocs *cgoAllocMap
	refcd374989.blendOverlap, cblendOverlap_allocs = (C.VkBlendOverlapEXT)(x.BlendOverlap), cgoAllocsUnknown
	allocscd374989.Borrow(cblendOverlap_allocs)

	x.refcd374989 = refcd374989
	x.allocscd374989 = allocscd374989
	return refcd374989, allocscd374989

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineColorBlendAdvancedStateCreateInfo) PassValue() (C.VkPipelineColorBlendAdvancedStateCreateInfoEXT, *cgoAllocMap) {
	if x.refcd374989 != nil {
		return *x.refcd374989, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineColorBlendAdvancedStateCreateInfo) Deref() {
	if x.refcd374989 == nil {
		return
	}
	x.SType = (StructureType)(x.refcd374989.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcd374989.pNext))
	x.SrcPremultiplied = (Bool32)(x.refcd374989.srcPremultiplied)
	x.DstPremultiplied = (Bool32)(x.refcd374989.dstPremultiplied)
	x.BlendOverlap = (BlendOverlap)(x.refcd374989.blendOverlap)
}

// allocPipelineCoverageToColorStateCreateInfoNVMemory allocates memory for type C.VkPipelineCoverageToColorStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCoverageToColorStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCoverageToColorStateCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineCoverageToColorStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineCoverageToColorStateCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineCoverageToColorStateCreateInfoNV) Ref() *C.VkPipelineCoverageToColorStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refcc6b7b68
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineCoverageToColorStateCreateInfoNV) Free() {
	if x != nil && x.allocscc6b7b68 != nil {
		x.allocscc6b7b68.(*cgoAllocMap).Free()
		x.refcc6b7b68 = nil
	}
}

// NewPipelineCoverageToColorStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineCoverageToColorStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineCoverageToColorStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineCoverageToColorStateCreateInfoNV)
	obj.refcc6b7b68 = (*C.VkPipelineCoverageToColorStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineCoverageToColorStateCreateInfoNV) PassRef() (*C.VkPipelineCoverageToColorStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcc6b7b68 != nil {
		return x.refcc6b7b68, nil
	}
	memcc6b7b68 := allocPipelineCoverageToColorStateCreateInfoNVMemory(1)
	refcc6b7b68 := (*C.VkPipelineCoverageToColorStateCreateInfoNV)(memcc6b7b68)
	allocscc6b7b68 := new(cgoAllocMap)
	allocscc6b7b68.Add(memcc6b7b68)

	var csType_allocs *cgoAllocMap
	refcc6b7b68.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscc6b7b68.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcc6b7b68.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscc6b7b68.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refcc6b7b68.flags, cflags_allocs = (C.VkPipelineCoverageToColorStateCreateFlagsNV)(x.Flags), cgoAllocsUnknown
	allocscc6b7b68.Borrow(cflags_allocs)

	var ccoverageToColorEnable_allocs *cgoAllocMap
	refcc6b7b68.coverageToColorEnable, ccoverageToColorEnable_allocs = (C.VkBool32)(x.CoverageToColorEnable), cgoAllocsUnknown
	allocscc6b7b68.Borrow(ccoverageToColorEnable_allocs)

	var ccoverageToColorLocation_allocs *cgoAllocMap
	refcc6b7b68.coverageToColorLocation, ccoverageToColorLocation_allocs = (C.uint32_t)(x.CoverageToColorLocation), cgoAllocsUnknown
	allocscc6b7b68.Borrow(ccoverageToColorLocation_allocs)

	x.refcc6b7b68 = refcc6b7b68
	x.allocscc6b7b68 = allocscc6b7b68
	return refcc6b7b68, allocscc6b7b68

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineCoverageToColorStateCreateInfoNV) PassValue() (C.VkPipelineCoverageToColorStateCreateInfoNV, *cgoAllocMap) {
	if x.refcc6b7b68 != nil {
		return *x.refcc6b7b68, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineCoverageToColorStateCreateInfoNV) Deref() {
	if x.refcc6b7b68 == nil {
		return
	}
	x.SType = (StructureType)(x.refcc6b7b68.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcc6b7b68.pNext))
	x.Flags = (PipelineCoverageToColorStateCreateFlagsNV)(x.refcc6b7b68.flags)
	x.CoverageToColorEnable = (Bool32)(x.refcc6b7b68.coverageToColorEnable)
	x.CoverageToColorLocation = (uint32)(x.refcc6b7b68.coverageToColorLocation)
}

// allocPipelineCoverageModulationStateCreateInfoNVMemory allocates memory for type C.VkPipelineCoverageModulationStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCoverageModulationStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCoverageModulationStateCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineCoverageModulationStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineCoverageModulationStateCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineCoverageModulationStateCreateInfoNV) Ref() *C.VkPipelineCoverageModulationStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refa081b0ea
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineCoverageModulationStateCreateInfoNV) Free() {
	if x != nil && x.allocsa081b0ea != nil {
		x.allocsa081b0ea.(*cgoAllocMap).Free()
		x.refa081b0ea = nil
	}
}

// NewPipelineCoverageModulationStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineCoverageModulationStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineCoverageModulationStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineCoverageModulationStateCreateInfoNV)
	obj.refa081b0ea = (*C.VkPipelineCoverageModulationStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineCoverageModulationStateCreateInfoNV) PassRef() (*C.VkPipelineCoverageModulationStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa081b0ea != nil {
		return x.refa081b0ea, nil
	}
	mema081b0ea := allocPipelineCoverageModulationStateCreateInfoNVMemory(1)
	refa081b0ea := (*C.VkPipelineCoverageModulationStateCreateInfoNV)(mema081b0ea)
	allocsa081b0ea := new(cgoAllocMap)
	allocsa081b0ea.Add(mema081b0ea)

	var csType_allocs *cgoAllocMap
	refa081b0ea.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa081b0ea.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa081b0ea.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa081b0ea.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	refa081b0ea.flags, cflags_allocs = (C.VkPipelineCoverageModulationStateCreateFlagsNV)(x.Flags), cgoAllocsUnknown
	allocsa081b0ea.Borrow(cflags_allocs)

	var ccoverageModulationMode_allocs *cgoAllocMap
	refa081b0ea.coverageModulationMode, ccoverageModulationMode_allocs = (C.VkCoverageModulationModeNV)(x.CoverageModulationMode), cgoAllocsUnknown
	allocsa081b0ea.Borrow(ccoverageModulationMode_allocs)

	var ccoverageModulationTableEnable_allocs *cgoAllocMap
	refa081b0ea.coverageModulationTableEnable, ccoverageModulationTableEnable_allocs = (C.VkBool32)(x.CoverageModulationTableEnable), cgoAllocsUnknown
	allocsa081b0ea.Borrow(ccoverageModulationTableEnable_allocs)

	var ccoverageModulationTableCount_allocs *cgoAllocMap
	refa081b0ea.coverageModulationTableCount, ccoverageModulationTableCount_allocs = (C.uint32_t)(x.CoverageModulationTableCount), cgoAllocsUnknown
	allocsa081b0ea.Borrow(ccoverageModulationTableCount_allocs)

	var cpCoverageModulationTable_allocs *cgoAllocMap
	refa081b0ea.pCoverageModulationTable, cpCoverageModulationTable_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PCoverageModulationTable)).Data)), cgoAllocsUnknown
	allocsa081b0ea.Borrow(cpCoverageModulationTable_allocs)

	x.refa081b0ea = refa081b0ea
	x.allocsa081b0ea = allocsa081b0ea
	return refa081b0ea, allocsa081b0ea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineCoverageModulationStateCreateInfoNV) PassValue() (C.VkPipelineCoverageModulationStateCreateInfoNV, *cgoAllocMap) {
	if x.refa081b0ea != nil {
		return *x.refa081b0ea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineCoverageModulationStateCreateInfoNV) Deref() {
	if x.refa081b0ea == nil {
		return
	}
	x.SType = (StructureType)(x.refa081b0ea.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa081b0ea.pNext))
	x.Flags = (PipelineCoverageModulationStateCreateFlagsNV)(x.refa081b0ea.flags)
	x.CoverageModulationMode = (CoverageModulationModeNV)(x.refa081b0ea.coverageModulationMode)
	x.CoverageModulationTableEnable = (Bool32)(x.refa081b0ea.coverageModulationTableEnable)
	x.CoverageModulationTableCount = (uint32)(x.refa081b0ea.coverageModulationTableCount)
	hxf8e0dd2 := (*sliceHeader)(unsafe.Pointer(&x.PCoverageModulationTable))
	hxf8e0dd2.Data = unsafe.Pointer(x.refa081b0ea.pCoverageModulationTable)
	hxf8e0dd2.Cap = 0x7fffffff
	// hxf8e0dd2.Len = ?

}

// allocDrmFormatModifierPropertiesMemory allocates memory for type C.VkDrmFormatModifierPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrmFormatModifierPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrmFormatModifierPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDrmFormatModifierPropertiesValue = unsafe.Sizeof([1]C.VkDrmFormatModifierPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DrmFormatModifierProperties) Ref() *C.VkDrmFormatModifierPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref7dcb7f85
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DrmFormatModifierProperties) Free() {
	if x != nil && x.allocs7dcb7f85 != nil {
		x.allocs7dcb7f85.(*cgoAllocMap).Free()
		x.ref7dcb7f85 = nil
	}
}

// NewDrmFormatModifierPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDrmFormatModifierPropertiesRef(ref unsafe.Pointer) *DrmFormatModifierProperties {
	if ref == nil {
		return nil
	}
	obj := new(DrmFormatModifierProperties)
	obj.ref7dcb7f85 = (*C.VkDrmFormatModifierPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DrmFormatModifierProperties) PassRef() (*C.VkDrmFormatModifierPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7dcb7f85 != nil {
		return x.ref7dcb7f85, nil
	}
	mem7dcb7f85 := allocDrmFormatModifierPropertiesMemory(1)
	ref7dcb7f85 := (*C.VkDrmFormatModifierPropertiesEXT)(mem7dcb7f85)
	allocs7dcb7f85 := new(cgoAllocMap)
	allocs7dcb7f85.Add(mem7dcb7f85)

	var cdrmFormatModifier_allocs *cgoAllocMap
	ref7dcb7f85.drmFormatModifier, cdrmFormatModifier_allocs = (C.uint64_t)(x.DrmFormatModifier), cgoAllocsUnknown
	allocs7dcb7f85.Borrow(cdrmFormatModifier_allocs)

	var cdrmFormatModifierPlaneCount_allocs *cgoAllocMap
	ref7dcb7f85.drmFormatModifierPlaneCount, cdrmFormatModifierPlaneCount_allocs = (C.uint32_t)(x.DrmFormatModifierPlaneCount), cgoAllocsUnknown
	allocs7dcb7f85.Borrow(cdrmFormatModifierPlaneCount_allocs)

	var cdrmFormatModifierTilingFeatures_allocs *cgoAllocMap
	ref7dcb7f85.drmFormatModifierTilingFeatures, cdrmFormatModifierTilingFeatures_allocs = (C.VkFormatFeatureFlags)(x.DrmFormatModifierTilingFeatures), cgoAllocsUnknown
	allocs7dcb7f85.Borrow(cdrmFormatModifierTilingFeatures_allocs)

	x.ref7dcb7f85 = ref7dcb7f85
	x.allocs7dcb7f85 = allocs7dcb7f85
	return ref7dcb7f85, allocs7dcb7f85

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DrmFormatModifierProperties) PassValue() (C.VkDrmFormatModifierPropertiesEXT, *cgoAllocMap) {
	if x.ref7dcb7f85 != nil {
		return *x.ref7dcb7f85, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DrmFormatModifierProperties) Deref() {
	if x.ref7dcb7f85 == nil {
		return
	}
	x.DrmFormatModifier = (uint64)(x.ref7dcb7f85.drmFormatModifier)
	x.DrmFormatModifierPlaneCount = (uint32)(x.ref7dcb7f85.drmFormatModifierPlaneCount)
	x.DrmFormatModifierTilingFeatures = (FormatFeatureFlags)(x.ref7dcb7f85.drmFormatModifierTilingFeatures)
}

// allocDrmFormatModifierPropertiesListMemory allocates memory for type C.VkDrmFormatModifierPropertiesListEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrmFormatModifierPropertiesListMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrmFormatModifierPropertiesListValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDrmFormatModifierPropertiesListValue = unsafe.Sizeof([1]C.VkDrmFormatModifierPropertiesListEXT{})

// unpackSDrmFormatModifierProperties transforms a sliced Go data structure into plain C format.
func unpackSDrmFormatModifierProperties(x []DrmFormatModifierProperties) (unpacked *C.VkDrmFormatModifierPropertiesEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDrmFormatModifierPropertiesEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDrmFormatModifierPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDrmFormatModifierPropertiesEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDrmFormatModifierPropertiesEXT)(h.Data)
	return
}

// packSDrmFormatModifierProperties reads sliced Go data structure out from plain C format.
func packSDrmFormatModifierProperties(v []DrmFormatModifierProperties, ptr0 *C.VkDrmFormatModifierPropertiesEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDrmFormatModifierPropertiesValue]C.VkDrmFormatModifierPropertiesEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDrmFormatModifierPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DrmFormatModifierPropertiesList) Ref() *C.VkDrmFormatModifierPropertiesListEXT {
	if x == nil {
		return nil
	}
	return x.ref7e3ede2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DrmFormatModifierPropertiesList) Free() {
	if x != nil && x.allocs7e3ede2 != nil {
		x.allocs7e3ede2.(*cgoAllocMap).Free()
		x.ref7e3ede2 = nil
	}
}

// NewDrmFormatModifierPropertiesListRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDrmFormatModifierPropertiesListRef(ref unsafe.Pointer) *DrmFormatModifierPropertiesList {
	if ref == nil {
		return nil
	}
	obj := new(DrmFormatModifierPropertiesList)
	obj.ref7e3ede2 = (*C.VkDrmFormatModifierPropertiesListEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DrmFormatModifierPropertiesList) PassRef() (*C.VkDrmFormatModifierPropertiesListEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7e3ede2 != nil {
		return x.ref7e3ede2, nil
	}
	mem7e3ede2 := allocDrmFormatModifierPropertiesListMemory(1)
	ref7e3ede2 := (*C.VkDrmFormatModifierPropertiesListEXT)(mem7e3ede2)
	allocs7e3ede2 := new(cgoAllocMap)
	allocs7e3ede2.Add(mem7e3ede2)

	var csType_allocs *cgoAllocMap
	ref7e3ede2.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7e3ede2.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7e3ede2.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7e3ede2.Borrow(cpNext_allocs)

	var cdrmFormatModifierCount_allocs *cgoAllocMap
	ref7e3ede2.drmFormatModifierCount, cdrmFormatModifierCount_allocs = (C.uint32_t)(x.DrmFormatModifierCount), cgoAllocsUnknown
	allocs7e3ede2.Borrow(cdrmFormatModifierCount_allocs)

	var cpDrmFormatModifierProperties_allocs *cgoAllocMap
	ref7e3ede2.pDrmFormatModifierProperties, cpDrmFormatModifierProperties_allocs = unpackSDrmFormatModifierProperties(x.PDrmFormatModifierProperties)
	allocs7e3ede2.Borrow(cpDrmFormatModifierProperties_allocs)

	x.ref7e3ede2 = ref7e3ede2
	x.allocs7e3ede2 = allocs7e3ede2
	return ref7e3ede2, allocs7e3ede2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DrmFormatModifierPropertiesList) PassValue() (C.VkDrmFormatModifierPropertiesListEXT, *cgoAllocMap) {
	if x.ref7e3ede2 != nil {
		return *x.ref7e3ede2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DrmFormatModifierPropertiesList) Deref() {
	if x.ref7e3ede2 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7e3ede2.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7e3ede2.pNext))
	x.DrmFormatModifierCount = (uint32)(x.ref7e3ede2.drmFormatModifierCount)
	packSDrmFormatModifierProperties(x.PDrmFormatModifierProperties, x.ref7e3ede2.pDrmFormatModifierProperties)
}

// allocPhysicalDeviceImageDrmFormatModifierInfoMemory allocates memory for type C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceImageDrmFormatModifierInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceImageDrmFormatModifierInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceImageDrmFormatModifierInfoValue = unsafe.Sizeof([1]C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceImageDrmFormatModifierInfo) Ref() *C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
	if x == nil {
		return nil
	}
	return x.refd7abef44
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceImageDrmFormatModifierInfo) Free() {
	if x != nil && x.allocsd7abef44 != nil {
		x.allocsd7abef44.(*cgoAllocMap).Free()
		x.refd7abef44 = nil
	}
}

// NewPhysicalDeviceImageDrmFormatModifierInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceImageDrmFormatModifierInfoRef(ref unsafe.Pointer) *PhysicalDeviceImageDrmFormatModifierInfo {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceImageDrmFormatModifierInfo)
	obj.refd7abef44 = (*C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceImageDrmFormatModifierInfo) PassRef() (*C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd7abef44 != nil {
		return x.refd7abef44, nil
	}
	memd7abef44 := allocPhysicalDeviceImageDrmFormatModifierInfoMemory(1)
	refd7abef44 := (*C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT)(memd7abef44)
	allocsd7abef44 := new(cgoAllocMap)
	allocsd7abef44.Add(memd7abef44)

	var csType_allocs *cgoAllocMap
	refd7abef44.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd7abef44.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd7abef44.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd7abef44.Borrow(cpNext_allocs)

	var cdrmFormatModifier_allocs *cgoAllocMap
	refd7abef44.drmFormatModifier, cdrmFormatModifier_allocs = (C.uint64_t)(x.DrmFormatModifier), cgoAllocsUnknown
	allocsd7abef44.Borrow(cdrmFormatModifier_allocs)

	var csharingMode_allocs *cgoAllocMap
	refd7abef44.sharingMode, csharingMode_allocs = (C.VkSharingMode)(x.SharingMode), cgoAllocsUnknown
	allocsd7abef44.Borrow(csharingMode_allocs)

	var cqueueFamilyIndexCount_allocs *cgoAllocMap
	refd7abef44.queueFamilyIndexCount, cqueueFamilyIndexCount_allocs = (C.uint32_t)(x.QueueFamilyIndexCount), cgoAllocsUnknown
	allocsd7abef44.Borrow(cqueueFamilyIndexCount_allocs)

	var cpQueueFamilyIndices_allocs *cgoAllocMap
	refd7abef44.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)).Data)), cgoAllocsUnknown
	allocsd7abef44.Borrow(cpQueueFamilyIndices_allocs)

	x.refd7abef44 = refd7abef44
	x.allocsd7abef44 = allocsd7abef44
	return refd7abef44, allocsd7abef44

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceImageDrmFormatModifierInfo) PassValue() (C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT, *cgoAllocMap) {
	if x.refd7abef44 != nil {
		return *x.refd7abef44, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceImageDrmFormatModifierInfo) Deref() {
	if x.refd7abef44 == nil {
		return
	}
	x.SType = (StructureType)(x.refd7abef44.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd7abef44.pNext))
	x.DrmFormatModifier = (uint64)(x.refd7abef44.drmFormatModifier)
	x.SharingMode = (SharingMode)(x.refd7abef44.sharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.refd7abef44.queueFamilyIndexCount)
	hxf44d909 := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf44d909.Data = unsafe.Pointer(x.refd7abef44.pQueueFamilyIndices)
	hxf44d909.Cap = 0x7fffffff
	// hxf44d909.Len = ?

}

// allocImageDrmFormatModifierListCreateInfoMemory allocates memory for type C.VkImageDrmFormatModifierListCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageDrmFormatModifierListCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageDrmFormatModifierListCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageDrmFormatModifierListCreateInfoValue = unsafe.Sizeof([1]C.VkImageDrmFormatModifierListCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageDrmFormatModifierListCreateInfo) Ref() *C.VkImageDrmFormatModifierListCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref544538ab
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageDrmFormatModifierListCreateInfo) Free() {
	if x != nil && x.allocs544538ab != nil {
		x.allocs544538ab.(*cgoAllocMap).Free()
		x.ref544538ab = nil
	}
}

// NewImageDrmFormatModifierListCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageDrmFormatModifierListCreateInfoRef(ref unsafe.Pointer) *ImageDrmFormatModifierListCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageDrmFormatModifierListCreateInfo)
	obj.ref544538ab = (*C.VkImageDrmFormatModifierListCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageDrmFormatModifierListCreateInfo) PassRef() (*C.VkImageDrmFormatModifierListCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref544538ab != nil {
		return x.ref544538ab, nil
	}
	mem544538ab := allocImageDrmFormatModifierListCreateInfoMemory(1)
	ref544538ab := (*C.VkImageDrmFormatModifierListCreateInfoEXT)(mem544538ab)
	allocs544538ab := new(cgoAllocMap)
	allocs544538ab.Add(mem544538ab)

	var csType_allocs *cgoAllocMap
	ref544538ab.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs544538ab.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref544538ab.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs544538ab.Borrow(cpNext_allocs)

	var cdrmFormatModifierCount_allocs *cgoAllocMap
	ref544538ab.drmFormatModifierCount, cdrmFormatModifierCount_allocs = (C.uint32_t)(x.DrmFormatModifierCount), cgoAllocsUnknown
	allocs544538ab.Borrow(cdrmFormatModifierCount_allocs)

	var cpDrmFormatModifiers_allocs *cgoAllocMap
	ref544538ab.pDrmFormatModifiers, cpDrmFormatModifiers_allocs = (*C.uint64_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDrmFormatModifiers)).Data)), cgoAllocsUnknown
	allocs544538ab.Borrow(cpDrmFormatModifiers_allocs)

	x.ref544538ab = ref544538ab
	x.allocs544538ab = allocs544538ab
	return ref544538ab, allocs544538ab

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageDrmFormatModifierListCreateInfo) PassValue() (C.VkImageDrmFormatModifierListCreateInfoEXT, *cgoAllocMap) {
	if x.ref544538ab != nil {
		return *x.ref544538ab, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageDrmFormatModifierListCreateInfo) Deref() {
	if x.ref544538ab == nil {
		return
	}
	x.SType = (StructureType)(x.ref544538ab.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref544538ab.pNext))
	x.DrmFormatModifierCount = (uint32)(x.ref544538ab.drmFormatModifierCount)
	hxfa835e7 := (*sliceHeader)(unsafe.Pointer(&x.PDrmFormatModifiers))
	hxfa835e7.Data = unsafe.Pointer(x.ref544538ab.pDrmFormatModifiers)
	hxfa835e7.Cap = 0x7fffffff
	// hxfa835e7.Len = ?

}

// allocImageDrmFormatModifierExplicitCreateInfoMemory allocates memory for type C.VkImageDrmFormatModifierExplicitCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageDrmFormatModifierExplicitCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageDrmFormatModifierExplicitCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageDrmFormatModifierExplicitCreateInfoValue = unsafe.Sizeof([1]C.VkImageDrmFormatModifierExplicitCreateInfoEXT{})

// unpackSSubresourceLayout transforms a sliced Go data structure into plain C format.
func unpackSSubresourceLayout(x []SubresourceLayout) (unpacked *C.VkSubresourceLayout, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubresourceLayout) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubresourceLayoutMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubresourceLayout)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubresourceLayout)(h.Data)
	return
}

// packSSubresourceLayout reads sliced Go data structure out from plain C format.
func packSSubresourceLayout(v []SubresourceLayout, ptr0 *C.VkSubresourceLayout) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubresourceLayoutValue]C.VkSubresourceLayout)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubresourceLayoutRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageDrmFormatModifierExplicitCreateInfo) Ref() *C.VkImageDrmFormatModifierExplicitCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref8fb45ca9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageDrmFormatModifierExplicitCreateInfo) Free() {
	if x != nil && x.allocs8fb45ca9 != nil {
		x.allocs8fb45ca9.(*cgoAllocMap).Free()
		x.ref8fb45ca9 = nil
	}
}

// NewImageDrmFormatModifierExplicitCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageDrmFormatModifierExplicitCreateInfoRef(ref unsafe.Pointer) *ImageDrmFormatModifierExplicitCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageDrmFormatModifierExplicitCreateInfo)
	obj.ref8fb45ca9 = (*C.VkImageDrmFormatModifierExplicitCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageDrmFormatModifierExplicitCreateInfo) PassRef() (*C.VkImageDrmFormatModifierExplicitCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8fb45ca9 != nil {
		return x.ref8fb45ca9, nil
	}
	mem8fb45ca9 := allocImageDrmFormatModifierExplicitCreateInfoMemory(1)
	ref8fb45ca9 := (*C.VkImageDrmFormatModifierExplicitCreateInfoEXT)(mem8fb45ca9)
	allocs8fb45ca9 := new(cgoAllocMap)
	allocs8fb45ca9.Add(mem8fb45ca9)

	var csType_allocs *cgoAllocMap
	ref8fb45ca9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs8fb45ca9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref8fb45ca9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs8fb45ca9.Borrow(cpNext_allocs)

	var cdrmFormatModifier_allocs *cgoAllocMap
	ref8fb45ca9.drmFormatModifier, cdrmFormatModifier_allocs = (C.uint64_t)(x.DrmFormatModifier), cgoAllocsUnknown
	allocs8fb45ca9.Borrow(cdrmFormatModifier_allocs)

	var cdrmFormatModifierPlaneCount_allocs *cgoAllocMap
	ref8fb45ca9.drmFormatModifierPlaneCount, cdrmFormatModifierPlaneCount_allocs = (C.uint32_t)(x.DrmFormatModifierPlaneCount), cgoAllocsUnknown
	allocs8fb45ca9.Borrow(cdrmFormatModifierPlaneCount_allocs)

	var cpPlaneLayouts_allocs *cgoAllocMap
	ref8fb45ca9.pPlaneLayouts, cpPlaneLayouts_allocs = unpackSSubresourceLayout(x.PPlaneLayouts)
	allocs8fb45ca9.Borrow(cpPlaneLayouts_allocs)

	x.ref8fb45ca9 = ref8fb45ca9
	x.allocs8fb45ca9 = allocs8fb45ca9
	return ref8fb45ca9, allocs8fb45ca9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageDrmFormatModifierExplicitCreateInfo) PassValue() (C.VkImageDrmFormatModifierExplicitCreateInfoEXT, *cgoAllocMap) {
	if x.ref8fb45ca9 != nil {
		return *x.ref8fb45ca9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageDrmFormatModifierExplicitCreateInfo) Deref() {
	if x.ref8fb45ca9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8fb45ca9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8fb45ca9.pNext))
	x.DrmFormatModifier = (uint64)(x.ref8fb45ca9.drmFormatModifier)
	x.DrmFormatModifierPlaneCount = (uint32)(x.ref8fb45ca9.drmFormatModifierPlaneCount)
	packSSubresourceLayout(x.PPlaneLayouts, x.ref8fb45ca9.pPlaneLayouts)
}

// allocImageDrmFormatModifierPropertiesMemory allocates memory for type C.VkImageDrmFormatModifierPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageDrmFormatModifierPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageDrmFormatModifierPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageDrmFormatModifierPropertiesValue = unsafe.Sizeof([1]C.VkImageDrmFormatModifierPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageDrmFormatModifierProperties) Ref() *C.VkImageDrmFormatModifierPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref86a0f149
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageDrmFormatModifierProperties) Free() {
	if x != nil && x.allocs86a0f149 != nil {
		x.allocs86a0f149.(*cgoAllocMap).Free()
		x.ref86a0f149 = nil
	}
}

// NewImageDrmFormatModifierPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageDrmFormatModifierPropertiesRef(ref unsafe.Pointer) *ImageDrmFormatModifierProperties {
	if ref == nil {
		return nil
	}
	obj := new(ImageDrmFormatModifierProperties)
	obj.ref86a0f149 = (*C.VkImageDrmFormatModifierPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageDrmFormatModifierProperties) PassRef() (*C.VkImageDrmFormatModifierPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref86a0f149 != nil {
		return x.ref86a0f149, nil
	}
	mem86a0f149 := allocImageDrmFormatModifierPropertiesMemory(1)
	ref86a0f149 := (*C.VkImageDrmFormatModifierPropertiesEXT)(mem86a0f149)
	allocs86a0f149 := new(cgoAllocMap)
	allocs86a0f149.Add(mem86a0f149)

	var csType_allocs *cgoAllocMap
	ref86a0f149.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs86a0f149.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref86a0f149.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs86a0f149.Borrow(cpNext_allocs)

	var cdrmFormatModifier_allocs *cgoAllocMap
	ref86a0f149.drmFormatModifier, cdrmFormatModifier_allocs = (C.uint64_t)(x.DrmFormatModifier), cgoAllocsUnknown
	allocs86a0f149.Borrow(cdrmFormatModifier_allocs)

	x.ref86a0f149 = ref86a0f149
	x.allocs86a0f149 = allocs86a0f149
	return ref86a0f149, allocs86a0f149

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageDrmFormatModifierProperties) PassValue() (C.VkImageDrmFormatModifierPropertiesEXT, *cgoAllocMap) {
	if x.ref86a0f149 != nil {
		return *x.ref86a0f149, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageDrmFormatModifierProperties) Deref() {
	if x.ref86a0f149 == nil {
		return
	}
	x.SType = (StructureType)(x.ref86a0f149.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref86a0f149.pNext))
	x.DrmFormatModifier = (uint64)(x.ref86a0f149.drmFormatModifier)
}

// allocValidationCacheCreateInfoMemory allocates memory for type C.VkValidationCacheCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValidationCacheCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValidationCacheCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfValidationCacheCreateInfoValue = unsafe.Sizeof([1]C.VkValidationCacheCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ValidationCacheCreateInfo) Ref() *C.VkValidationCacheCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref3d8ac8aa
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ValidationCacheCreateInfo) Free() {
	if x != nil && x.allocs3d8ac8aa != nil {
		x.allocs3d8ac8aa.(*cgoAllocMap).Free()
		x.ref3d8ac8aa = nil
	}
}

// NewValidationCacheCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewValidationCacheCreateInfoRef(ref unsafe.Pointer) *ValidationCacheCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ValidationCacheCreateInfo)
	obj.ref3d8ac8aa = (*C.VkValidationCacheCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ValidationCacheCreateInfo) PassRef() (*C.VkValidationCacheCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3d8ac8aa != nil {
		return x.ref3d8ac8aa, nil
	}
	mem3d8ac8aa := allocValidationCacheCreateInfoMemory(1)
	ref3d8ac8aa := (*C.VkValidationCacheCreateInfoEXT)(mem3d8ac8aa)
	allocs3d8ac8aa := new(cgoAllocMap)
	allocs3d8ac8aa.Add(mem3d8ac8aa)

	var csType_allocs *cgoAllocMap
	ref3d8ac8aa.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3d8ac8aa.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3d8ac8aa.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3d8ac8aa.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref3d8ac8aa.flags, cflags_allocs = (C.VkValidationCacheCreateFlagsEXT)(x.Flags), cgoAllocsUnknown
	allocs3d8ac8aa.Borrow(cflags_allocs)

	var cinitialDataSize_allocs *cgoAllocMap
	ref3d8ac8aa.initialDataSize, cinitialDataSize_allocs = (C.size_t)(x.InitialDataSize), cgoAllocsUnknown
	allocs3d8ac8aa.Borrow(cinitialDataSize_allocs)

	var cpInitialData_allocs *cgoAllocMap
	ref3d8ac8aa.pInitialData, cpInitialData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PInitialData)), cgoAllocsUnknown
	allocs3d8ac8aa.Borrow(cpInitialData_allocs)

	x.ref3d8ac8aa = ref3d8ac8aa
	x.allocs3d8ac8aa = allocs3d8ac8aa
	return ref3d8ac8aa, allocs3d8ac8aa

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ValidationCacheCreateInfo) PassValue() (C.VkValidationCacheCreateInfoEXT, *cgoAllocMap) {
	if x.ref3d8ac8aa != nil {
		return *x.ref3d8ac8aa, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ValidationCacheCreateInfo) Deref() {
	if x.ref3d8ac8aa == nil {
		return
	}
	x.SType = (StructureType)(x.ref3d8ac8aa.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3d8ac8aa.pNext))
	x.Flags = (ValidationCacheCreateFlags)(x.ref3d8ac8aa.flags)
	x.InitialDataSize = (uint64)(x.ref3d8ac8aa.initialDataSize)
	x.PInitialData = (unsafe.Pointer)(unsafe.Pointer(x.ref3d8ac8aa.pInitialData))
}

// allocShaderModuleValidationCacheCreateInfoMemory allocates memory for type C.VkShaderModuleValidationCacheCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderModuleValidationCacheCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderModuleValidationCacheCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaderModuleValidationCacheCreateInfoValue = unsafe.Sizeof([1]C.VkShaderModuleValidationCacheCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShaderModuleValidationCacheCreateInfo) Ref() *C.VkShaderModuleValidationCacheCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref37065f24
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShaderModuleValidationCacheCreateInfo) Free() {
	if x != nil && x.allocs37065f24 != nil {
		x.allocs37065f24.(*cgoAllocMap).Free()
		x.ref37065f24 = nil
	}
}

// NewShaderModuleValidationCacheCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderModuleValidationCacheCreateInfoRef(ref unsafe.Pointer) *ShaderModuleValidationCacheCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ShaderModuleValidationCacheCreateInfo)
	obj.ref37065f24 = (*C.VkShaderModuleValidationCacheCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShaderModuleValidationCacheCreateInfo) PassRef() (*C.VkShaderModuleValidationCacheCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref37065f24 != nil {
		return x.ref37065f24, nil
	}
	mem37065f24 := allocShaderModuleValidationCacheCreateInfoMemory(1)
	ref37065f24 := (*C.VkShaderModuleValidationCacheCreateInfoEXT)(mem37065f24)
	allocs37065f24 := new(cgoAllocMap)
	allocs37065f24.Add(mem37065f24)

	var csType_allocs *cgoAllocMap
	ref37065f24.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs37065f24.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref37065f24.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs37065f24.Borrow(cpNext_allocs)

	var cvalidationCache_allocs *cgoAllocMap
	ref37065f24.validationCache, cvalidationCache_allocs = *(*C.VkValidationCacheEXT)(unsafe.Pointer(&x.ValidationCache)), cgoAllocsUnknown
	allocs37065f24.Borrow(cvalidationCache_allocs)

	x.ref37065f24 = ref37065f24
	x.allocs37065f24 = allocs37065f24
	return ref37065f24, allocs37065f24

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShaderModuleValidationCacheCreateInfo) PassValue() (C.VkShaderModuleValidationCacheCreateInfoEXT, *cgoAllocMap) {
	if x.ref37065f24 != nil {
		return *x.ref37065f24, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShaderModuleValidationCacheCreateInfo) Deref() {
	if x.ref37065f24 == nil {
		return
	}
	x.SType = (StructureType)(x.ref37065f24.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref37065f24.pNext))
	x.ValidationCache = *(*ValidationCache)(unsafe.Pointer(&x.ref37065f24.validationCache))
}

// allocDescriptorSetLayoutBindingFlagsCreateInfoMemory allocates memory for type C.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutBindingFlagsCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutBindingFlagsCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetLayoutBindingFlagsCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) Ref() *C.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refcb1cf42
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) Free() {
	if x != nil && x.allocscb1cf42 != nil {
		x.allocscb1cf42.(*cgoAllocMap).Free()
		x.refcb1cf42 = nil
	}
}

// NewDescriptorSetLayoutBindingFlagsCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetLayoutBindingFlagsCreateInfoRef(ref unsafe.Pointer) *DescriptorSetLayoutBindingFlagsCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutBindingFlagsCreateInfo)
	obj.refcb1cf42 = (*C.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) PassRef() (*C.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcb1cf42 != nil {
		return x.refcb1cf42, nil
	}
	memcb1cf42 := allocDescriptorSetLayoutBindingFlagsCreateInfoMemory(1)
	refcb1cf42 := (*C.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT)(memcb1cf42)
	allocscb1cf42 := new(cgoAllocMap)
	allocscb1cf42.Add(memcb1cf42)

	var csType_allocs *cgoAllocMap
	refcb1cf42.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocscb1cf42.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refcb1cf42.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocscb1cf42.Borrow(cpNext_allocs)

	var cbindingCount_allocs *cgoAllocMap
	refcb1cf42.bindingCount, cbindingCount_allocs = (C.uint32_t)(x.BindingCount), cgoAllocsUnknown
	allocscb1cf42.Borrow(cbindingCount_allocs)

	var cpBindingFlags_allocs *cgoAllocMap
	refcb1cf42.pBindingFlags, cpBindingFlags_allocs = (*C.VkDescriptorBindingFlagsEXT)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PBindingFlags)).Data)), cgoAllocsUnknown
	allocscb1cf42.Borrow(cpBindingFlags_allocs)

	x.refcb1cf42 = refcb1cf42
	x.allocscb1cf42 = allocscb1cf42
	return refcb1cf42, allocscb1cf42

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) PassValue() (C.VkDescriptorSetLayoutBindingFlagsCreateInfoEXT, *cgoAllocMap) {
	if x.refcb1cf42 != nil {
		return *x.refcb1cf42, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) Deref() {
	if x.refcb1cf42 == nil {
		return
	}
	x.SType = (StructureType)(x.refcb1cf42.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcb1cf42.pNext))
	x.BindingCount = (uint32)(x.refcb1cf42.bindingCount)
	hxf8eae10 := (*sliceHeader)(unsafe.Pointer(&x.PBindingFlags))
	hxf8eae10.Data = unsafe.Pointer(x.refcb1cf42.pBindingFlags)
	hxf8eae10.Cap = 0x7fffffff
	// hxf8eae10.Len = ?

}

// allocPhysicalDeviceDescriptorIndexingFeaturesMemory allocates memory for type C.VkPhysicalDeviceDescriptorIndexingFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDescriptorIndexingFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDescriptorIndexingFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceDescriptorIndexingFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDescriptorIndexingFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDescriptorIndexingFeatures) Ref() *C.VkPhysicalDeviceDescriptorIndexingFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.ref76ca48bc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDescriptorIndexingFeatures) Free() {
	if x != nil && x.allocs76ca48bc != nil {
		x.allocs76ca48bc.(*cgoAllocMap).Free()
		x.ref76ca48bc = nil
	}
}

// NewPhysicalDeviceDescriptorIndexingFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDescriptorIndexingFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceDescriptorIndexingFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDescriptorIndexingFeatures)
	obj.ref76ca48bc = (*C.VkPhysicalDeviceDescriptorIndexingFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDescriptorIndexingFeatures) PassRef() (*C.VkPhysicalDeviceDescriptorIndexingFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref76ca48bc != nil {
		return x.ref76ca48bc, nil
	}
	mem76ca48bc := allocPhysicalDeviceDescriptorIndexingFeaturesMemory(1)
	ref76ca48bc := (*C.VkPhysicalDeviceDescriptorIndexingFeaturesEXT)(mem76ca48bc)
	allocs76ca48bc := new(cgoAllocMap)
	allocs76ca48bc.Add(mem76ca48bc)

	var csType_allocs *cgoAllocMap
	ref76ca48bc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs76ca48bc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref76ca48bc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cpNext_allocs)

	var cshaderInputAttachmentArrayDynamicIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderInputAttachmentArrayDynamicIndexing, cshaderInputAttachmentArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderInputAttachmentArrayDynamicIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderInputAttachmentArrayDynamicIndexing_allocs)

	var cshaderUniformTexelBufferArrayDynamicIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderUniformTexelBufferArrayDynamicIndexing, cshaderUniformTexelBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderUniformTexelBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderUniformTexelBufferArrayDynamicIndexing_allocs)

	var cshaderStorageTexelBufferArrayDynamicIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderStorageTexelBufferArrayDynamicIndexing, cshaderStorageTexelBufferArrayDynamicIndexing_allocs = (C.VkBool32)(x.ShaderStorageTexelBufferArrayDynamicIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderStorageTexelBufferArrayDynamicIndexing_allocs)

	var cshaderUniformBufferArrayNonUniformIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderUniformBufferArrayNonUniformIndexing, cshaderUniformBufferArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderUniformBufferArrayNonUniformIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderUniformBufferArrayNonUniformIndexing_allocs)

	var cshaderSampledImageArrayNonUniformIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderSampledImageArrayNonUniformIndexing, cshaderSampledImageArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderSampledImageArrayNonUniformIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderSampledImageArrayNonUniformIndexing_allocs)

	var cshaderStorageBufferArrayNonUniformIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderStorageBufferArrayNonUniformIndexing, cshaderStorageBufferArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderStorageBufferArrayNonUniformIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderStorageBufferArrayNonUniformIndexing_allocs)

	var cshaderStorageImageArrayNonUniformIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderStorageImageArrayNonUniformIndexing, cshaderStorageImageArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderStorageImageArrayNonUniformIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderStorageImageArrayNonUniformIndexing_allocs)

	var cshaderInputAttachmentArrayNonUniformIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderInputAttachmentArrayNonUniformIndexing, cshaderInputAttachmentArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderInputAttachmentArrayNonUniformIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderInputAttachmentArrayNonUniformIndexing_allocs)

	var cshaderUniformTexelBufferArrayNonUniformIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderUniformTexelBufferArrayNonUniformIndexing, cshaderUniformTexelBufferArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderUniformTexelBufferArrayNonUniformIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderUniformTexelBufferArrayNonUniformIndexing_allocs)

	var cshaderStorageTexelBufferArrayNonUniformIndexing_allocs *cgoAllocMap
	ref76ca48bc.shaderStorageTexelBufferArrayNonUniformIndexing, cshaderStorageTexelBufferArrayNonUniformIndexing_allocs = (C.VkBool32)(x.ShaderStorageTexelBufferArrayNonUniformIndexing), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cshaderStorageTexelBufferArrayNonUniformIndexing_allocs)

	var cdescriptorBindingUniformBufferUpdateAfterBind_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingUniformBufferUpdateAfterBind, cdescriptorBindingUniformBufferUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingUniformBufferUpdateAfterBind), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingUniformBufferUpdateAfterBind_allocs)

	var cdescriptorBindingSampledImageUpdateAfterBind_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingSampledImageUpdateAfterBind, cdescriptorBindingSampledImageUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingSampledImageUpdateAfterBind), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingSampledImageUpdateAfterBind_allocs)

	var cdescriptorBindingStorageImageUpdateAfterBind_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingStorageImageUpdateAfterBind, cdescriptorBindingStorageImageUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingStorageImageUpdateAfterBind), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingStorageImageUpdateAfterBind_allocs)

	var cdescriptorBindingStorageBufferUpdateAfterBind_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingStorageBufferUpdateAfterBind, cdescriptorBindingStorageBufferUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingStorageBufferUpdateAfterBind), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingStorageBufferUpdateAfterBind_allocs)

	var cdescriptorBindingUniformTexelBufferUpdateAfterBind_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingUniformTexelBufferUpdateAfterBind, cdescriptorBindingUniformTexelBufferUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingUniformTexelBufferUpdateAfterBind), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingUniformTexelBufferUpdateAfterBind_allocs)

	var cdescriptorBindingStorageTexelBufferUpdateAfterBind_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingStorageTexelBufferUpdateAfterBind, cdescriptorBindingStorageTexelBufferUpdateAfterBind_allocs = (C.VkBool32)(x.DescriptorBindingStorageTexelBufferUpdateAfterBind), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingStorageTexelBufferUpdateAfterBind_allocs)

	var cdescriptorBindingUpdateUnusedWhilePending_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingUpdateUnusedWhilePending, cdescriptorBindingUpdateUnusedWhilePending_allocs = (C.VkBool32)(x.DescriptorBindingUpdateUnusedWhilePending), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingUpdateUnusedWhilePending_allocs)

	var cdescriptorBindingPartiallyBound_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingPartiallyBound, cdescriptorBindingPartiallyBound_allocs = (C.VkBool32)(x.DescriptorBindingPartiallyBound), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingPartiallyBound_allocs)

	var cdescriptorBindingVariableDescriptorCount_allocs *cgoAllocMap
	ref76ca48bc.descriptorBindingVariableDescriptorCount, cdescriptorBindingVariableDescriptorCount_allocs = (C.VkBool32)(x.DescriptorBindingVariableDescriptorCount), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cdescriptorBindingVariableDescriptorCount_allocs)

	var cruntimeDescriptorArray_allocs *cgoAllocMap
	ref76ca48bc.runtimeDescriptorArray, cruntimeDescriptorArray_allocs = (C.VkBool32)(x.RuntimeDescriptorArray), cgoAllocsUnknown
	allocs76ca48bc.Borrow(cruntimeDescriptorArray_allocs)

	x.ref76ca48bc = ref76ca48bc
	x.allocs76ca48bc = allocs76ca48bc
	return ref76ca48bc, allocs76ca48bc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDescriptorIndexingFeatures) PassValue() (C.VkPhysicalDeviceDescriptorIndexingFeaturesEXT, *cgoAllocMap) {
	if x.ref76ca48bc != nil {
		return *x.ref76ca48bc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDescriptorIndexingFeatures) Deref() {
	if x.ref76ca48bc == nil {
		return
	}
	x.SType = (StructureType)(x.ref76ca48bc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref76ca48bc.pNext))
	x.ShaderInputAttachmentArrayDynamicIndexing = (Bool32)(x.ref76ca48bc.shaderInputAttachmentArrayDynamicIndexing)
	x.ShaderUniformTexelBufferArrayDynamicIndexing = (Bool32)(x.ref76ca48bc.shaderUniformTexelBufferArrayDynamicIndexing)
	x.ShaderStorageTexelBufferArrayDynamicIndexing = (Bool32)(x.ref76ca48bc.shaderStorageTexelBufferArrayDynamicIndexing)
	x.ShaderUniformBufferArrayNonUniformIndexing = (Bool32)(x.ref76ca48bc.shaderUniformBufferArrayNonUniformIndexing)
	x.ShaderSampledImageArrayNonUniformIndexing = (Bool32)(x.ref76ca48bc.shaderSampledImageArrayNonUniformIndexing)
	x.ShaderStorageBufferArrayNonUniformIndexing = (Bool32)(x.ref76ca48bc.shaderStorageBufferArrayNonUniformIndexing)
	x.ShaderStorageImageArrayNonUniformIndexing = (Bool32)(x.ref76ca48bc.shaderStorageImageArrayNonUniformIndexing)
	x.ShaderInputAttachmentArrayNonUniformIndexing = (Bool32)(x.ref76ca48bc.shaderInputAttachmentArrayNonUniformIndexing)
	x.ShaderUniformTexelBufferArrayNonUniformIndexing = (Bool32)(x.ref76ca48bc.shaderUniformTexelBufferArrayNonUniformIndexing)
	x.ShaderStorageTexelBufferArrayNonUniformIndexing = (Bool32)(x.ref76ca48bc.shaderStorageTexelBufferArrayNonUniformIndexing)
	x.DescriptorBindingUniformBufferUpdateAfterBind = (Bool32)(x.ref76ca48bc.descriptorBindingUniformBufferUpdateAfterBind)
	x.DescriptorBindingSampledImageUpdateAfterBind = (Bool32)(x.ref76ca48bc.descriptorBindingSampledImageUpdateAfterBind)
	x.DescriptorBindingStorageImageUpdateAfterBind = (Bool32)(x.ref76ca48bc.descriptorBindingStorageImageUpdateAfterBind)
	x.DescriptorBindingStorageBufferUpdateAfterBind = (Bool32)(x.ref76ca48bc.descriptorBindingStorageBufferUpdateAfterBind)
	x.DescriptorBindingUniformTexelBufferUpdateAfterBind = (Bool32)(x.ref76ca48bc.descriptorBindingUniformTexelBufferUpdateAfterBind)
	x.DescriptorBindingStorageTexelBufferUpdateAfterBind = (Bool32)(x.ref76ca48bc.descriptorBindingStorageTexelBufferUpdateAfterBind)
	x.DescriptorBindingUpdateUnusedWhilePending = (Bool32)(x.ref76ca48bc.descriptorBindingUpdateUnusedWhilePending)
	x.DescriptorBindingPartiallyBound = (Bool32)(x.ref76ca48bc.descriptorBindingPartiallyBound)
	x.DescriptorBindingVariableDescriptorCount = (Bool32)(x.ref76ca48bc.descriptorBindingVariableDescriptorCount)
	x.RuntimeDescriptorArray = (Bool32)(x.ref76ca48bc.runtimeDescriptorArray)
}

// allocPhysicalDeviceDescriptorIndexingPropertiesMemory allocates memory for type C.VkPhysicalDeviceDescriptorIndexingPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDescriptorIndexingPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDescriptorIndexingPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceDescriptorIndexingPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDescriptorIndexingPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDescriptorIndexingProperties) Ref() *C.VkPhysicalDeviceDescriptorIndexingPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref3c07c210
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDescriptorIndexingProperties) Free() {
	if x != nil && x.allocs3c07c210 != nil {
		x.allocs3c07c210.(*cgoAllocMap).Free()
		x.ref3c07c210 = nil
	}
}

// NewPhysicalDeviceDescriptorIndexingPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDescriptorIndexingPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceDescriptorIndexingProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDescriptorIndexingProperties)
	obj.ref3c07c210 = (*C.VkPhysicalDeviceDescriptorIndexingPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDescriptorIndexingProperties) PassRef() (*C.VkPhysicalDeviceDescriptorIndexingPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c07c210 != nil {
		return x.ref3c07c210, nil
	}
	mem3c07c210 := allocPhysicalDeviceDescriptorIndexingPropertiesMemory(1)
	ref3c07c210 := (*C.VkPhysicalDeviceDescriptorIndexingPropertiesEXT)(mem3c07c210)
	allocs3c07c210 := new(cgoAllocMap)
	allocs3c07c210.Add(mem3c07c210)

	var csType_allocs *cgoAllocMap
	ref3c07c210.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs3c07c210.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref3c07c210.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs3c07c210.Borrow(cpNext_allocs)

	var cmaxUpdateAfterBindDescriptorsInAllPools_allocs *cgoAllocMap
	ref3c07c210.maxUpdateAfterBindDescriptorsInAllPools, cmaxUpdateAfterBindDescriptorsInAllPools_allocs = (C.uint32_t)(x.MaxUpdateAfterBindDescriptorsInAllPools), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxUpdateAfterBindDescriptorsInAllPools_allocs)

	var cshaderUniformBufferArrayNonUniformIndexingNative_allocs *cgoAllocMap
	ref3c07c210.shaderUniformBufferArrayNonUniformIndexingNative, cshaderUniformBufferArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderUniformBufferArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocs3c07c210.Borrow(cshaderUniformBufferArrayNonUniformIndexingNative_allocs)

	var cshaderSampledImageArrayNonUniformIndexingNative_allocs *cgoAllocMap
	ref3c07c210.shaderSampledImageArrayNonUniformIndexingNative, cshaderSampledImageArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderSampledImageArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocs3c07c210.Borrow(cshaderSampledImageArrayNonUniformIndexingNative_allocs)

	var cshaderStorageBufferArrayNonUniformIndexingNative_allocs *cgoAllocMap
	ref3c07c210.shaderStorageBufferArrayNonUniformIndexingNative, cshaderStorageBufferArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderStorageBufferArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocs3c07c210.Borrow(cshaderStorageBufferArrayNonUniformIndexingNative_allocs)

	var cshaderStorageImageArrayNonUniformIndexingNative_allocs *cgoAllocMap
	ref3c07c210.shaderStorageImageArrayNonUniformIndexingNative, cshaderStorageImageArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderStorageImageArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocs3c07c210.Borrow(cshaderStorageImageArrayNonUniformIndexingNative_allocs)

	var cshaderInputAttachmentArrayNonUniformIndexingNative_allocs *cgoAllocMap
	ref3c07c210.shaderInputAttachmentArrayNonUniformIndexingNative, cshaderInputAttachmentArrayNonUniformIndexingNative_allocs = (C.VkBool32)(x.ShaderInputAttachmentArrayNonUniformIndexingNative), cgoAllocsUnknown
	allocs3c07c210.Borrow(cshaderInputAttachmentArrayNonUniformIndexingNative_allocs)

	var crobustBufferAccessUpdateAfterBind_allocs *cgoAllocMap
	ref3c07c210.robustBufferAccessUpdateAfterBind, crobustBufferAccessUpdateAfterBind_allocs = (C.VkBool32)(x.RobustBufferAccessUpdateAfterBind), cgoAllocsUnknown
	allocs3c07c210.Borrow(crobustBufferAccessUpdateAfterBind_allocs)

	var cquadDivergentImplicitLod_allocs *cgoAllocMap
	ref3c07c210.quadDivergentImplicitLod, cquadDivergentImplicitLod_allocs = (C.VkBool32)(x.QuadDivergentImplicitLod), cgoAllocsUnknown
	allocs3c07c210.Borrow(cquadDivergentImplicitLod_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindSamplers_allocs *cgoAllocMap
	ref3c07c210.maxPerStageDescriptorUpdateAfterBindSamplers, cmaxPerStageDescriptorUpdateAfterBindSamplers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindSamplers), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxPerStageDescriptorUpdateAfterBindSamplers_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindUniformBuffers_allocs *cgoAllocMap
	ref3c07c210.maxPerStageDescriptorUpdateAfterBindUniformBuffers, cmaxPerStageDescriptorUpdateAfterBindUniformBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindUniformBuffers), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxPerStageDescriptorUpdateAfterBindUniformBuffers_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindStorageBuffers_allocs *cgoAllocMap
	ref3c07c210.maxPerStageDescriptorUpdateAfterBindStorageBuffers, cmaxPerStageDescriptorUpdateAfterBindStorageBuffers_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindStorageBuffers), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxPerStageDescriptorUpdateAfterBindStorageBuffers_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindSampledImages_allocs *cgoAllocMap
	ref3c07c210.maxPerStageDescriptorUpdateAfterBindSampledImages, cmaxPerStageDescriptorUpdateAfterBindSampledImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindSampledImages), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxPerStageDescriptorUpdateAfterBindSampledImages_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindStorageImages_allocs *cgoAllocMap
	ref3c07c210.maxPerStageDescriptorUpdateAfterBindStorageImages, cmaxPerStageDescriptorUpdateAfterBindStorageImages_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindStorageImages), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxPerStageDescriptorUpdateAfterBindStorageImages_allocs)

	var cmaxPerStageDescriptorUpdateAfterBindInputAttachments_allocs *cgoAllocMap
	ref3c07c210.maxPerStageDescriptorUpdateAfterBindInputAttachments, cmaxPerStageDescriptorUpdateAfterBindInputAttachments_allocs = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindInputAttachments), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxPerStageDescriptorUpdateAfterBindInputAttachments_allocs)

	var cmaxPerStageUpdateAfterBindResources_allocs *cgoAllocMap
	ref3c07c210.maxPerStageUpdateAfterBindResources, cmaxPerStageUpdateAfterBindResources_allocs = (C.uint32_t)(x.MaxPerStageUpdateAfterBindResources), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxPerStageUpdateAfterBindResources_allocs)

	var cmaxDescriptorSetUpdateAfterBindSamplers_allocs *cgoAllocMap
	ref3c07c210.maxDescriptorSetUpdateAfterBindSamplers, cmaxDescriptorSetUpdateAfterBindSamplers_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindSamplers), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxDescriptorSetUpdateAfterBindSamplers_allocs)

	var cmaxDescriptorSetUpdateAfterBindUniformBuffers_allocs *cgoAllocMap
	ref3c07c210.maxDescriptorSetUpdateAfterBindUniformBuffers, cmaxDescriptorSetUpdateAfterBindUniformBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindUniformBuffers), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxDescriptorSetUpdateAfterBindUniformBuffers_allocs)

	var cmaxDescriptorSetUpdateAfterBindUniformBuffersDynamic_allocs *cgoAllocMap
	ref3c07c210.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, cmaxDescriptorSetUpdateAfterBindUniformBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxDescriptorSetUpdateAfterBindUniformBuffersDynamic_allocs)

	var cmaxDescriptorSetUpdateAfterBindStorageBuffers_allocs *cgoAllocMap
	ref3c07c210.maxDescriptorSetUpdateAfterBindStorageBuffers, cmaxDescriptorSetUpdateAfterBindStorageBuffers_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindStorageBuffers), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxDescriptorSetUpdateAfterBindStorageBuffers_allocs)

	var cmaxDescriptorSetUpdateAfterBindStorageBuffersDynamic_allocs *cgoAllocMap
	ref3c07c210.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, cmaxDescriptorSetUpdateAfterBindStorageBuffersDynamic_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxDescriptorSetUpdateAfterBindStorageBuffersDynamic_allocs)

	var cmaxDescriptorSetUpdateAfterBindSampledImages_allocs *cgoAllocMap
	ref3c07c210.maxDescriptorSetUpdateAfterBindSampledImages, cmaxDescriptorSetUpdateAfterBindSampledImages_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindSampledImages), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxDescriptorSetUpdateAfterBindSampledImages_allocs)

	var cmaxDescriptorSetUpdateAfterBindStorageImages_allocs *cgoAllocMap
	ref3c07c210.maxDescriptorSetUpdateAfterBindStorageImages, cmaxDescriptorSetUpdateAfterBindStorageImages_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindStorageImages), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxDescriptorSetUpdateAfterBindStorageImages_allocs)

	var cmaxDescriptorSetUpdateAfterBindInputAttachments_allocs *cgoAllocMap
	ref3c07c210.maxDescriptorSetUpdateAfterBindInputAttachments, cmaxDescriptorSetUpdateAfterBindInputAttachments_allocs = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindInputAttachments), cgoAllocsUnknown
	allocs3c07c210.Borrow(cmaxDescriptorSetUpdateAfterBindInputAttachments_allocs)

	x.ref3c07c210 = ref3c07c210
	x.allocs3c07c210 = allocs3c07c210
	return ref3c07c210, allocs3c07c210

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDescriptorIndexingProperties) PassValue() (C.VkPhysicalDeviceDescriptorIndexingPropertiesEXT, *cgoAllocMap) {
	if x.ref3c07c210 != nil {
		return *x.ref3c07c210, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDescriptorIndexingProperties) Deref() {
	if x.ref3c07c210 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3c07c210.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3c07c210.pNext))
	x.MaxUpdateAfterBindDescriptorsInAllPools = (uint32)(x.ref3c07c210.maxUpdateAfterBindDescriptorsInAllPools)
	x.ShaderUniformBufferArrayNonUniformIndexingNative = (Bool32)(x.ref3c07c210.shaderUniformBufferArrayNonUniformIndexingNative)
	x.ShaderSampledImageArrayNonUniformIndexingNative = (Bool32)(x.ref3c07c210.shaderSampledImageArrayNonUniformIndexingNative)
	x.ShaderStorageBufferArrayNonUniformIndexingNative = (Bool32)(x.ref3c07c210.shaderStorageBufferArrayNonUniformIndexingNative)
	x.ShaderStorageImageArrayNonUniformIndexingNative = (Bool32)(x.ref3c07c210.shaderStorageImageArrayNonUniformIndexingNative)
	x.ShaderInputAttachmentArrayNonUniformIndexingNative = (Bool32)(x.ref3c07c210.shaderInputAttachmentArrayNonUniformIndexingNative)
	x.RobustBufferAccessUpdateAfterBind = (Bool32)(x.ref3c07c210.robustBufferAccessUpdateAfterBind)
	x.QuadDivergentImplicitLod = (Bool32)(x.ref3c07c210.quadDivergentImplicitLod)
	x.MaxPerStageDescriptorUpdateAfterBindSamplers = (uint32)(x.ref3c07c210.maxPerStageDescriptorUpdateAfterBindSamplers)
	x.MaxPerStageDescriptorUpdateAfterBindUniformBuffers = (uint32)(x.ref3c07c210.maxPerStageDescriptorUpdateAfterBindUniformBuffers)
	x.MaxPerStageDescriptorUpdateAfterBindStorageBuffers = (uint32)(x.ref3c07c210.maxPerStageDescriptorUpdateAfterBindStorageBuffers)
	x.MaxPerStageDescriptorUpdateAfterBindSampledImages = (uint32)(x.ref3c07c210.maxPerStageDescriptorUpdateAfterBindSampledImages)
	x.MaxPerStageDescriptorUpdateAfterBindStorageImages = (uint32)(x.ref3c07c210.maxPerStageDescriptorUpdateAfterBindStorageImages)
	x.MaxPerStageDescriptorUpdateAfterBindInputAttachments = (uint32)(x.ref3c07c210.maxPerStageDescriptorUpdateAfterBindInputAttachments)
	x.MaxPerStageUpdateAfterBindResources = (uint32)(x.ref3c07c210.maxPerStageUpdateAfterBindResources)
	x.MaxDescriptorSetUpdateAfterBindSamplers = (uint32)(x.ref3c07c210.maxDescriptorSetUpdateAfterBindSamplers)
	x.MaxDescriptorSetUpdateAfterBindUniformBuffers = (uint32)(x.ref3c07c210.maxDescriptorSetUpdateAfterBindUniformBuffers)
	x.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic = (uint32)(x.ref3c07c210.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
	x.MaxDescriptorSetUpdateAfterBindStorageBuffers = (uint32)(x.ref3c07c210.maxDescriptorSetUpdateAfterBindStorageBuffers)
	x.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic = (uint32)(x.ref3c07c210.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)
	x.MaxDescriptorSetUpdateAfterBindSampledImages = (uint32)(x.ref3c07c210.maxDescriptorSetUpdateAfterBindSampledImages)
	x.MaxDescriptorSetUpdateAfterBindStorageImages = (uint32)(x.ref3c07c210.maxDescriptorSetUpdateAfterBindStorageImages)
	x.MaxDescriptorSetUpdateAfterBindInputAttachments = (uint32)(x.ref3c07c210.maxDescriptorSetUpdateAfterBindInputAttachments)
}

// allocDescriptorSetVariableDescriptorCountAllocateInfoMemory allocates memory for type C.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetVariableDescriptorCountAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetVariableDescriptorCountAllocateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetVariableDescriptorCountAllocateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) Ref() *C.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref65152aef
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) Free() {
	if x != nil && x.allocs65152aef != nil {
		x.allocs65152aef.(*cgoAllocMap).Free()
		x.ref65152aef = nil
	}
}

// NewDescriptorSetVariableDescriptorCountAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetVariableDescriptorCountAllocateInfoRef(ref unsafe.Pointer) *DescriptorSetVariableDescriptorCountAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetVariableDescriptorCountAllocateInfo)
	obj.ref65152aef = (*C.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) PassRef() (*C.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref65152aef != nil {
		return x.ref65152aef, nil
	}
	mem65152aef := allocDescriptorSetVariableDescriptorCountAllocateInfoMemory(1)
	ref65152aef := (*C.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT)(mem65152aef)
	allocs65152aef := new(cgoAllocMap)
	allocs65152aef.Add(mem65152aef)

	var csType_allocs *cgoAllocMap
	ref65152aef.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs65152aef.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref65152aef.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs65152aef.Borrow(cpNext_allocs)

	var cdescriptorSetCount_allocs *cgoAllocMap
	ref65152aef.descriptorSetCount, cdescriptorSetCount_allocs = (C.uint32_t)(x.DescriptorSetCount), cgoAllocsUnknown
	allocs65152aef.Borrow(cdescriptorSetCount_allocs)

	var cpDescriptorCounts_allocs *cgoAllocMap
	ref65152aef.pDescriptorCounts, cpDescriptorCounts_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDescriptorCounts)).Data)), cgoAllocsUnknown
	allocs65152aef.Borrow(cpDescriptorCounts_allocs)

	x.ref65152aef = ref65152aef
	x.allocs65152aef = allocs65152aef
	return ref65152aef, allocs65152aef

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) PassValue() (C.VkDescriptorSetVariableDescriptorCountAllocateInfoEXT, *cgoAllocMap) {
	if x.ref65152aef != nil {
		return *x.ref65152aef, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) Deref() {
	if x.ref65152aef == nil {
		return
	}
	x.SType = (StructureType)(x.ref65152aef.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref65152aef.pNext))
	x.DescriptorSetCount = (uint32)(x.ref65152aef.descriptorSetCount)
	hxfeb55cf := (*sliceHeader)(unsafe.Pointer(&x.PDescriptorCounts))
	hxfeb55cf.Data = unsafe.Pointer(x.ref65152aef.pDescriptorCounts)
	hxfeb55cf.Cap = 0x7fffffff
	// hxfeb55cf.Len = ?

}

// allocDescriptorSetVariableDescriptorCountLayoutSupportMemory allocates memory for type C.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetVariableDescriptorCountLayoutSupportMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetVariableDescriptorCountLayoutSupportValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetVariableDescriptorCountLayoutSupportValue = unsafe.Sizeof([1]C.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetVariableDescriptorCountLayoutSupport) Ref() *C.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT {
	if x == nil {
		return nil
	}
	return x.ref4684c56f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetVariableDescriptorCountLayoutSupport) Free() {
	if x != nil && x.allocs4684c56f != nil {
		x.allocs4684c56f.(*cgoAllocMap).Free()
		x.ref4684c56f = nil
	}
}

// NewDescriptorSetVariableDescriptorCountLayoutSupportRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetVariableDescriptorCountLayoutSupportRef(ref unsafe.Pointer) *DescriptorSetVariableDescriptorCountLayoutSupport {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetVariableDescriptorCountLayoutSupport)
	obj.ref4684c56f = (*C.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetVariableDescriptorCountLayoutSupport) PassRef() (*C.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4684c56f != nil {
		return x.ref4684c56f, nil
	}
	mem4684c56f := allocDescriptorSetVariableDescriptorCountLayoutSupportMemory(1)
	ref4684c56f := (*C.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT)(mem4684c56f)
	allocs4684c56f := new(cgoAllocMap)
	allocs4684c56f.Add(mem4684c56f)

	var csType_allocs *cgoAllocMap
	ref4684c56f.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4684c56f.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4684c56f.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4684c56f.Borrow(cpNext_allocs)

	var cmaxVariableDescriptorCount_allocs *cgoAllocMap
	ref4684c56f.maxVariableDescriptorCount, cmaxVariableDescriptorCount_allocs = (C.uint32_t)(x.MaxVariableDescriptorCount), cgoAllocsUnknown
	allocs4684c56f.Borrow(cmaxVariableDescriptorCount_allocs)

	x.ref4684c56f = ref4684c56f
	x.allocs4684c56f = allocs4684c56f
	return ref4684c56f, allocs4684c56f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetVariableDescriptorCountLayoutSupport) PassValue() (C.VkDescriptorSetVariableDescriptorCountLayoutSupportEXT, *cgoAllocMap) {
	if x.ref4684c56f != nil {
		return *x.ref4684c56f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetVariableDescriptorCountLayoutSupport) Deref() {
	if x.ref4684c56f == nil {
		return
	}
	x.SType = (StructureType)(x.ref4684c56f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4684c56f.pNext))
	x.MaxVariableDescriptorCount = (uint32)(x.ref4684c56f.maxVariableDescriptorCount)
}

// allocShadingRatePaletteNVMemory allocates memory for type C.VkShadingRatePaletteNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShadingRatePaletteNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShadingRatePaletteNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShadingRatePaletteNVValue = unsafe.Sizeof([1]C.VkShadingRatePaletteNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShadingRatePaletteNV) Ref() *C.VkShadingRatePaletteNV {
	if x == nil {
		return nil
	}
	return x.refa5c4ae3a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShadingRatePaletteNV) Free() {
	if x != nil && x.allocsa5c4ae3a != nil {
		x.allocsa5c4ae3a.(*cgoAllocMap).Free()
		x.refa5c4ae3a = nil
	}
}

// NewShadingRatePaletteNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShadingRatePaletteNVRef(ref unsafe.Pointer) *ShadingRatePaletteNV {
	if ref == nil {
		return nil
	}
	obj := new(ShadingRatePaletteNV)
	obj.refa5c4ae3a = (*C.VkShadingRatePaletteNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShadingRatePaletteNV) PassRef() (*C.VkShadingRatePaletteNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa5c4ae3a != nil {
		return x.refa5c4ae3a, nil
	}
	mema5c4ae3a := allocShadingRatePaletteNVMemory(1)
	refa5c4ae3a := (*C.VkShadingRatePaletteNV)(mema5c4ae3a)
	allocsa5c4ae3a := new(cgoAllocMap)
	allocsa5c4ae3a.Add(mema5c4ae3a)

	var cshadingRatePaletteEntryCount_allocs *cgoAllocMap
	refa5c4ae3a.shadingRatePaletteEntryCount, cshadingRatePaletteEntryCount_allocs = (C.uint32_t)(x.ShadingRatePaletteEntryCount), cgoAllocsUnknown
	allocsa5c4ae3a.Borrow(cshadingRatePaletteEntryCount_allocs)

	var cpShadingRatePaletteEntries_allocs *cgoAllocMap
	refa5c4ae3a.pShadingRatePaletteEntries, cpShadingRatePaletteEntries_allocs = (*C.VkShadingRatePaletteEntryNV)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PShadingRatePaletteEntries)).Data)), cgoAllocsUnknown
	allocsa5c4ae3a.Borrow(cpShadingRatePaletteEntries_allocs)

	x.refa5c4ae3a = refa5c4ae3a
	x.allocsa5c4ae3a = allocsa5c4ae3a
	return refa5c4ae3a, allocsa5c4ae3a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShadingRatePaletteNV) PassValue() (C.VkShadingRatePaletteNV, *cgoAllocMap) {
	if x.refa5c4ae3a != nil {
		return *x.refa5c4ae3a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShadingRatePaletteNV) Deref() {
	if x.refa5c4ae3a == nil {
		return
	}
	x.ShadingRatePaletteEntryCount = (uint32)(x.refa5c4ae3a.shadingRatePaletteEntryCount)
	hxf458096 := (*sliceHeader)(unsafe.Pointer(&x.PShadingRatePaletteEntries))
	hxf458096.Data = unsafe.Pointer(x.refa5c4ae3a.pShadingRatePaletteEntries)
	hxf458096.Cap = 0x7fffffff
	// hxf458096.Len = ?

}

// allocPipelineViewportShadingRateImageStateCreateInfoNVMemory allocates memory for type C.VkPipelineViewportShadingRateImageStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportShadingRateImageStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportShadingRateImageStateCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineViewportShadingRateImageStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineViewportShadingRateImageStateCreateInfoNV{})

// unpackSShadingRatePaletteNV transforms a sliced Go data structure into plain C format.
func unpackSShadingRatePaletteNV(x []ShadingRatePaletteNV) (unpacked *C.VkShadingRatePaletteNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkShadingRatePaletteNV) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocShadingRatePaletteNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkShadingRatePaletteNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkShadingRatePaletteNV)(h.Data)
	return
}

// packSShadingRatePaletteNV reads sliced Go data structure out from plain C format.
func packSShadingRatePaletteNV(v []ShadingRatePaletteNV, ptr0 *C.VkShadingRatePaletteNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfShadingRatePaletteNVValue]C.VkShadingRatePaletteNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewShadingRatePaletteNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportShadingRateImageStateCreateInfoNV) Ref() *C.VkPipelineViewportShadingRateImageStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref6f2ec732
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportShadingRateImageStateCreateInfoNV) Free() {
	if x != nil && x.allocs6f2ec732 != nil {
		x.allocs6f2ec732.(*cgoAllocMap).Free()
		x.ref6f2ec732 = nil
	}
}

// NewPipelineViewportShadingRateImageStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportShadingRateImageStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineViewportShadingRateImageStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportShadingRateImageStateCreateInfoNV)
	obj.ref6f2ec732 = (*C.VkPipelineViewportShadingRateImageStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportShadingRateImageStateCreateInfoNV) PassRef() (*C.VkPipelineViewportShadingRateImageStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6f2ec732 != nil {
		return x.ref6f2ec732, nil
	}
	mem6f2ec732 := allocPipelineViewportShadingRateImageStateCreateInfoNVMemory(1)
	ref6f2ec732 := (*C.VkPipelineViewportShadingRateImageStateCreateInfoNV)(mem6f2ec732)
	allocs6f2ec732 := new(cgoAllocMap)
	allocs6f2ec732.Add(mem6f2ec732)

	var csType_allocs *cgoAllocMap
	ref6f2ec732.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs6f2ec732.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref6f2ec732.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs6f2ec732.Borrow(cpNext_allocs)

	var cshadingRateImageEnable_allocs *cgoAllocMap
	ref6f2ec732.shadingRateImageEnable, cshadingRateImageEnable_allocs = (C.VkBool32)(x.ShadingRateImageEnable), cgoAllocsUnknown
	allocs6f2ec732.Borrow(cshadingRateImageEnable_allocs)

	var cviewportCount_allocs *cgoAllocMap
	ref6f2ec732.viewportCount, cviewportCount_allocs = (C.uint32_t)(x.ViewportCount), cgoAllocsUnknown
	allocs6f2ec732.Borrow(cviewportCount_allocs)

	var cpShadingRatePalettes_allocs *cgoAllocMap
	ref6f2ec732.pShadingRatePalettes, cpShadingRatePalettes_allocs = unpackSShadingRatePaletteNV(x.PShadingRatePalettes)
	allocs6f2ec732.Borrow(cpShadingRatePalettes_allocs)

	x.ref6f2ec732 = ref6f2ec732
	x.allocs6f2ec732 = allocs6f2ec732
	return ref6f2ec732, allocs6f2ec732

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportShadingRateImageStateCreateInfoNV) PassValue() (C.VkPipelineViewportShadingRateImageStateCreateInfoNV, *cgoAllocMap) {
	if x.ref6f2ec732 != nil {
		return *x.ref6f2ec732, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportShadingRateImageStateCreateInfoNV) Deref() {
	if x.ref6f2ec732 == nil {
		return
	}
	x.SType = (StructureType)(x.ref6f2ec732.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6f2ec732.pNext))
	x.ShadingRateImageEnable = (Bool32)(x.ref6f2ec732.shadingRateImageEnable)
	x.ViewportCount = (uint32)(x.ref6f2ec732.viewportCount)
	packSShadingRatePaletteNV(x.PShadingRatePalettes, x.ref6f2ec732.pShadingRatePalettes)
}

// allocPhysicalDeviceShadingRateImageFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceShadingRateImageFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShadingRateImageFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShadingRateImageFeaturesNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceShadingRateImageFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShadingRateImageFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShadingRateImageFeaturesNV) Ref() *C.VkPhysicalDeviceShadingRateImageFeaturesNV {
	if x == nil {
		return nil
	}
	return x.ref199a921b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShadingRateImageFeaturesNV) Free() {
	if x != nil && x.allocs199a921b != nil {
		x.allocs199a921b.(*cgoAllocMap).Free()
		x.ref199a921b = nil
	}
}

// NewPhysicalDeviceShadingRateImageFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShadingRateImageFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceShadingRateImageFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShadingRateImageFeaturesNV)
	obj.ref199a921b = (*C.VkPhysicalDeviceShadingRateImageFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShadingRateImageFeaturesNV) PassRef() (*C.VkPhysicalDeviceShadingRateImageFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref199a921b != nil {
		return x.ref199a921b, nil
	}
	mem199a921b := allocPhysicalDeviceShadingRateImageFeaturesNVMemory(1)
	ref199a921b := (*C.VkPhysicalDeviceShadingRateImageFeaturesNV)(mem199a921b)
	allocs199a921b := new(cgoAllocMap)
	allocs199a921b.Add(mem199a921b)

	var csType_allocs *cgoAllocMap
	ref199a921b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs199a921b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref199a921b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs199a921b.Borrow(cpNext_allocs)

	var cshadingRateImage_allocs *cgoAllocMap
	ref199a921b.shadingRateImage, cshadingRateImage_allocs = (C.VkBool32)(x.ShadingRateImage), cgoAllocsUnknown
	allocs199a921b.Borrow(cshadingRateImage_allocs)

	var cshadingRateCoarseSampleOrder_allocs *cgoAllocMap
	ref199a921b.shadingRateCoarseSampleOrder, cshadingRateCoarseSampleOrder_allocs = (C.VkBool32)(x.ShadingRateCoarseSampleOrder), cgoAllocsUnknown
	allocs199a921b.Borrow(cshadingRateCoarseSampleOrder_allocs)

	x.ref199a921b = ref199a921b
	x.allocs199a921b = allocs199a921b
	return ref199a921b, allocs199a921b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShadingRateImageFeaturesNV) PassValue() (C.VkPhysicalDeviceShadingRateImageFeaturesNV, *cgoAllocMap) {
	if x.ref199a921b != nil {
		return *x.ref199a921b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShadingRateImageFeaturesNV) Deref() {
	if x.ref199a921b == nil {
		return
	}
	x.SType = (StructureType)(x.ref199a921b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref199a921b.pNext))
	x.ShadingRateImage = (Bool32)(x.ref199a921b.shadingRateImage)
	x.ShadingRateCoarseSampleOrder = (Bool32)(x.ref199a921b.shadingRateCoarseSampleOrder)
}

// allocPhysicalDeviceShadingRateImagePropertiesNVMemory allocates memory for type C.VkPhysicalDeviceShadingRateImagePropertiesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShadingRateImagePropertiesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShadingRateImagePropertiesNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceShadingRateImagePropertiesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShadingRateImagePropertiesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShadingRateImagePropertiesNV) Ref() *C.VkPhysicalDeviceShadingRateImagePropertiesNV {
	if x == nil {
		return nil
	}
	return x.refea059f34
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShadingRateImagePropertiesNV) Free() {
	if x != nil && x.allocsea059f34 != nil {
		x.allocsea059f34.(*cgoAllocMap).Free()
		x.refea059f34 = nil
	}
}

// NewPhysicalDeviceShadingRateImagePropertiesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShadingRateImagePropertiesNVRef(ref unsafe.Pointer) *PhysicalDeviceShadingRateImagePropertiesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShadingRateImagePropertiesNV)
	obj.refea059f34 = (*C.VkPhysicalDeviceShadingRateImagePropertiesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShadingRateImagePropertiesNV) PassRef() (*C.VkPhysicalDeviceShadingRateImagePropertiesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refea059f34 != nil {
		return x.refea059f34, nil
	}
	memea059f34 := allocPhysicalDeviceShadingRateImagePropertiesNVMemory(1)
	refea059f34 := (*C.VkPhysicalDeviceShadingRateImagePropertiesNV)(memea059f34)
	allocsea059f34 := new(cgoAllocMap)
	allocsea059f34.Add(memea059f34)

	var csType_allocs *cgoAllocMap
	refea059f34.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsea059f34.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refea059f34.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsea059f34.Borrow(cpNext_allocs)

	var cshadingRateTexelSize_allocs *cgoAllocMap
	refea059f34.shadingRateTexelSize, cshadingRateTexelSize_allocs = x.ShadingRateTexelSize.PassValue()
	allocsea059f34.Borrow(cshadingRateTexelSize_allocs)

	var cshadingRatePaletteSize_allocs *cgoAllocMap
	refea059f34.shadingRatePaletteSize, cshadingRatePaletteSize_allocs = (C.uint32_t)(x.ShadingRatePaletteSize), cgoAllocsUnknown
	allocsea059f34.Borrow(cshadingRatePaletteSize_allocs)

	var cshadingRateMaxCoarseSamples_allocs *cgoAllocMap
	refea059f34.shadingRateMaxCoarseSamples, cshadingRateMaxCoarseSamples_allocs = (C.uint32_t)(x.ShadingRateMaxCoarseSamples), cgoAllocsUnknown
	allocsea059f34.Borrow(cshadingRateMaxCoarseSamples_allocs)

	x.refea059f34 = refea059f34
	x.allocsea059f34 = allocsea059f34
	return refea059f34, allocsea059f34

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShadingRateImagePropertiesNV) PassValue() (C.VkPhysicalDeviceShadingRateImagePropertiesNV, *cgoAllocMap) {
	if x.refea059f34 != nil {
		return *x.refea059f34, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShadingRateImagePropertiesNV) Deref() {
	if x.refea059f34 == nil {
		return
	}
	x.SType = (StructureType)(x.refea059f34.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refea059f34.pNext))
	x.ShadingRateTexelSize = *NewExtent2DRef(unsafe.Pointer(&x.refea059f34.shadingRateTexelSize))
	x.ShadingRatePaletteSize = (uint32)(x.refea059f34.shadingRatePaletteSize)
	x.ShadingRateMaxCoarseSamples = (uint32)(x.refea059f34.shadingRateMaxCoarseSamples)
}

// allocCoarseSampleLocationNVMemory allocates memory for type C.VkCoarseSampleLocationNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCoarseSampleLocationNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCoarseSampleLocationNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCoarseSampleLocationNVValue = unsafe.Sizeof([1]C.VkCoarseSampleLocationNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CoarseSampleLocationNV) Ref() *C.VkCoarseSampleLocationNV {
	if x == nil {
		return nil
	}
	return x.ref2f447beb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CoarseSampleLocationNV) Free() {
	if x != nil && x.allocs2f447beb != nil {
		x.allocs2f447beb.(*cgoAllocMap).Free()
		x.ref2f447beb = nil
	}
}

// NewCoarseSampleLocationNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCoarseSampleLocationNVRef(ref unsafe.Pointer) *CoarseSampleLocationNV {
	if ref == nil {
		return nil
	}
	obj := new(CoarseSampleLocationNV)
	obj.ref2f447beb = (*C.VkCoarseSampleLocationNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CoarseSampleLocationNV) PassRef() (*C.VkCoarseSampleLocationNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f447beb != nil {
		return x.ref2f447beb, nil
	}
	mem2f447beb := allocCoarseSampleLocationNVMemory(1)
	ref2f447beb := (*C.VkCoarseSampleLocationNV)(mem2f447beb)
	allocs2f447beb := new(cgoAllocMap)
	allocs2f447beb.Add(mem2f447beb)

	var cpixelX_allocs *cgoAllocMap
	ref2f447beb.pixelX, cpixelX_allocs = (C.uint32_t)(x.PixelX), cgoAllocsUnknown
	allocs2f447beb.Borrow(cpixelX_allocs)

	var cpixelY_allocs *cgoAllocMap
	ref2f447beb.pixelY, cpixelY_allocs = (C.uint32_t)(x.PixelY), cgoAllocsUnknown
	allocs2f447beb.Borrow(cpixelY_allocs)

	var csample_allocs *cgoAllocMap
	ref2f447beb.sample, csample_allocs = (C.uint32_t)(x.Sample), cgoAllocsUnknown
	allocs2f447beb.Borrow(csample_allocs)

	x.ref2f447beb = ref2f447beb
	x.allocs2f447beb = allocs2f447beb
	return ref2f447beb, allocs2f447beb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CoarseSampleLocationNV) PassValue() (C.VkCoarseSampleLocationNV, *cgoAllocMap) {
	if x.ref2f447beb != nil {
		return *x.ref2f447beb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CoarseSampleLocationNV) Deref() {
	if x.ref2f447beb == nil {
		return
	}
	x.PixelX = (uint32)(x.ref2f447beb.pixelX)
	x.PixelY = (uint32)(x.ref2f447beb.pixelY)
	x.Sample = (uint32)(x.ref2f447beb.sample)
}

// allocCoarseSampleOrderCustomNVMemory allocates memory for type C.VkCoarseSampleOrderCustomNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCoarseSampleOrderCustomNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCoarseSampleOrderCustomNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCoarseSampleOrderCustomNVValue = unsafe.Sizeof([1]C.VkCoarseSampleOrderCustomNV{})

// unpackSCoarseSampleLocationNV transforms a sliced Go data structure into plain C format.
func unpackSCoarseSampleLocationNV(x []CoarseSampleLocationNV) (unpacked *C.VkCoarseSampleLocationNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkCoarseSampleLocationNV) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCoarseSampleLocationNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCoarseSampleLocationNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCoarseSampleLocationNV)(h.Data)
	return
}

// packSCoarseSampleLocationNV reads sliced Go data structure out from plain C format.
func packSCoarseSampleLocationNV(v []CoarseSampleLocationNV, ptr0 *C.VkCoarseSampleLocationNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCoarseSampleLocationNVValue]C.VkCoarseSampleLocationNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCoarseSampleLocationNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CoarseSampleOrderCustomNV) Ref() *C.VkCoarseSampleOrderCustomNV {
	if x == nil {
		return nil
	}
	return x.ref4524fa09
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CoarseSampleOrderCustomNV) Free() {
	if x != nil && x.allocs4524fa09 != nil {
		x.allocs4524fa09.(*cgoAllocMap).Free()
		x.ref4524fa09 = nil
	}
}

// NewCoarseSampleOrderCustomNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCoarseSampleOrderCustomNVRef(ref unsafe.Pointer) *CoarseSampleOrderCustomNV {
	if ref == nil {
		return nil
	}
	obj := new(CoarseSampleOrderCustomNV)
	obj.ref4524fa09 = (*C.VkCoarseSampleOrderCustomNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CoarseSampleOrderCustomNV) PassRef() (*C.VkCoarseSampleOrderCustomNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4524fa09 != nil {
		return x.ref4524fa09, nil
	}
	mem4524fa09 := allocCoarseSampleOrderCustomNVMemory(1)
	ref4524fa09 := (*C.VkCoarseSampleOrderCustomNV)(mem4524fa09)
	allocs4524fa09 := new(cgoAllocMap)
	allocs4524fa09.Add(mem4524fa09)

	var cshadingRate_allocs *cgoAllocMap
	ref4524fa09.shadingRate, cshadingRate_allocs = (C.VkShadingRatePaletteEntryNV)(x.ShadingRate), cgoAllocsUnknown
	allocs4524fa09.Borrow(cshadingRate_allocs)

	var csampleCount_allocs *cgoAllocMap
	ref4524fa09.sampleCount, csampleCount_allocs = (C.uint32_t)(x.SampleCount), cgoAllocsUnknown
	allocs4524fa09.Borrow(csampleCount_allocs)

	var csampleLocationCount_allocs *cgoAllocMap
	ref4524fa09.sampleLocationCount, csampleLocationCount_allocs = (C.uint32_t)(x.SampleLocationCount), cgoAllocsUnknown
	allocs4524fa09.Borrow(csampleLocationCount_allocs)

	var cpSampleLocations_allocs *cgoAllocMap
	ref4524fa09.pSampleLocations, cpSampleLocations_allocs = unpackSCoarseSampleLocationNV(x.PSampleLocations)
	allocs4524fa09.Borrow(cpSampleLocations_allocs)

	x.ref4524fa09 = ref4524fa09
	x.allocs4524fa09 = allocs4524fa09
	return ref4524fa09, allocs4524fa09

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CoarseSampleOrderCustomNV) PassValue() (C.VkCoarseSampleOrderCustomNV, *cgoAllocMap) {
	if x.ref4524fa09 != nil {
		return *x.ref4524fa09, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CoarseSampleOrderCustomNV) Deref() {
	if x.ref4524fa09 == nil {
		return
	}
	x.ShadingRate = (ShadingRatePaletteEntryNV)(x.ref4524fa09.shadingRate)
	x.SampleCount = (uint32)(x.ref4524fa09.sampleCount)
	x.SampleLocationCount = (uint32)(x.ref4524fa09.sampleLocationCount)
	packSCoarseSampleLocationNV(x.PSampleLocations, x.ref4524fa09.pSampleLocations)
}

// allocPipelineViewportCoarseSampleOrderStateCreateInfoNVMemory allocates memory for type C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportCoarseSampleOrderStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportCoarseSampleOrderStateCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineViewportCoarseSampleOrderStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV{})

// unpackSCoarseSampleOrderCustomNV transforms a sliced Go data structure into plain C format.
func unpackSCoarseSampleOrderCustomNV(x []CoarseSampleOrderCustomNV) (unpacked *C.VkCoarseSampleOrderCustomNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkCoarseSampleOrderCustomNV) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCoarseSampleOrderCustomNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCoarseSampleOrderCustomNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCoarseSampleOrderCustomNV)(h.Data)
	return
}

// packSCoarseSampleOrderCustomNV reads sliced Go data structure out from plain C format.
func packSCoarseSampleOrderCustomNV(v []CoarseSampleOrderCustomNV, ptr0 *C.VkCoarseSampleOrderCustomNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCoarseSampleOrderCustomNVValue]C.VkCoarseSampleOrderCustomNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCoarseSampleOrderCustomNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportCoarseSampleOrderStateCreateInfoNV) Ref() *C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref54de8ca6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportCoarseSampleOrderStateCreateInfoNV) Free() {
	if x != nil && x.allocs54de8ca6 != nil {
		x.allocs54de8ca6.(*cgoAllocMap).Free()
		x.ref54de8ca6 = nil
	}
}

// NewPipelineViewportCoarseSampleOrderStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportCoarseSampleOrderStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineViewportCoarseSampleOrderStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportCoarseSampleOrderStateCreateInfoNV)
	obj.ref54de8ca6 = (*C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportCoarseSampleOrderStateCreateInfoNV) PassRef() (*C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref54de8ca6 != nil {
		return x.ref54de8ca6, nil
	}
	mem54de8ca6 := allocPipelineViewportCoarseSampleOrderStateCreateInfoNVMemory(1)
	ref54de8ca6 := (*C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV)(mem54de8ca6)
	allocs54de8ca6 := new(cgoAllocMap)
	allocs54de8ca6.Add(mem54de8ca6)

	var csType_allocs *cgoAllocMap
	ref54de8ca6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs54de8ca6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref54de8ca6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs54de8ca6.Borrow(cpNext_allocs)

	var csampleOrderType_allocs *cgoAllocMap
	ref54de8ca6.sampleOrderType, csampleOrderType_allocs = (C.VkCoarseSampleOrderTypeNV)(x.SampleOrderType), cgoAllocsUnknown
	allocs54de8ca6.Borrow(csampleOrderType_allocs)

	var ccustomSampleOrderCount_allocs *cgoAllocMap
	ref54de8ca6.customSampleOrderCount, ccustomSampleOrderCount_allocs = (C.uint32_t)(x.CustomSampleOrderCount), cgoAllocsUnknown
	allocs54de8ca6.Borrow(ccustomSampleOrderCount_allocs)

	var cpCustomSampleOrders_allocs *cgoAllocMap
	ref54de8ca6.pCustomSampleOrders, cpCustomSampleOrders_allocs = unpackSCoarseSampleOrderCustomNV(x.PCustomSampleOrders)
	allocs54de8ca6.Borrow(cpCustomSampleOrders_allocs)

	x.ref54de8ca6 = ref54de8ca6
	x.allocs54de8ca6 = allocs54de8ca6
	return ref54de8ca6, allocs54de8ca6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportCoarseSampleOrderStateCreateInfoNV) PassValue() (C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, *cgoAllocMap) {
	if x.ref54de8ca6 != nil {
		return *x.ref54de8ca6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportCoarseSampleOrderStateCreateInfoNV) Deref() {
	if x.ref54de8ca6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref54de8ca6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref54de8ca6.pNext))
	x.SampleOrderType = (CoarseSampleOrderTypeNV)(x.ref54de8ca6.sampleOrderType)
	x.CustomSampleOrderCount = (uint32)(x.ref54de8ca6.customSampleOrderCount)
	packSCoarseSampleOrderCustomNV(x.PCustomSampleOrders, x.ref54de8ca6.pCustomSampleOrders)
}

// allocRaytracingPipelineCreateInfoNVXMemory allocates memory for type C.VkRaytracingPipelineCreateInfoNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRaytracingPipelineCreateInfoNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRaytracingPipelineCreateInfoNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRaytracingPipelineCreateInfoNVXValue = unsafe.Sizeof([1]C.VkRaytracingPipelineCreateInfoNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RaytracingPipelineCreateInfoNVX) Ref() *C.VkRaytracingPipelineCreateInfoNVX {
	if x == nil {
		return nil
	}
	return x.ref4d91852a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RaytracingPipelineCreateInfoNVX) Free() {
	if x != nil && x.allocs4d91852a != nil {
		x.allocs4d91852a.(*cgoAllocMap).Free()
		x.ref4d91852a = nil
	}
}

// NewRaytracingPipelineCreateInfoNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRaytracingPipelineCreateInfoNVXRef(ref unsafe.Pointer) *RaytracingPipelineCreateInfoNVX {
	if ref == nil {
		return nil
	}
	obj := new(RaytracingPipelineCreateInfoNVX)
	obj.ref4d91852a = (*C.VkRaytracingPipelineCreateInfoNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RaytracingPipelineCreateInfoNVX) PassRef() (*C.VkRaytracingPipelineCreateInfoNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4d91852a != nil {
		return x.ref4d91852a, nil
	}
	mem4d91852a := allocRaytracingPipelineCreateInfoNVXMemory(1)
	ref4d91852a := (*C.VkRaytracingPipelineCreateInfoNVX)(mem4d91852a)
	allocs4d91852a := new(cgoAllocMap)
	allocs4d91852a.Add(mem4d91852a)

	var csType_allocs *cgoAllocMap
	ref4d91852a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs4d91852a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref4d91852a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs4d91852a.Borrow(cpNext_allocs)

	var cflags_allocs *cgoAllocMap
	ref4d91852a.flags, cflags_allocs = (C.VkPipelineCreateFlags)(x.Flags), cgoAllocsUnknown
	allocs4d91852a.Borrow(cflags_allocs)

	var cstageCount_allocs *cgoAllocMap
	ref4d91852a.stageCount, cstageCount_allocs = (C.uint32_t)(x.StageCount), cgoAllocsUnknown
	allocs4d91852a.Borrow(cstageCount_allocs)

	var cpStages_allocs *cgoAllocMap
	ref4d91852a.pStages, cpStages_allocs = unpackSPipelineShaderStageCreateInfo(x.PStages)
	allocs4d91852a.Borrow(cpStages_allocs)

	var cpGroupNumbers_allocs *cgoAllocMap
	ref4d91852a.pGroupNumbers, cpGroupNumbers_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PGroupNumbers)).Data)), cgoAllocsUnknown
	allocs4d91852a.Borrow(cpGroupNumbers_allocs)

	var cmaxRecursionDepth_allocs *cgoAllocMap
	ref4d91852a.maxRecursionDepth, cmaxRecursionDepth_allocs = (C.uint32_t)(x.MaxRecursionDepth), cgoAllocsUnknown
	allocs4d91852a.Borrow(cmaxRecursionDepth_allocs)

	var clayout_allocs *cgoAllocMap
	ref4d91852a.layout, clayout_allocs = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.Layout)), cgoAllocsUnknown
	allocs4d91852a.Borrow(clayout_allocs)

	var cbasePipelineHandle_allocs *cgoAllocMap
	ref4d91852a.basePipelineHandle, cbasePipelineHandle_allocs = *(*C.VkPipeline)(unsafe.Pointer(&x.BasePipelineHandle)), cgoAllocsUnknown
	allocs4d91852a.Borrow(cbasePipelineHandle_allocs)

	var cbasePipelineIndex_allocs *cgoAllocMap
	ref4d91852a.basePipelineIndex, cbasePipelineIndex_allocs = (C.int32_t)(x.BasePipelineIndex), cgoAllocsUnknown
	allocs4d91852a.Borrow(cbasePipelineIndex_allocs)

	x.ref4d91852a = ref4d91852a
	x.allocs4d91852a = allocs4d91852a
	return ref4d91852a, allocs4d91852a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RaytracingPipelineCreateInfoNVX) PassValue() (C.VkRaytracingPipelineCreateInfoNVX, *cgoAllocMap) {
	if x.ref4d91852a != nil {
		return *x.ref4d91852a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RaytracingPipelineCreateInfoNVX) Deref() {
	if x.ref4d91852a == nil {
		return
	}
	x.SType = (StructureType)(x.ref4d91852a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4d91852a.pNext))
	x.Flags = (PipelineCreateFlags)(x.ref4d91852a.flags)
	x.StageCount = (uint32)(x.ref4d91852a.stageCount)
	packSPipelineShaderStageCreateInfo(x.PStages, x.ref4d91852a.pStages)
	hxf9aab83 := (*sliceHeader)(unsafe.Pointer(&x.PGroupNumbers))
	hxf9aab83.Data = unsafe.Pointer(x.ref4d91852a.pGroupNumbers)
	hxf9aab83.Cap = 0x7fffffff
	// hxf9aab83.Len = ?

	x.MaxRecursionDepth = (uint32)(x.ref4d91852a.maxRecursionDepth)
	x.Layout = *(*PipelineLayout)(unsafe.Pointer(&x.ref4d91852a.layout))
	x.BasePipelineHandle = *(*Pipeline)(unsafe.Pointer(&x.ref4d91852a.basePipelineHandle))
	x.BasePipelineIndex = (int32)(x.ref4d91852a.basePipelineIndex)
}

// allocGeometryTrianglesNVXMemory allocates memory for type C.VkGeometryTrianglesNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGeometryTrianglesNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGeometryTrianglesNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGeometryTrianglesNVXValue = unsafe.Sizeof([1]C.VkGeometryTrianglesNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GeometryTrianglesNVX) Ref() *C.VkGeometryTrianglesNVX {
	if x == nil {
		return nil
	}
	return x.ref5c3b4de9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GeometryTrianglesNVX) Free() {
	if x != nil && x.allocs5c3b4de9 != nil {
		x.allocs5c3b4de9.(*cgoAllocMap).Free()
		x.ref5c3b4de9 = nil
	}
}

// NewGeometryTrianglesNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGeometryTrianglesNVXRef(ref unsafe.Pointer) *GeometryTrianglesNVX {
	if ref == nil {
		return nil
	}
	obj := new(GeometryTrianglesNVX)
	obj.ref5c3b4de9 = (*C.VkGeometryTrianglesNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GeometryTrianglesNVX) PassRef() (*C.VkGeometryTrianglesNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5c3b4de9 != nil {
		return x.ref5c3b4de9, nil
	}
	mem5c3b4de9 := allocGeometryTrianglesNVXMemory(1)
	ref5c3b4de9 := (*C.VkGeometryTrianglesNVX)(mem5c3b4de9)
	allocs5c3b4de9 := new(cgoAllocMap)
	allocs5c3b4de9.Add(mem5c3b4de9)

	var csType_allocs *cgoAllocMap
	ref5c3b4de9.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5c3b4de9.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5c3b4de9.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5c3b4de9.Borrow(cpNext_allocs)

	var cvertexData_allocs *cgoAllocMap
	ref5c3b4de9.vertexData, cvertexData_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.VertexData)), cgoAllocsUnknown
	allocs5c3b4de9.Borrow(cvertexData_allocs)

	var cvertexOffset_allocs *cgoAllocMap
	ref5c3b4de9.vertexOffset, cvertexOffset_allocs = (C.VkDeviceSize)(x.VertexOffset), cgoAllocsUnknown
	allocs5c3b4de9.Borrow(cvertexOffset_allocs)

	var cvertexCount_allocs *cgoAllocMap
	ref5c3b4de9.vertexCount, cvertexCount_allocs = (C.uint32_t)(x.VertexCount), cgoAllocsUnknown
	allocs5c3b4de9.Borrow(cvertexCount_allocs)

	var cvertexStride_allocs *cgoAllocMap
	ref5c3b4de9.vertexStride, cvertexStride_allocs = (C.VkDeviceSize)(x.VertexStride), cgoAllocsUnknown
	allocs5c3b4de9.Borrow(cvertexStride_allocs)

	var cvertexFormat_allocs *cgoAllocMap
	ref5c3b4de9.vertexFormat, cvertexFormat_allocs = (C.VkFormat)(x.VertexFormat), cgoAllocsUnknown
	allocs5c3b4de9.Borrow(cvertexFormat_allocs)

	var cindexData_allocs *cgoAllocMap
	ref5c3b4de9.indexData, cindexData_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.IndexData)), cgoAllocsUnknown
	allocs5c3b4de9.Borrow(cindexData_allocs)

	var cindexOffset_allocs *cgoAllocMap
	ref5c3b4de9.indexOffset, cindexOffset_allocs = (C.VkDeviceSize)(x.IndexOffset), cgoAllocsUnknown
	allocs5c3b4de9.Borrow(cindexOffset_allocs)

	var cindexCount_allocs *cgoAllocMap
	ref5c3b4de9.indexCount, cindexCount_allocs = (C.uint32_t)(x.IndexCount), cgoAllocsUnknown
	allocs5c3b4de9.Borrow(cindexCount_allocs)

	var cindexType_allocs *cgoAllocMap
	ref5c3b4de9.indexType, cindexType_allocs = (C.VkIndexType)(x.IndexType), cgoAllocsUnknown
	allocs5c3b4de9.Borrow(cindexType_allocs)

	var ctransformData_allocs *cgoAllocMap
	ref5c3b4de9.transformData, ctransformData_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.TransformData)), cgoAllocsUnknown
	allocs5c3b4de9.Borrow(ctransformData_allocs)

	var ctransformOffset_allocs *cgoAllocMap
	ref5c3b4de9.transformOffset, ctransformOffset_allocs = (C.VkDeviceSize)(x.TransformOffset), cgoAllocsUnknown
	allocs5c3b4de9.Borrow(ctransformOffset_allocs)

	x.ref5c3b4de9 = ref5c3b4de9
	x.allocs5c3b4de9 = allocs5c3b4de9
	return ref5c3b4de9, allocs5c3b4de9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GeometryTrianglesNVX) PassValue() (C.VkGeometryTrianglesNVX, *cgoAllocMap) {
	if x.ref5c3b4de9 != nil {
		return *x.ref5c3b4de9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GeometryTrianglesNVX) Deref() {
	if x.ref5c3b4de9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5c3b4de9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5c3b4de9.pNext))
	x.VertexData = *(*Buffer)(unsafe.Pointer(&x.ref5c3b4de9.vertexData))
	x.VertexOffset = (DeviceSize)(x.ref5c3b4de9.vertexOffset)
	x.VertexCount = (uint32)(x.ref5c3b4de9.vertexCount)
	x.VertexStride = (DeviceSize)(x.ref5c3b4de9.vertexStride)
	x.VertexFormat = (Format)(x.ref5c3b4de9.vertexFormat)
	x.IndexData = *(*Buffer)(unsafe.Pointer(&x.ref5c3b4de9.indexData))
	x.IndexOffset = (DeviceSize)(x.ref5c3b4de9.indexOffset)
	x.IndexCount = (uint32)(x.ref5c3b4de9.indexCount)
	x.IndexType = (IndexType)(x.ref5c3b4de9.indexType)
	x.TransformData = *(*Buffer)(unsafe.Pointer(&x.ref5c3b4de9.transformData))
	x.TransformOffset = (DeviceSize)(x.ref5c3b4de9.transformOffset)
}

// allocGeometryAABBNVXMemory allocates memory for type C.VkGeometryAABBNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGeometryAABBNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGeometryAABBNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGeometryAABBNVXValue = unsafe.Sizeof([1]C.VkGeometryAABBNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GeometryAABBNVX) Ref() *C.VkGeometryAABBNVX {
	if x == nil {
		return nil
	}
	return x.reff4c42a9d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GeometryAABBNVX) Free() {
	if x != nil && x.allocsf4c42a9d != nil {
		x.allocsf4c42a9d.(*cgoAllocMap).Free()
		x.reff4c42a9d = nil
	}
}

// NewGeometryAABBNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGeometryAABBNVXRef(ref unsafe.Pointer) *GeometryAABBNVX {
	if ref == nil {
		return nil
	}
	obj := new(GeometryAABBNVX)
	obj.reff4c42a9d = (*C.VkGeometryAABBNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GeometryAABBNVX) PassRef() (*C.VkGeometryAABBNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff4c42a9d != nil {
		return x.reff4c42a9d, nil
	}
	memf4c42a9d := allocGeometryAABBNVXMemory(1)
	reff4c42a9d := (*C.VkGeometryAABBNVX)(memf4c42a9d)
	allocsf4c42a9d := new(cgoAllocMap)
	allocsf4c42a9d.Add(memf4c42a9d)

	var csType_allocs *cgoAllocMap
	reff4c42a9d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf4c42a9d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff4c42a9d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf4c42a9d.Borrow(cpNext_allocs)

	var caabbData_allocs *cgoAllocMap
	reff4c42a9d.aabbData, caabbData_allocs = *(*C.VkBuffer)(unsafe.Pointer(&x.AabbData)), cgoAllocsUnknown
	allocsf4c42a9d.Borrow(caabbData_allocs)

	var cnumAABBs_allocs *cgoAllocMap
	reff4c42a9d.numAABBs, cnumAABBs_allocs = (C.uint32_t)(x.NumAABBs), cgoAllocsUnknown
	allocsf4c42a9d.Borrow(cnumAABBs_allocs)

	var cstride_allocs *cgoAllocMap
	reff4c42a9d.stride, cstride_allocs = (C.uint32_t)(x.Stride), cgoAllocsUnknown
	allocsf4c42a9d.Borrow(cstride_allocs)

	var coffset_allocs *cgoAllocMap
	reff4c42a9d.offset, coffset_allocs = (C.VkDeviceSize)(x.Offset), cgoAllocsUnknown
	allocsf4c42a9d.Borrow(coffset_allocs)

	x.reff4c42a9d = reff4c42a9d
	x.allocsf4c42a9d = allocsf4c42a9d
	return reff4c42a9d, allocsf4c42a9d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GeometryAABBNVX) PassValue() (C.VkGeometryAABBNVX, *cgoAllocMap) {
	if x.reff4c42a9d != nil {
		return *x.reff4c42a9d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GeometryAABBNVX) Deref() {
	if x.reff4c42a9d == nil {
		return
	}
	x.SType = (StructureType)(x.reff4c42a9d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff4c42a9d.pNext))
	x.AabbData = *(*Buffer)(unsafe.Pointer(&x.reff4c42a9d.aabbData))
	x.NumAABBs = (uint32)(x.reff4c42a9d.numAABBs)
	x.Stride = (uint32)(x.reff4c42a9d.stride)
	x.Offset = (DeviceSize)(x.reff4c42a9d.offset)
}

// allocGeometryDataNVXMemory allocates memory for type C.VkGeometryDataNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGeometryDataNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGeometryDataNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGeometryDataNVXValue = unsafe.Sizeof([1]C.VkGeometryDataNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GeometryDataNVX) Ref() *C.VkGeometryDataNVX {
	if x == nil {
		return nil
	}
	return x.ref3db64dfa
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GeometryDataNVX) Free() {
	if x != nil && x.allocs3db64dfa != nil {
		x.allocs3db64dfa.(*cgoAllocMap).Free()
		x.ref3db64dfa = nil
	}
}

// NewGeometryDataNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGeometryDataNVXRef(ref unsafe.Pointer) *GeometryDataNVX {
	if ref == nil {
		return nil
	}
	obj := new(GeometryDataNVX)
	obj.ref3db64dfa = (*C.VkGeometryDataNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GeometryDataNVX) PassRef() (*C.VkGeometryDataNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3db64dfa != nil {
		return x.ref3db64dfa, nil
	}
	mem3db64dfa := allocGeometryDataNVXMemory(1)
	ref3db64dfa := (*C.VkGeometryDataNVX)(mem3db64dfa)
	allocs3db64dfa := new(cgoAllocMap)
	allocs3db64dfa.Add(mem3db64dfa)

	var ctriangles_allocs *cgoAllocMap
	ref3db64dfa.triangles, ctriangles_allocs = x.Triangles.PassValue()
	allocs3db64dfa.Borrow(ctriangles_allocs)

	var caabbs_allocs *cgoAllocMap
	ref3db64dfa.aabbs, caabbs_allocs = x.Aabbs.PassValue()
	allocs3db64dfa.Borrow(caabbs_allocs)

	x.ref3db64dfa = ref3db64dfa
	x.allocs3db64dfa = allocs3db64dfa
	return ref3db64dfa, allocs3db64dfa

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GeometryDataNVX) PassValue() (C.VkGeometryDataNVX, *cgoAllocMap) {
	if x.ref3db64dfa != nil {
		return *x.ref3db64dfa, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GeometryDataNVX) Deref() {
	if x.ref3db64dfa == nil {
		return
	}
	x.Triangles = *NewGeometryTrianglesNVXRef(unsafe.Pointer(&x.ref3db64dfa.triangles))
	x.Aabbs = *NewGeometryAABBNVXRef(unsafe.Pointer(&x.ref3db64dfa.aabbs))
}

// allocGeometryNVXMemory allocates memory for type C.VkGeometryNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGeometryNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGeometryNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGeometryNVXValue = unsafe.Sizeof([1]C.VkGeometryNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GeometryNVX) Ref() *C.VkGeometryNVX {
	if x == nil {
		return nil
	}
	return x.refd01fad9d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GeometryNVX) Free() {
	if x != nil && x.allocsd01fad9d != nil {
		x.allocsd01fad9d.(*cgoAllocMap).Free()
		x.refd01fad9d = nil
	}
}

// NewGeometryNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGeometryNVXRef(ref unsafe.Pointer) *GeometryNVX {
	if ref == nil {
		return nil
	}
	obj := new(GeometryNVX)
	obj.refd01fad9d = (*C.VkGeometryNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GeometryNVX) PassRef() (*C.VkGeometryNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd01fad9d != nil {
		return x.refd01fad9d, nil
	}
	memd01fad9d := allocGeometryNVXMemory(1)
	refd01fad9d := (*C.VkGeometryNVX)(memd01fad9d)
	allocsd01fad9d := new(cgoAllocMap)
	allocsd01fad9d.Add(memd01fad9d)

	var csType_allocs *cgoAllocMap
	refd01fad9d.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd01fad9d.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd01fad9d.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd01fad9d.Borrow(cpNext_allocs)

	var cgeometryType_allocs *cgoAllocMap
	refd01fad9d.geometryType, cgeometryType_allocs = (C.VkGeometryTypeNVX)(x.GeometryType), cgoAllocsUnknown
	allocsd01fad9d.Borrow(cgeometryType_allocs)

	var cgeometry_allocs *cgoAllocMap
	refd01fad9d.geometry, cgeometry_allocs = x.Geometry.PassValue()
	allocsd01fad9d.Borrow(cgeometry_allocs)

	var cflags_allocs *cgoAllocMap
	refd01fad9d.flags, cflags_allocs = (C.VkGeometryFlagsNVX)(x.Flags), cgoAllocsUnknown
	allocsd01fad9d.Borrow(cflags_allocs)

	x.refd01fad9d = refd01fad9d
	x.allocsd01fad9d = allocsd01fad9d
	return refd01fad9d, allocsd01fad9d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GeometryNVX) PassValue() (C.VkGeometryNVX, *cgoAllocMap) {
	if x.refd01fad9d != nil {
		return *x.refd01fad9d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GeometryNVX) Deref() {
	if x.refd01fad9d == nil {
		return
	}
	x.SType = (StructureType)(x.refd01fad9d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd01fad9d.pNext))
	x.GeometryType = (GeometryTypeNVX)(x.refd01fad9d.geometryType)
	x.Geometry = *NewGeometryDataNVXRef(unsafe.Pointer(&x.refd01fad9d.geometry))
	x.Flags = (GeometryFlagsNVX)(x.refd01fad9d.flags)
}

// allocAccelerationStructureCreateInfoNVXMemory allocates memory for type C.VkAccelerationStructureCreateInfoNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureCreateInfoNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureCreateInfoNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAccelerationStructureCreateInfoNVXValue = unsafe.Sizeof([1]C.VkAccelerationStructureCreateInfoNVX{})

// unpackSGeometryNVX transforms a sliced Go data structure into plain C format.
func unpackSGeometryNVX(x []GeometryNVX) (unpacked *C.VkGeometryNVX, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkGeometryNVX) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocGeometryNVXMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkGeometryNVX)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkGeometryNVX)(h.Data)
	return
}

// packSGeometryNVX reads sliced Go data structure out from plain C format.
func packSGeometryNVX(v []GeometryNVX, ptr0 *C.VkGeometryNVX) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfGeometryNVXValue]C.VkGeometryNVX)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewGeometryNVXRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AccelerationStructureCreateInfoNVX) Ref() *C.VkAccelerationStructureCreateInfoNVX {
	if x == nil {
		return nil
	}
	return x.ref1289fd56
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AccelerationStructureCreateInfoNVX) Free() {
	if x != nil && x.allocs1289fd56 != nil {
		x.allocs1289fd56.(*cgoAllocMap).Free()
		x.ref1289fd56 = nil
	}
}

// NewAccelerationStructureCreateInfoNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAccelerationStructureCreateInfoNVXRef(ref unsafe.Pointer) *AccelerationStructureCreateInfoNVX {
	if ref == nil {
		return nil
	}
	obj := new(AccelerationStructureCreateInfoNVX)
	obj.ref1289fd56 = (*C.VkAccelerationStructureCreateInfoNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AccelerationStructureCreateInfoNVX) PassRef() (*C.VkAccelerationStructureCreateInfoNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1289fd56 != nil {
		return x.ref1289fd56, nil
	}
	mem1289fd56 := allocAccelerationStructureCreateInfoNVXMemory(1)
	ref1289fd56 := (*C.VkAccelerationStructureCreateInfoNVX)(mem1289fd56)
	allocs1289fd56 := new(cgoAllocMap)
	allocs1289fd56.Add(mem1289fd56)

	var csType_allocs *cgoAllocMap
	ref1289fd56.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs1289fd56.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref1289fd56.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs1289fd56.Borrow(cpNext_allocs)

	var c_type_allocs *cgoAllocMap
	ref1289fd56._type, c_type_allocs = (C.VkAccelerationStructureTypeNVX)(x.Type), cgoAllocsUnknown
	allocs1289fd56.Borrow(c_type_allocs)

	var cflags_allocs *cgoAllocMap
	ref1289fd56.flags, cflags_allocs = (C.VkBuildAccelerationStructureFlagsNVX)(x.Flags), cgoAllocsUnknown
	allocs1289fd56.Borrow(cflags_allocs)

	var ccompactedSize_allocs *cgoAllocMap
	ref1289fd56.compactedSize, ccompactedSize_allocs = (C.VkDeviceSize)(x.CompactedSize), cgoAllocsUnknown
	allocs1289fd56.Borrow(ccompactedSize_allocs)

	var cinstanceCount_allocs *cgoAllocMap
	ref1289fd56.instanceCount, cinstanceCount_allocs = (C.uint32_t)(x.InstanceCount), cgoAllocsUnknown
	allocs1289fd56.Borrow(cinstanceCount_allocs)

	var cgeometryCount_allocs *cgoAllocMap
	ref1289fd56.geometryCount, cgeometryCount_allocs = (C.uint32_t)(x.GeometryCount), cgoAllocsUnknown
	allocs1289fd56.Borrow(cgeometryCount_allocs)

	var cpGeometries_allocs *cgoAllocMap
	ref1289fd56.pGeometries, cpGeometries_allocs = unpackSGeometryNVX(x.PGeometries)
	allocs1289fd56.Borrow(cpGeometries_allocs)

	x.ref1289fd56 = ref1289fd56
	x.allocs1289fd56 = allocs1289fd56
	return ref1289fd56, allocs1289fd56

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AccelerationStructureCreateInfoNVX) PassValue() (C.VkAccelerationStructureCreateInfoNVX, *cgoAllocMap) {
	if x.ref1289fd56 != nil {
		return *x.ref1289fd56, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AccelerationStructureCreateInfoNVX) Deref() {
	if x.ref1289fd56 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1289fd56.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1289fd56.pNext))
	x.Type = (AccelerationStructureTypeNVX)(x.ref1289fd56._type)
	x.Flags = (BuildAccelerationStructureFlagsNVX)(x.ref1289fd56.flags)
	x.CompactedSize = (DeviceSize)(x.ref1289fd56.compactedSize)
	x.InstanceCount = (uint32)(x.ref1289fd56.instanceCount)
	x.GeometryCount = (uint32)(x.ref1289fd56.geometryCount)
	packSGeometryNVX(x.PGeometries, x.ref1289fd56.pGeometries)
}

// allocBindAccelerationStructureMemoryInfoNVXMemory allocates memory for type C.VkBindAccelerationStructureMemoryInfoNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindAccelerationStructureMemoryInfoNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindAccelerationStructureMemoryInfoNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindAccelerationStructureMemoryInfoNVXValue = unsafe.Sizeof([1]C.VkBindAccelerationStructureMemoryInfoNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindAccelerationStructureMemoryInfoNVX) Ref() *C.VkBindAccelerationStructureMemoryInfoNVX {
	if x == nil {
		return nil
	}
	return x.refb92eae10
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindAccelerationStructureMemoryInfoNVX) Free() {
	if x != nil && x.allocsb92eae10 != nil {
		x.allocsb92eae10.(*cgoAllocMap).Free()
		x.refb92eae10 = nil
	}
}

// NewBindAccelerationStructureMemoryInfoNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindAccelerationStructureMemoryInfoNVXRef(ref unsafe.Pointer) *BindAccelerationStructureMemoryInfoNVX {
	if ref == nil {
		return nil
	}
	obj := new(BindAccelerationStructureMemoryInfoNVX)
	obj.refb92eae10 = (*C.VkBindAccelerationStructureMemoryInfoNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindAccelerationStructureMemoryInfoNVX) PassRef() (*C.VkBindAccelerationStructureMemoryInfoNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb92eae10 != nil {
		return x.refb92eae10, nil
	}
	memb92eae10 := allocBindAccelerationStructureMemoryInfoNVXMemory(1)
	refb92eae10 := (*C.VkBindAccelerationStructureMemoryInfoNVX)(memb92eae10)
	allocsb92eae10 := new(cgoAllocMap)
	allocsb92eae10.Add(memb92eae10)

	var csType_allocs *cgoAllocMap
	refb92eae10.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsb92eae10.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refb92eae10.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsb92eae10.Borrow(cpNext_allocs)

	var caccelerationStructure_allocs *cgoAllocMap
	refb92eae10.accelerationStructure, caccelerationStructure_allocs = *(*C.VkAccelerationStructureNVX)(unsafe.Pointer(&x.AccelerationStructure)), cgoAllocsUnknown
	allocsb92eae10.Borrow(caccelerationStructure_allocs)

	var cmemory_allocs *cgoAllocMap
	refb92eae10.memory, cmemory_allocs = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory)), cgoAllocsUnknown
	allocsb92eae10.Borrow(cmemory_allocs)

	var cmemoryOffset_allocs *cgoAllocMap
	refb92eae10.memoryOffset, cmemoryOffset_allocs = (C.VkDeviceSize)(x.MemoryOffset), cgoAllocsUnknown
	allocsb92eae10.Borrow(cmemoryOffset_allocs)

	var cdeviceIndexCount_allocs *cgoAllocMap
	refb92eae10.deviceIndexCount, cdeviceIndexCount_allocs = (C.uint32_t)(x.DeviceIndexCount), cgoAllocsUnknown
	allocsb92eae10.Borrow(cdeviceIndexCount_allocs)

	var cpDeviceIndices_allocs *cgoAllocMap
	refb92eae10.pDeviceIndices, cpDeviceIndices_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices)).Data)), cgoAllocsUnknown
	allocsb92eae10.Borrow(cpDeviceIndices_allocs)

	x.refb92eae10 = refb92eae10
	x.allocsb92eae10 = allocsb92eae10
	return refb92eae10, allocsb92eae10

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindAccelerationStructureMemoryInfoNVX) PassValue() (C.VkBindAccelerationStructureMemoryInfoNVX, *cgoAllocMap) {
	if x.refb92eae10 != nil {
		return *x.refb92eae10, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindAccelerationStructureMemoryInfoNVX) Deref() {
	if x.refb92eae10 == nil {
		return
	}
	x.SType = (StructureType)(x.refb92eae10.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb92eae10.pNext))
	x.AccelerationStructure = *(*AccelerationStructureNVX)(unsafe.Pointer(&x.refb92eae10.accelerationStructure))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.refb92eae10.memory))
	x.MemoryOffset = (DeviceSize)(x.refb92eae10.memoryOffset)
	x.DeviceIndexCount = (uint32)(x.refb92eae10.deviceIndexCount)
	hxf8b35a8 := (*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices))
	hxf8b35a8.Data = unsafe.Pointer(x.refb92eae10.pDeviceIndices)
	hxf8b35a8.Cap = 0x7fffffff
	// hxf8b35a8.Len = ?

}

// allocDescriptorAccelerationStructureInfoNVXMemory allocates memory for type C.VkDescriptorAccelerationStructureInfoNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorAccelerationStructureInfoNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorAccelerationStructureInfoNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorAccelerationStructureInfoNVXValue = unsafe.Sizeof([1]C.VkDescriptorAccelerationStructureInfoNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorAccelerationStructureInfoNVX) Ref() *C.VkDescriptorAccelerationStructureInfoNVX {
	if x == nil {
		return nil
	}
	return x.refde5f3ba5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorAccelerationStructureInfoNVX) Free() {
	if x != nil && x.allocsde5f3ba5 != nil {
		x.allocsde5f3ba5.(*cgoAllocMap).Free()
		x.refde5f3ba5 = nil
	}
}

// NewDescriptorAccelerationStructureInfoNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorAccelerationStructureInfoNVXRef(ref unsafe.Pointer) *DescriptorAccelerationStructureInfoNVX {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorAccelerationStructureInfoNVX)
	obj.refde5f3ba5 = (*C.VkDescriptorAccelerationStructureInfoNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorAccelerationStructureInfoNVX) PassRef() (*C.VkDescriptorAccelerationStructureInfoNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refde5f3ba5 != nil {
		return x.refde5f3ba5, nil
	}
	memde5f3ba5 := allocDescriptorAccelerationStructureInfoNVXMemory(1)
	refde5f3ba5 := (*C.VkDescriptorAccelerationStructureInfoNVX)(memde5f3ba5)
	allocsde5f3ba5 := new(cgoAllocMap)
	allocsde5f3ba5.Add(memde5f3ba5)

	var csType_allocs *cgoAllocMap
	refde5f3ba5.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsde5f3ba5.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refde5f3ba5.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsde5f3ba5.Borrow(cpNext_allocs)

	var caccelerationStructureCount_allocs *cgoAllocMap
	refde5f3ba5.accelerationStructureCount, caccelerationStructureCount_allocs = (C.uint32_t)(x.AccelerationStructureCount), cgoAllocsUnknown
	allocsde5f3ba5.Borrow(caccelerationStructureCount_allocs)

	var cpAccelerationStructures_allocs *cgoAllocMap
	refde5f3ba5.pAccelerationStructures, cpAccelerationStructures_allocs = (*C.VkAccelerationStructureNVX)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PAccelerationStructures)).Data)), cgoAllocsUnknown
	allocsde5f3ba5.Borrow(cpAccelerationStructures_allocs)

	x.refde5f3ba5 = refde5f3ba5
	x.allocsde5f3ba5 = allocsde5f3ba5
	return refde5f3ba5, allocsde5f3ba5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorAccelerationStructureInfoNVX) PassValue() (C.VkDescriptorAccelerationStructureInfoNVX, *cgoAllocMap) {
	if x.refde5f3ba5 != nil {
		return *x.refde5f3ba5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorAccelerationStructureInfoNVX) Deref() {
	if x.refde5f3ba5 == nil {
		return
	}
	x.SType = (StructureType)(x.refde5f3ba5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refde5f3ba5.pNext))
	x.AccelerationStructureCount = (uint32)(x.refde5f3ba5.accelerationStructureCount)
	hxf8959c2 := (*sliceHeader)(unsafe.Pointer(&x.PAccelerationStructures))
	hxf8959c2.Data = unsafe.Pointer(x.refde5f3ba5.pAccelerationStructures)
	hxf8959c2.Cap = 0x7fffffff
	// hxf8959c2.Len = ?

}

// allocAccelerationStructureMemoryRequirementsInfoNVXMemory allocates memory for type C.VkAccelerationStructureMemoryRequirementsInfoNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAccelerationStructureMemoryRequirementsInfoNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAccelerationStructureMemoryRequirementsInfoNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAccelerationStructureMemoryRequirementsInfoNVXValue = unsafe.Sizeof([1]C.VkAccelerationStructureMemoryRequirementsInfoNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AccelerationStructureMemoryRequirementsInfoNVX) Ref() *C.VkAccelerationStructureMemoryRequirementsInfoNVX {
	if x == nil {
		return nil
	}
	return x.ref212466e8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AccelerationStructureMemoryRequirementsInfoNVX) Free() {
	if x != nil && x.allocs212466e8 != nil {
		x.allocs212466e8.(*cgoAllocMap).Free()
		x.ref212466e8 = nil
	}
}

// NewAccelerationStructureMemoryRequirementsInfoNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAccelerationStructureMemoryRequirementsInfoNVXRef(ref unsafe.Pointer) *AccelerationStructureMemoryRequirementsInfoNVX {
	if ref == nil {
		return nil
	}
	obj := new(AccelerationStructureMemoryRequirementsInfoNVX)
	obj.ref212466e8 = (*C.VkAccelerationStructureMemoryRequirementsInfoNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AccelerationStructureMemoryRequirementsInfoNVX) PassRef() (*C.VkAccelerationStructureMemoryRequirementsInfoNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref212466e8 != nil {
		return x.ref212466e8, nil
	}
	mem212466e8 := allocAccelerationStructureMemoryRequirementsInfoNVXMemory(1)
	ref212466e8 := (*C.VkAccelerationStructureMemoryRequirementsInfoNVX)(mem212466e8)
	allocs212466e8 := new(cgoAllocMap)
	allocs212466e8.Add(mem212466e8)

	var csType_allocs *cgoAllocMap
	ref212466e8.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs212466e8.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref212466e8.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs212466e8.Borrow(cpNext_allocs)

	var caccelerationStructure_allocs *cgoAllocMap
	ref212466e8.accelerationStructure, caccelerationStructure_allocs = *(*C.VkAccelerationStructureNVX)(unsafe.Pointer(&x.AccelerationStructure)), cgoAllocsUnknown
	allocs212466e8.Borrow(caccelerationStructure_allocs)

	x.ref212466e8 = ref212466e8
	x.allocs212466e8 = allocs212466e8
	return ref212466e8, allocs212466e8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AccelerationStructureMemoryRequirementsInfoNVX) PassValue() (C.VkAccelerationStructureMemoryRequirementsInfoNVX, *cgoAllocMap) {
	if x.ref212466e8 != nil {
		return *x.ref212466e8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AccelerationStructureMemoryRequirementsInfoNVX) Deref() {
	if x.ref212466e8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref212466e8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref212466e8.pNext))
	x.AccelerationStructure = *(*AccelerationStructureNVX)(unsafe.Pointer(&x.ref212466e8.accelerationStructure))
}

// allocPhysicalDeviceRaytracingPropertiesNVXMemory allocates memory for type C.VkPhysicalDeviceRaytracingPropertiesNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceRaytracingPropertiesNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceRaytracingPropertiesNVXValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceRaytracingPropertiesNVXValue = unsafe.Sizeof([1]C.VkPhysicalDeviceRaytracingPropertiesNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceRaytracingPropertiesNVX) Ref() *C.VkPhysicalDeviceRaytracingPropertiesNVX {
	if x == nil {
		return nil
	}
	return x.refd37a6b69
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceRaytracingPropertiesNVX) Free() {
	if x != nil && x.allocsd37a6b69 != nil {
		x.allocsd37a6b69.(*cgoAllocMap).Free()
		x.refd37a6b69 = nil
	}
}

// NewPhysicalDeviceRaytracingPropertiesNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceRaytracingPropertiesNVXRef(ref unsafe.Pointer) *PhysicalDeviceRaytracingPropertiesNVX {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceRaytracingPropertiesNVX)
	obj.refd37a6b69 = (*C.VkPhysicalDeviceRaytracingPropertiesNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceRaytracingPropertiesNVX) PassRef() (*C.VkPhysicalDeviceRaytracingPropertiesNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd37a6b69 != nil {
		return x.refd37a6b69, nil
	}
	memd37a6b69 := allocPhysicalDeviceRaytracingPropertiesNVXMemory(1)
	refd37a6b69 := (*C.VkPhysicalDeviceRaytracingPropertiesNVX)(memd37a6b69)
	allocsd37a6b69 := new(cgoAllocMap)
	allocsd37a6b69.Add(memd37a6b69)

	var csType_allocs *cgoAllocMap
	refd37a6b69.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd37a6b69.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd37a6b69.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd37a6b69.Borrow(cpNext_allocs)

	var cshaderHeaderSize_allocs *cgoAllocMap
	refd37a6b69.shaderHeaderSize, cshaderHeaderSize_allocs = (C.uint32_t)(x.ShaderHeaderSize), cgoAllocsUnknown
	allocsd37a6b69.Borrow(cshaderHeaderSize_allocs)

	var cmaxRecursionDepth_allocs *cgoAllocMap
	refd37a6b69.maxRecursionDepth, cmaxRecursionDepth_allocs = (C.uint32_t)(x.MaxRecursionDepth), cgoAllocsUnknown
	allocsd37a6b69.Borrow(cmaxRecursionDepth_allocs)

	var cmaxGeometryCount_allocs *cgoAllocMap
	refd37a6b69.maxGeometryCount, cmaxGeometryCount_allocs = (C.uint32_t)(x.MaxGeometryCount), cgoAllocsUnknown
	allocsd37a6b69.Borrow(cmaxGeometryCount_allocs)

	x.refd37a6b69 = refd37a6b69
	x.allocsd37a6b69 = allocsd37a6b69
	return refd37a6b69, allocsd37a6b69

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceRaytracingPropertiesNVX) PassValue() (C.VkPhysicalDeviceRaytracingPropertiesNVX, *cgoAllocMap) {
	if x.refd37a6b69 != nil {
		return *x.refd37a6b69, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceRaytracingPropertiesNVX) Deref() {
	if x.refd37a6b69 == nil {
		return
	}
	x.SType = (StructureType)(x.refd37a6b69.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd37a6b69.pNext))
	x.ShaderHeaderSize = (uint32)(x.refd37a6b69.shaderHeaderSize)
	x.MaxRecursionDepth = (uint32)(x.refd37a6b69.maxRecursionDepth)
	x.MaxGeometryCount = (uint32)(x.refd37a6b69.maxGeometryCount)
}

// allocPhysicalDeviceRepresentativeFragmentTestFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceRepresentativeFragmentTestFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceRepresentativeFragmentTestFeaturesNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceRepresentativeFragmentTestFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceRepresentativeFragmentTestFeaturesNV) Ref() *C.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
	if x == nil {
		return nil
	}
	return x.reff1f69e03
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceRepresentativeFragmentTestFeaturesNV) Free() {
	if x != nil && x.allocsf1f69e03 != nil {
		x.allocsf1f69e03.(*cgoAllocMap).Free()
		x.reff1f69e03 = nil
	}
}

// NewPhysicalDeviceRepresentativeFragmentTestFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceRepresentativeFragmentTestFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceRepresentativeFragmentTestFeaturesNV)
	obj.reff1f69e03 = (*C.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceRepresentativeFragmentTestFeaturesNV) PassRef() (*C.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff1f69e03 != nil {
		return x.reff1f69e03, nil
	}
	memf1f69e03 := allocPhysicalDeviceRepresentativeFragmentTestFeaturesNVMemory(1)
	reff1f69e03 := (*C.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV)(memf1f69e03)
	allocsf1f69e03 := new(cgoAllocMap)
	allocsf1f69e03.Add(memf1f69e03)

	var csType_allocs *cgoAllocMap
	reff1f69e03.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf1f69e03.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff1f69e03.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf1f69e03.Borrow(cpNext_allocs)

	var crepresentativeFragmentTest_allocs *cgoAllocMap
	reff1f69e03.representativeFragmentTest, crepresentativeFragmentTest_allocs = (C.VkBool32)(x.RepresentativeFragmentTest), cgoAllocsUnknown
	allocsf1f69e03.Borrow(crepresentativeFragmentTest_allocs)

	x.reff1f69e03 = reff1f69e03
	x.allocsf1f69e03 = allocsf1f69e03
	return reff1f69e03, allocsf1f69e03

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceRepresentativeFragmentTestFeaturesNV) PassValue() (C.VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, *cgoAllocMap) {
	if x.reff1f69e03 != nil {
		return *x.reff1f69e03, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceRepresentativeFragmentTestFeaturesNV) Deref() {
	if x.reff1f69e03 == nil {
		return
	}
	x.SType = (StructureType)(x.reff1f69e03.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff1f69e03.pNext))
	x.RepresentativeFragmentTest = (Bool32)(x.reff1f69e03.representativeFragmentTest)
}

// allocPipelineRepresentativeFragmentTestStateCreateInfoNVMemory allocates memory for type C.VkPipelineRepresentativeFragmentTestStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRepresentativeFragmentTestStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRepresentativeFragmentTestStateCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineRepresentativeFragmentTestStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineRepresentativeFragmentTestStateCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineRepresentativeFragmentTestStateCreateInfoNV) Ref() *C.VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref9c224e21
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineRepresentativeFragmentTestStateCreateInfoNV) Free() {
	if x != nil && x.allocs9c224e21 != nil {
		x.allocs9c224e21.(*cgoAllocMap).Free()
		x.ref9c224e21 = nil
	}
}

// NewPipelineRepresentativeFragmentTestStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineRepresentativeFragmentTestStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineRepresentativeFragmentTestStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRepresentativeFragmentTestStateCreateInfoNV)
	obj.ref9c224e21 = (*C.VkPipelineRepresentativeFragmentTestStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineRepresentativeFragmentTestStateCreateInfoNV) PassRef() (*C.VkPipelineRepresentativeFragmentTestStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9c224e21 != nil {
		return x.ref9c224e21, nil
	}
	mem9c224e21 := allocPipelineRepresentativeFragmentTestStateCreateInfoNVMemory(1)
	ref9c224e21 := (*C.VkPipelineRepresentativeFragmentTestStateCreateInfoNV)(mem9c224e21)
	allocs9c224e21 := new(cgoAllocMap)
	allocs9c224e21.Add(mem9c224e21)

	var csType_allocs *cgoAllocMap
	ref9c224e21.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9c224e21.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9c224e21.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9c224e21.Borrow(cpNext_allocs)

	var crepresentativeFragmentTestEnable_allocs *cgoAllocMap
	ref9c224e21.representativeFragmentTestEnable, crepresentativeFragmentTestEnable_allocs = (C.VkBool32)(x.RepresentativeFragmentTestEnable), cgoAllocsUnknown
	allocs9c224e21.Borrow(crepresentativeFragmentTestEnable_allocs)

	x.ref9c224e21 = ref9c224e21
	x.allocs9c224e21 = allocs9c224e21
	return ref9c224e21, allocs9c224e21

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineRepresentativeFragmentTestStateCreateInfoNV) PassValue() (C.VkPipelineRepresentativeFragmentTestStateCreateInfoNV, *cgoAllocMap) {
	if x.ref9c224e21 != nil {
		return *x.ref9c224e21, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineRepresentativeFragmentTestStateCreateInfoNV) Deref() {
	if x.ref9c224e21 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9c224e21.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9c224e21.pNext))
	x.RepresentativeFragmentTestEnable = (Bool32)(x.ref9c224e21.representativeFragmentTestEnable)
}

// allocDeviceQueueGlobalPriorityCreateInfoMemory allocates memory for type C.VkDeviceQueueGlobalPriorityCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceQueueGlobalPriorityCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceQueueGlobalPriorityCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceQueueGlobalPriorityCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceQueueGlobalPriorityCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceQueueGlobalPriorityCreateInfo) Ref() *C.VkDeviceQueueGlobalPriorityCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref76356646
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceQueueGlobalPriorityCreateInfo) Free() {
	if x != nil && x.allocs76356646 != nil {
		x.allocs76356646.(*cgoAllocMap).Free()
		x.ref76356646 = nil
	}
}

// NewDeviceQueueGlobalPriorityCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceQueueGlobalPriorityCreateInfoRef(ref unsafe.Pointer) *DeviceQueueGlobalPriorityCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceQueueGlobalPriorityCreateInfo)
	obj.ref76356646 = (*C.VkDeviceQueueGlobalPriorityCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceQueueGlobalPriorityCreateInfo) PassRef() (*C.VkDeviceQueueGlobalPriorityCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref76356646 != nil {
		return x.ref76356646, nil
	}
	mem76356646 := allocDeviceQueueGlobalPriorityCreateInfoMemory(1)
	ref76356646 := (*C.VkDeviceQueueGlobalPriorityCreateInfoEXT)(mem76356646)
	allocs76356646 := new(cgoAllocMap)
	allocs76356646.Add(mem76356646)

	var csType_allocs *cgoAllocMap
	ref76356646.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs76356646.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref76356646.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs76356646.Borrow(cpNext_allocs)

	var cglobalPriority_allocs *cgoAllocMap
	ref76356646.globalPriority, cglobalPriority_allocs = (C.VkQueueGlobalPriorityEXT)(x.GlobalPriority), cgoAllocsUnknown
	allocs76356646.Borrow(cglobalPriority_allocs)

	x.ref76356646 = ref76356646
	x.allocs76356646 = allocs76356646
	return ref76356646, allocs76356646

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceQueueGlobalPriorityCreateInfo) PassValue() (C.VkDeviceQueueGlobalPriorityCreateInfoEXT, *cgoAllocMap) {
	if x.ref76356646 != nil {
		return *x.ref76356646, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceQueueGlobalPriorityCreateInfo) Deref() {
	if x.ref76356646 == nil {
		return
	}
	x.SType = (StructureType)(x.ref76356646.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref76356646.pNext))
	x.GlobalPriority = (QueueGlobalPriority)(x.ref76356646.globalPriority)
}

// allocImportMemoryHostPointerInfoMemory allocates memory for type C.VkImportMemoryHostPointerInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImportMemoryHostPointerInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImportMemoryHostPointerInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImportMemoryHostPointerInfoValue = unsafe.Sizeof([1]C.VkImportMemoryHostPointerInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImportMemoryHostPointerInfo) Ref() *C.VkImportMemoryHostPointerInfoEXT {
	if x == nil {
		return nil
	}
	return x.reffe09253e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImportMemoryHostPointerInfo) Free() {
	if x != nil && x.allocsfe09253e != nil {
		x.allocsfe09253e.(*cgoAllocMap).Free()
		x.reffe09253e = nil
	}
}

// NewImportMemoryHostPointerInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImportMemoryHostPointerInfoRef(ref unsafe.Pointer) *ImportMemoryHostPointerInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImportMemoryHostPointerInfo)
	obj.reffe09253e = (*C.VkImportMemoryHostPointerInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImportMemoryHostPointerInfo) PassRef() (*C.VkImportMemoryHostPointerInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe09253e != nil {
		return x.reffe09253e, nil
	}
	memfe09253e := allocImportMemoryHostPointerInfoMemory(1)
	reffe09253e := (*C.VkImportMemoryHostPointerInfoEXT)(memfe09253e)
	allocsfe09253e := new(cgoAllocMap)
	allocsfe09253e.Add(memfe09253e)

	var csType_allocs *cgoAllocMap
	reffe09253e.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsfe09253e.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reffe09253e.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsfe09253e.Borrow(cpNext_allocs)

	var chandleType_allocs *cgoAllocMap
	reffe09253e.handleType, chandleType_allocs = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType), cgoAllocsUnknown
	allocsfe09253e.Borrow(chandleType_allocs)

	var cpHostPointer_allocs *cgoAllocMap
	reffe09253e.pHostPointer, cpHostPointer_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PHostPointer)), cgoAllocsUnknown
	allocsfe09253e.Borrow(cpHostPointer_allocs)

	x.reffe09253e = reffe09253e
	x.allocsfe09253e = allocsfe09253e
	return reffe09253e, allocsfe09253e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImportMemoryHostPointerInfo) PassValue() (C.VkImportMemoryHostPointerInfoEXT, *cgoAllocMap) {
	if x.reffe09253e != nil {
		return *x.reffe09253e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImportMemoryHostPointerInfo) Deref() {
	if x.reffe09253e == nil {
		return
	}
	x.SType = (StructureType)(x.reffe09253e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe09253e.pNext))
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.reffe09253e.handleType)
	x.PHostPointer = (unsafe.Pointer)(unsafe.Pointer(x.reffe09253e.pHostPointer))
}

// allocMemoryHostPointerPropertiesMemory allocates memory for type C.VkMemoryHostPointerPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryHostPointerPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryHostPointerPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMemoryHostPointerPropertiesValue = unsafe.Sizeof([1]C.VkMemoryHostPointerPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryHostPointerProperties) Ref() *C.VkMemoryHostPointerPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refebf46a84
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryHostPointerProperties) Free() {
	if x != nil && x.allocsebf46a84 != nil {
		x.allocsebf46a84.(*cgoAllocMap).Free()
		x.refebf46a84 = nil
	}
}

// NewMemoryHostPointerPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryHostPointerPropertiesRef(ref unsafe.Pointer) *MemoryHostPointerProperties {
	if ref == nil {
		return nil
	}
	obj := new(MemoryHostPointerProperties)
	obj.refebf46a84 = (*C.VkMemoryHostPointerPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryHostPointerProperties) PassRef() (*C.VkMemoryHostPointerPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refebf46a84 != nil {
		return x.refebf46a84, nil
	}
	memebf46a84 := allocMemoryHostPointerPropertiesMemory(1)
	refebf46a84 := (*C.VkMemoryHostPointerPropertiesEXT)(memebf46a84)
	allocsebf46a84 := new(cgoAllocMap)
	allocsebf46a84.Add(memebf46a84)

	var csType_allocs *cgoAllocMap
	refebf46a84.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsebf46a84.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refebf46a84.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsebf46a84.Borrow(cpNext_allocs)

	var cmemoryTypeBits_allocs *cgoAllocMap
	refebf46a84.memoryTypeBits, cmemoryTypeBits_allocs = (C.uint32_t)(x.MemoryTypeBits), cgoAllocsUnknown
	allocsebf46a84.Borrow(cmemoryTypeBits_allocs)

	x.refebf46a84 = refebf46a84
	x.allocsebf46a84 = allocsebf46a84
	return refebf46a84, allocsebf46a84

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryHostPointerProperties) PassValue() (C.VkMemoryHostPointerPropertiesEXT, *cgoAllocMap) {
	if x.refebf46a84 != nil {
		return *x.refebf46a84, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryHostPointerProperties) Deref() {
	if x.refebf46a84 == nil {
		return
	}
	x.SType = (StructureType)(x.refebf46a84.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refebf46a84.pNext))
	x.MemoryTypeBits = (uint32)(x.refebf46a84.memoryTypeBits)
}

// allocPhysicalDeviceExternalMemoryHostPropertiesMemory allocates memory for type C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExternalMemoryHostPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExternalMemoryHostPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceExternalMemoryHostPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExternalMemoryHostProperties) Ref() *C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.ref7f697d15
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExternalMemoryHostProperties) Free() {
	if x != nil && x.allocs7f697d15 != nil {
		x.allocs7f697d15.(*cgoAllocMap).Free()
		x.ref7f697d15 = nil
	}
}

// NewPhysicalDeviceExternalMemoryHostPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExternalMemoryHostPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceExternalMemoryHostProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExternalMemoryHostProperties)
	obj.ref7f697d15 = (*C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExternalMemoryHostProperties) PassRef() (*C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7f697d15 != nil {
		return x.ref7f697d15, nil
	}
	mem7f697d15 := allocPhysicalDeviceExternalMemoryHostPropertiesMemory(1)
	ref7f697d15 := (*C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT)(mem7f697d15)
	allocs7f697d15 := new(cgoAllocMap)
	allocs7f697d15.Add(mem7f697d15)

	var csType_allocs *cgoAllocMap
	ref7f697d15.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs7f697d15.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref7f697d15.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs7f697d15.Borrow(cpNext_allocs)

	var cminImportedHostPointerAlignment_allocs *cgoAllocMap
	ref7f697d15.minImportedHostPointerAlignment, cminImportedHostPointerAlignment_allocs = (C.VkDeviceSize)(x.MinImportedHostPointerAlignment), cgoAllocsUnknown
	allocs7f697d15.Borrow(cminImportedHostPointerAlignment_allocs)

	x.ref7f697d15 = ref7f697d15
	x.allocs7f697d15 = allocs7f697d15
	return ref7f697d15, allocs7f697d15

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExternalMemoryHostProperties) PassValue() (C.VkPhysicalDeviceExternalMemoryHostPropertiesEXT, *cgoAllocMap) {
	if x.ref7f697d15 != nil {
		return *x.ref7f697d15, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExternalMemoryHostProperties) Deref() {
	if x.ref7f697d15 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7f697d15.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7f697d15.pNext))
	x.MinImportedHostPointerAlignment = (DeviceSize)(x.ref7f697d15.minImportedHostPointerAlignment)
}

// allocCalibratedTimestampInfoMemory allocates memory for type C.VkCalibratedTimestampInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCalibratedTimestampInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCalibratedTimestampInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCalibratedTimestampInfoValue = unsafe.Sizeof([1]C.VkCalibratedTimestampInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CalibratedTimestampInfo) Ref() *C.VkCalibratedTimestampInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref5f061d2a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CalibratedTimestampInfo) Free() {
	if x != nil && x.allocs5f061d2a != nil {
		x.allocs5f061d2a.(*cgoAllocMap).Free()
		x.ref5f061d2a = nil
	}
}

// NewCalibratedTimestampInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCalibratedTimestampInfoRef(ref unsafe.Pointer) *CalibratedTimestampInfo {
	if ref == nil {
		return nil
	}
	obj := new(CalibratedTimestampInfo)
	obj.ref5f061d2a = (*C.VkCalibratedTimestampInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CalibratedTimestampInfo) PassRef() (*C.VkCalibratedTimestampInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5f061d2a != nil {
		return x.ref5f061d2a, nil
	}
	mem5f061d2a := allocCalibratedTimestampInfoMemory(1)
	ref5f061d2a := (*C.VkCalibratedTimestampInfoEXT)(mem5f061d2a)
	allocs5f061d2a := new(cgoAllocMap)
	allocs5f061d2a.Add(mem5f061d2a)

	var csType_allocs *cgoAllocMap
	ref5f061d2a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs5f061d2a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref5f061d2a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs5f061d2a.Borrow(cpNext_allocs)

	var ctimeDomain_allocs *cgoAllocMap
	ref5f061d2a.timeDomain, ctimeDomain_allocs = (C.VkTimeDomainEXT)(x.TimeDomain), cgoAllocsUnknown
	allocs5f061d2a.Borrow(ctimeDomain_allocs)

	x.ref5f061d2a = ref5f061d2a
	x.allocs5f061d2a = allocs5f061d2a
	return ref5f061d2a, allocs5f061d2a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CalibratedTimestampInfo) PassValue() (C.VkCalibratedTimestampInfoEXT, *cgoAllocMap) {
	if x.ref5f061d2a != nil {
		return *x.ref5f061d2a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CalibratedTimestampInfo) Deref() {
	if x.ref5f061d2a == nil {
		return
	}
	x.SType = (StructureType)(x.ref5f061d2a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5f061d2a.pNext))
	x.TimeDomain = (TimeDomain)(x.ref5f061d2a.timeDomain)
}

// allocPhysicalDeviceShaderCorePropertiesAMDMemory allocates memory for type C.VkPhysicalDeviceShaderCorePropertiesAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderCorePropertiesAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderCorePropertiesAMDValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceShaderCorePropertiesAMDValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderCorePropertiesAMD{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderCorePropertiesAMD) Ref() *C.VkPhysicalDeviceShaderCorePropertiesAMD {
	if x == nil {
		return nil
	}
	return x.refde4b3b09
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderCorePropertiesAMD) Free() {
	if x != nil && x.allocsde4b3b09 != nil {
		x.allocsde4b3b09.(*cgoAllocMap).Free()
		x.refde4b3b09 = nil
	}
}

// NewPhysicalDeviceShaderCorePropertiesAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderCorePropertiesAMDRef(ref unsafe.Pointer) *PhysicalDeviceShaderCorePropertiesAMD {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderCorePropertiesAMD)
	obj.refde4b3b09 = (*C.VkPhysicalDeviceShaderCorePropertiesAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderCorePropertiesAMD) PassRef() (*C.VkPhysicalDeviceShaderCorePropertiesAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refde4b3b09 != nil {
		return x.refde4b3b09, nil
	}
	memde4b3b09 := allocPhysicalDeviceShaderCorePropertiesAMDMemory(1)
	refde4b3b09 := (*C.VkPhysicalDeviceShaderCorePropertiesAMD)(memde4b3b09)
	allocsde4b3b09 := new(cgoAllocMap)
	allocsde4b3b09.Add(memde4b3b09)

	var csType_allocs *cgoAllocMap
	refde4b3b09.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsde4b3b09.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refde4b3b09.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cpNext_allocs)

	var cshaderEngineCount_allocs *cgoAllocMap
	refde4b3b09.shaderEngineCount, cshaderEngineCount_allocs = (C.uint32_t)(x.ShaderEngineCount), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cshaderEngineCount_allocs)

	var cshaderArraysPerEngineCount_allocs *cgoAllocMap
	refde4b3b09.shaderArraysPerEngineCount, cshaderArraysPerEngineCount_allocs = (C.uint32_t)(x.ShaderArraysPerEngineCount), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cshaderArraysPerEngineCount_allocs)

	var ccomputeUnitsPerShaderArray_allocs *cgoAllocMap
	refde4b3b09.computeUnitsPerShaderArray, ccomputeUnitsPerShaderArray_allocs = (C.uint32_t)(x.ComputeUnitsPerShaderArray), cgoAllocsUnknown
	allocsde4b3b09.Borrow(ccomputeUnitsPerShaderArray_allocs)

	var csimdPerComputeUnit_allocs *cgoAllocMap
	refde4b3b09.simdPerComputeUnit, csimdPerComputeUnit_allocs = (C.uint32_t)(x.SimdPerComputeUnit), cgoAllocsUnknown
	allocsde4b3b09.Borrow(csimdPerComputeUnit_allocs)

	var cwavefrontsPerSimd_allocs *cgoAllocMap
	refde4b3b09.wavefrontsPerSimd, cwavefrontsPerSimd_allocs = (C.uint32_t)(x.WavefrontsPerSimd), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cwavefrontsPerSimd_allocs)

	var cwavefrontSize_allocs *cgoAllocMap
	refde4b3b09.wavefrontSize, cwavefrontSize_allocs = (C.uint32_t)(x.WavefrontSize), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cwavefrontSize_allocs)

	var csgprsPerSimd_allocs *cgoAllocMap
	refde4b3b09.sgprsPerSimd, csgprsPerSimd_allocs = (C.uint32_t)(x.SgprsPerSimd), cgoAllocsUnknown
	allocsde4b3b09.Borrow(csgprsPerSimd_allocs)

	var cminSgprAllocation_allocs *cgoAllocMap
	refde4b3b09.minSgprAllocation, cminSgprAllocation_allocs = (C.uint32_t)(x.MinSgprAllocation), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cminSgprAllocation_allocs)

	var cmaxSgprAllocation_allocs *cgoAllocMap
	refde4b3b09.maxSgprAllocation, cmaxSgprAllocation_allocs = (C.uint32_t)(x.MaxSgprAllocation), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cmaxSgprAllocation_allocs)

	var csgprAllocationGranularity_allocs *cgoAllocMap
	refde4b3b09.sgprAllocationGranularity, csgprAllocationGranularity_allocs = (C.uint32_t)(x.SgprAllocationGranularity), cgoAllocsUnknown
	allocsde4b3b09.Borrow(csgprAllocationGranularity_allocs)

	var cvgprsPerSimd_allocs *cgoAllocMap
	refde4b3b09.vgprsPerSimd, cvgprsPerSimd_allocs = (C.uint32_t)(x.VgprsPerSimd), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cvgprsPerSimd_allocs)

	var cminVgprAllocation_allocs *cgoAllocMap
	refde4b3b09.minVgprAllocation, cminVgprAllocation_allocs = (C.uint32_t)(x.MinVgprAllocation), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cminVgprAllocation_allocs)

	var cmaxVgprAllocation_allocs *cgoAllocMap
	refde4b3b09.maxVgprAllocation, cmaxVgprAllocation_allocs = (C.uint32_t)(x.MaxVgprAllocation), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cmaxVgprAllocation_allocs)

	var cvgprAllocationGranularity_allocs *cgoAllocMap
	refde4b3b09.vgprAllocationGranularity, cvgprAllocationGranularity_allocs = (C.uint32_t)(x.VgprAllocationGranularity), cgoAllocsUnknown
	allocsde4b3b09.Borrow(cvgprAllocationGranularity_allocs)

	x.refde4b3b09 = refde4b3b09
	x.allocsde4b3b09 = allocsde4b3b09
	return refde4b3b09, allocsde4b3b09

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderCorePropertiesAMD) PassValue() (C.VkPhysicalDeviceShaderCorePropertiesAMD, *cgoAllocMap) {
	if x.refde4b3b09 != nil {
		return *x.refde4b3b09, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderCorePropertiesAMD) Deref() {
	if x.refde4b3b09 == nil {
		return
	}
	x.SType = (StructureType)(x.refde4b3b09.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refde4b3b09.pNext))
	x.ShaderEngineCount = (uint32)(x.refde4b3b09.shaderEngineCount)
	x.ShaderArraysPerEngineCount = (uint32)(x.refde4b3b09.shaderArraysPerEngineCount)
	x.ComputeUnitsPerShaderArray = (uint32)(x.refde4b3b09.computeUnitsPerShaderArray)
	x.SimdPerComputeUnit = (uint32)(x.refde4b3b09.simdPerComputeUnit)
	x.WavefrontsPerSimd = (uint32)(x.refde4b3b09.wavefrontsPerSimd)
	x.WavefrontSize = (uint32)(x.refde4b3b09.wavefrontSize)
	x.SgprsPerSimd = (uint32)(x.refde4b3b09.sgprsPerSimd)
	x.MinSgprAllocation = (uint32)(x.refde4b3b09.minSgprAllocation)
	x.MaxSgprAllocation = (uint32)(x.refde4b3b09.maxSgprAllocation)
	x.SgprAllocationGranularity = (uint32)(x.refde4b3b09.sgprAllocationGranularity)
	x.VgprsPerSimd = (uint32)(x.refde4b3b09.vgprsPerSimd)
	x.MinVgprAllocation = (uint32)(x.refde4b3b09.minVgprAllocation)
	x.MaxVgprAllocation = (uint32)(x.refde4b3b09.maxVgprAllocation)
	x.VgprAllocationGranularity = (uint32)(x.refde4b3b09.vgprAllocationGranularity)
}

// allocPhysicalDeviceVertexAttributeDivisorPropertiesMemory allocates memory for type C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceVertexAttributeDivisorPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceVertexAttributeDivisorPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceVertexAttributeDivisorPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVertexAttributeDivisorProperties) Ref() *C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refbd6b5075
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVertexAttributeDivisorProperties) Free() {
	if x != nil && x.allocsbd6b5075 != nil {
		x.allocsbd6b5075.(*cgoAllocMap).Free()
		x.refbd6b5075 = nil
	}
}

// NewPhysicalDeviceVertexAttributeDivisorPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVertexAttributeDivisorPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceVertexAttributeDivisorProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVertexAttributeDivisorProperties)
	obj.refbd6b5075 = (*C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVertexAttributeDivisorProperties) PassRef() (*C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbd6b5075 != nil {
		return x.refbd6b5075, nil
	}
	membd6b5075 := allocPhysicalDeviceVertexAttributeDivisorPropertiesMemory(1)
	refbd6b5075 := (*C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT)(membd6b5075)
	allocsbd6b5075 := new(cgoAllocMap)
	allocsbd6b5075.Add(membd6b5075)

	var csType_allocs *cgoAllocMap
	refbd6b5075.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsbd6b5075.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refbd6b5075.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsbd6b5075.Borrow(cpNext_allocs)

	var cmaxVertexAttribDivisor_allocs *cgoAllocMap
	refbd6b5075.maxVertexAttribDivisor, cmaxVertexAttribDivisor_allocs = (C.uint32_t)(x.MaxVertexAttribDivisor), cgoAllocsUnknown
	allocsbd6b5075.Borrow(cmaxVertexAttribDivisor_allocs)

	x.refbd6b5075 = refbd6b5075
	x.allocsbd6b5075 = allocsbd6b5075
	return refbd6b5075, allocsbd6b5075

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVertexAttributeDivisorProperties) PassValue() (C.VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, *cgoAllocMap) {
	if x.refbd6b5075 != nil {
		return *x.refbd6b5075, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVertexAttributeDivisorProperties) Deref() {
	if x.refbd6b5075 == nil {
		return
	}
	x.SType = (StructureType)(x.refbd6b5075.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbd6b5075.pNext))
	x.MaxVertexAttribDivisor = (uint32)(x.refbd6b5075.maxVertexAttribDivisor)
}

// allocVertexInputBindingDivisorDescriptionMemory allocates memory for type C.VkVertexInputBindingDivisorDescriptionEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputBindingDivisorDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputBindingDivisorDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVertexInputBindingDivisorDescriptionValue = unsafe.Sizeof([1]C.VkVertexInputBindingDivisorDescriptionEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VertexInputBindingDivisorDescription) Ref() *C.VkVertexInputBindingDivisorDescriptionEXT {
	if x == nil {
		return nil
	}
	return x.refd64d4396
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VertexInputBindingDivisorDescription) Free() {
	if x != nil && x.allocsd64d4396 != nil {
		x.allocsd64d4396.(*cgoAllocMap).Free()
		x.refd64d4396 = nil
	}
}

// NewVertexInputBindingDivisorDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVertexInputBindingDivisorDescriptionRef(ref unsafe.Pointer) *VertexInputBindingDivisorDescription {
	if ref == nil {
		return nil
	}
	obj := new(VertexInputBindingDivisorDescription)
	obj.refd64d4396 = (*C.VkVertexInputBindingDivisorDescriptionEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VertexInputBindingDivisorDescription) PassRef() (*C.VkVertexInputBindingDivisorDescriptionEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd64d4396 != nil {
		return x.refd64d4396, nil
	}
	memd64d4396 := allocVertexInputBindingDivisorDescriptionMemory(1)
	refd64d4396 := (*C.VkVertexInputBindingDivisorDescriptionEXT)(memd64d4396)
	allocsd64d4396 := new(cgoAllocMap)
	allocsd64d4396.Add(memd64d4396)

	var cbinding_allocs *cgoAllocMap
	refd64d4396.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocsd64d4396.Borrow(cbinding_allocs)

	var cdivisor_allocs *cgoAllocMap
	refd64d4396.divisor, cdivisor_allocs = (C.uint32_t)(x.Divisor), cgoAllocsUnknown
	allocsd64d4396.Borrow(cdivisor_allocs)

	x.refd64d4396 = refd64d4396
	x.allocsd64d4396 = allocsd64d4396
	return refd64d4396, allocsd64d4396

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VertexInputBindingDivisorDescription) PassValue() (C.VkVertexInputBindingDivisorDescriptionEXT, *cgoAllocMap) {
	if x.refd64d4396 != nil {
		return *x.refd64d4396, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VertexInputBindingDivisorDescription) Deref() {
	if x.refd64d4396 == nil {
		return
	}
	x.Binding = (uint32)(x.refd64d4396.binding)
	x.Divisor = (uint32)(x.refd64d4396.divisor)
}

// allocPipelineVertexInputDivisorStateCreateInfoMemory allocates memory for type C.VkPipelineVertexInputDivisorStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineVertexInputDivisorStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineVertexInputDivisorStateCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineVertexInputDivisorStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineVertexInputDivisorStateCreateInfoEXT{})

// unpackSVertexInputBindingDivisorDescription transforms a sliced Go data structure into plain C format.
func unpackSVertexInputBindingDivisorDescription(x []VertexInputBindingDivisorDescription) (unpacked *C.VkVertexInputBindingDivisorDescriptionEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkVertexInputBindingDivisorDescriptionEXT) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVertexInputBindingDivisorDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkVertexInputBindingDivisorDescriptionEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkVertexInputBindingDivisorDescriptionEXT)(h.Data)
	return
}

// packSVertexInputBindingDivisorDescription reads sliced Go data structure out from plain C format.
func packSVertexInputBindingDivisorDescription(v []VertexInputBindingDivisorDescription, ptr0 *C.VkVertexInputBindingDivisorDescriptionEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVertexInputBindingDivisorDescriptionValue]C.VkVertexInputBindingDivisorDescriptionEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVertexInputBindingDivisorDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineVertexInputDivisorStateCreateInfo) Ref() *C.VkPipelineVertexInputDivisorStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref86096bfd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineVertexInputDivisorStateCreateInfo) Free() {
	if x != nil && x.allocs86096bfd != nil {
		x.allocs86096bfd.(*cgoAllocMap).Free()
		x.ref86096bfd = nil
	}
}

// NewPipelineVertexInputDivisorStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineVertexInputDivisorStateCreateInfoRef(ref unsafe.Pointer) *PipelineVertexInputDivisorStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineVertexInputDivisorStateCreateInfo)
	obj.ref86096bfd = (*C.VkPipelineVertexInputDivisorStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineVertexInputDivisorStateCreateInfo) PassRef() (*C.VkPipelineVertexInputDivisorStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref86096bfd != nil {
		return x.ref86096bfd, nil
	}
	mem86096bfd := allocPipelineVertexInputDivisorStateCreateInfoMemory(1)
	ref86096bfd := (*C.VkPipelineVertexInputDivisorStateCreateInfoEXT)(mem86096bfd)
	allocs86096bfd := new(cgoAllocMap)
	allocs86096bfd.Add(mem86096bfd)

	var csType_allocs *cgoAllocMap
	ref86096bfd.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs86096bfd.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref86096bfd.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs86096bfd.Borrow(cpNext_allocs)

	var cvertexBindingDivisorCount_allocs *cgoAllocMap
	ref86096bfd.vertexBindingDivisorCount, cvertexBindingDivisorCount_allocs = (C.uint32_t)(x.VertexBindingDivisorCount), cgoAllocsUnknown
	allocs86096bfd.Borrow(cvertexBindingDivisorCount_allocs)

	var cpVertexBindingDivisors_allocs *cgoAllocMap
	ref86096bfd.pVertexBindingDivisors, cpVertexBindingDivisors_allocs = unpackSVertexInputBindingDivisorDescription(x.PVertexBindingDivisors)
	allocs86096bfd.Borrow(cpVertexBindingDivisors_allocs)

	x.ref86096bfd = ref86096bfd
	x.allocs86096bfd = allocs86096bfd
	return ref86096bfd, allocs86096bfd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineVertexInputDivisorStateCreateInfo) PassValue() (C.VkPipelineVertexInputDivisorStateCreateInfoEXT, *cgoAllocMap) {
	if x.ref86096bfd != nil {
		return *x.ref86096bfd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineVertexInputDivisorStateCreateInfo) Deref() {
	if x.ref86096bfd == nil {
		return
	}
	x.SType = (StructureType)(x.ref86096bfd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref86096bfd.pNext))
	x.VertexBindingDivisorCount = (uint32)(x.ref86096bfd.vertexBindingDivisorCount)
	packSVertexInputBindingDivisorDescription(x.PVertexBindingDivisors, x.ref86096bfd.pVertexBindingDivisors)
}

// allocPhysicalDeviceVertexAttributeDivisorFeaturesMemory allocates memory for type C.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceVertexAttributeDivisorFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceVertexAttributeDivisorFeaturesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceVertexAttributeDivisorFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVertexAttributeDivisorFeatures) Ref() *C.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refffe7619a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVertexAttributeDivisorFeatures) Free() {
	if x != nil && x.allocsffe7619a != nil {
		x.allocsffe7619a.(*cgoAllocMap).Free()
		x.refffe7619a = nil
	}
}

// NewPhysicalDeviceVertexAttributeDivisorFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVertexAttributeDivisorFeaturesRef(ref unsafe.Pointer) *PhysicalDeviceVertexAttributeDivisorFeatures {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVertexAttributeDivisorFeatures)
	obj.refffe7619a = (*C.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVertexAttributeDivisorFeatures) PassRef() (*C.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refffe7619a != nil {
		return x.refffe7619a, nil
	}
	memffe7619a := allocPhysicalDeviceVertexAttributeDivisorFeaturesMemory(1)
	refffe7619a := (*C.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT)(memffe7619a)
	allocsffe7619a := new(cgoAllocMap)
	allocsffe7619a.Add(memffe7619a)

	var csType_allocs *cgoAllocMap
	refffe7619a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsffe7619a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refffe7619a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsffe7619a.Borrow(cpNext_allocs)

	var cvertexAttributeInstanceRateDivisor_allocs *cgoAllocMap
	refffe7619a.vertexAttributeInstanceRateDivisor, cvertexAttributeInstanceRateDivisor_allocs = (C.VkBool32)(x.VertexAttributeInstanceRateDivisor), cgoAllocsUnknown
	allocsffe7619a.Borrow(cvertexAttributeInstanceRateDivisor_allocs)

	var cvertexAttributeInstanceRateZeroDivisor_allocs *cgoAllocMap
	refffe7619a.vertexAttributeInstanceRateZeroDivisor, cvertexAttributeInstanceRateZeroDivisor_allocs = (C.VkBool32)(x.VertexAttributeInstanceRateZeroDivisor), cgoAllocsUnknown
	allocsffe7619a.Borrow(cvertexAttributeInstanceRateZeroDivisor_allocs)

	x.refffe7619a = refffe7619a
	x.allocsffe7619a = allocsffe7619a
	return refffe7619a, allocsffe7619a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVertexAttributeDivisorFeatures) PassValue() (C.VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, *cgoAllocMap) {
	if x.refffe7619a != nil {
		return *x.refffe7619a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVertexAttributeDivisorFeatures) Deref() {
	if x.refffe7619a == nil {
		return
	}
	x.SType = (StructureType)(x.refffe7619a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refffe7619a.pNext))
	x.VertexAttributeInstanceRateDivisor = (Bool32)(x.refffe7619a.vertexAttributeInstanceRateDivisor)
	x.VertexAttributeInstanceRateZeroDivisor = (Bool32)(x.refffe7619a.vertexAttributeInstanceRateZeroDivisor)
}

// allocPhysicalDeviceComputeShaderDerivativesFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceComputeShaderDerivativesFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceComputeShaderDerivativesFeaturesNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceComputeShaderDerivativesFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceComputeShaderDerivativesFeaturesNV) Ref() *C.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV {
	if x == nil {
		return nil
	}
	return x.reff31d599c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceComputeShaderDerivativesFeaturesNV) Free() {
	if x != nil && x.allocsf31d599c != nil {
		x.allocsf31d599c.(*cgoAllocMap).Free()
		x.reff31d599c = nil
	}
}

// NewPhysicalDeviceComputeShaderDerivativesFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceComputeShaderDerivativesFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceComputeShaderDerivativesFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceComputeShaderDerivativesFeaturesNV)
	obj.reff31d599c = (*C.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceComputeShaderDerivativesFeaturesNV) PassRef() (*C.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff31d599c != nil {
		return x.reff31d599c, nil
	}
	memf31d599c := allocPhysicalDeviceComputeShaderDerivativesFeaturesNVMemory(1)
	reff31d599c := (*C.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV)(memf31d599c)
	allocsf31d599c := new(cgoAllocMap)
	allocsf31d599c.Add(memf31d599c)

	var csType_allocs *cgoAllocMap
	reff31d599c.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsf31d599c.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	reff31d599c.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsf31d599c.Borrow(cpNext_allocs)

	var ccomputeDerivativeGroupQuads_allocs *cgoAllocMap
	reff31d599c.computeDerivativeGroupQuads, ccomputeDerivativeGroupQuads_allocs = (C.VkBool32)(x.ComputeDerivativeGroupQuads), cgoAllocsUnknown
	allocsf31d599c.Borrow(ccomputeDerivativeGroupQuads_allocs)

	var ccomputeDerivativeGroupLinear_allocs *cgoAllocMap
	reff31d599c.computeDerivativeGroupLinear, ccomputeDerivativeGroupLinear_allocs = (C.VkBool32)(x.ComputeDerivativeGroupLinear), cgoAllocsUnknown
	allocsf31d599c.Borrow(ccomputeDerivativeGroupLinear_allocs)

	x.reff31d599c = reff31d599c
	x.allocsf31d599c = allocsf31d599c
	return reff31d599c, allocsf31d599c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceComputeShaderDerivativesFeaturesNV) PassValue() (C.VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, *cgoAllocMap) {
	if x.reff31d599c != nil {
		return *x.reff31d599c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceComputeShaderDerivativesFeaturesNV) Deref() {
	if x.reff31d599c == nil {
		return
	}
	x.SType = (StructureType)(x.reff31d599c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff31d599c.pNext))
	x.ComputeDerivativeGroupQuads = (Bool32)(x.reff31d599c.computeDerivativeGroupQuads)
	x.ComputeDerivativeGroupLinear = (Bool32)(x.reff31d599c.computeDerivativeGroupLinear)
}

// allocPhysicalDeviceMeshShaderFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceMeshShaderFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMeshShaderFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMeshShaderFeaturesNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceMeshShaderFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMeshShaderFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMeshShaderFeaturesNV) Ref() *C.VkPhysicalDeviceMeshShaderFeaturesNV {
	if x == nil {
		return nil
	}
	return x.ref802b98a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMeshShaderFeaturesNV) Free() {
	if x != nil && x.allocs802b98a != nil {
		x.allocs802b98a.(*cgoAllocMap).Free()
		x.ref802b98a = nil
	}
}

// NewPhysicalDeviceMeshShaderFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMeshShaderFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceMeshShaderFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMeshShaderFeaturesNV)
	obj.ref802b98a = (*C.VkPhysicalDeviceMeshShaderFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMeshShaderFeaturesNV) PassRef() (*C.VkPhysicalDeviceMeshShaderFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref802b98a != nil {
		return x.ref802b98a, nil
	}
	mem802b98a := allocPhysicalDeviceMeshShaderFeaturesNVMemory(1)
	ref802b98a := (*C.VkPhysicalDeviceMeshShaderFeaturesNV)(mem802b98a)
	allocs802b98a := new(cgoAllocMap)
	allocs802b98a.Add(mem802b98a)

	var csType_allocs *cgoAllocMap
	ref802b98a.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs802b98a.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref802b98a.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs802b98a.Borrow(cpNext_allocs)

	var ctaskShader_allocs *cgoAllocMap
	ref802b98a.taskShader, ctaskShader_allocs = (C.VkBool32)(x.TaskShader), cgoAllocsUnknown
	allocs802b98a.Borrow(ctaskShader_allocs)

	var cmeshShader_allocs *cgoAllocMap
	ref802b98a.meshShader, cmeshShader_allocs = (C.VkBool32)(x.MeshShader), cgoAllocsUnknown
	allocs802b98a.Borrow(cmeshShader_allocs)

	x.ref802b98a = ref802b98a
	x.allocs802b98a = allocs802b98a
	return ref802b98a, allocs802b98a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMeshShaderFeaturesNV) PassValue() (C.VkPhysicalDeviceMeshShaderFeaturesNV, *cgoAllocMap) {
	if x.ref802b98a != nil {
		return *x.ref802b98a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMeshShaderFeaturesNV) Deref() {
	if x.ref802b98a == nil {
		return
	}
	x.SType = (StructureType)(x.ref802b98a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref802b98a.pNext))
	x.TaskShader = (Bool32)(x.ref802b98a.taskShader)
	x.MeshShader = (Bool32)(x.ref802b98a.meshShader)
}

// allocPhysicalDeviceMeshShaderPropertiesNVMemory allocates memory for type C.VkPhysicalDeviceMeshShaderPropertiesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMeshShaderPropertiesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceMeshShaderPropertiesNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceMeshShaderPropertiesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceMeshShaderPropertiesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceMeshShaderPropertiesNV) Ref() *C.VkPhysicalDeviceMeshShaderPropertiesNV {
	if x == nil {
		return nil
	}
	return x.ref2ee3ccb7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceMeshShaderPropertiesNV) Free() {
	if x != nil && x.allocs2ee3ccb7 != nil {
		x.allocs2ee3ccb7.(*cgoAllocMap).Free()
		x.ref2ee3ccb7 = nil
	}
}

// NewPhysicalDeviceMeshShaderPropertiesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceMeshShaderPropertiesNVRef(ref unsafe.Pointer) *PhysicalDeviceMeshShaderPropertiesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceMeshShaderPropertiesNV)
	obj.ref2ee3ccb7 = (*C.VkPhysicalDeviceMeshShaderPropertiesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceMeshShaderPropertiesNV) PassRef() (*C.VkPhysicalDeviceMeshShaderPropertiesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2ee3ccb7 != nil {
		return x.ref2ee3ccb7, nil
	}
	mem2ee3ccb7 := allocPhysicalDeviceMeshShaderPropertiesNVMemory(1)
	ref2ee3ccb7 := (*C.VkPhysicalDeviceMeshShaderPropertiesNV)(mem2ee3ccb7)
	allocs2ee3ccb7 := new(cgoAllocMap)
	allocs2ee3ccb7.Add(mem2ee3ccb7)

	var csType_allocs *cgoAllocMap
	ref2ee3ccb7.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref2ee3ccb7.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cpNext_allocs)

	var cmaxDrawMeshTasksCount_allocs *cgoAllocMap
	ref2ee3ccb7.maxDrawMeshTasksCount, cmaxDrawMeshTasksCount_allocs = (C.uint32_t)(x.MaxDrawMeshTasksCount), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxDrawMeshTasksCount_allocs)

	var cmaxTaskWorkGroupInvocations_allocs *cgoAllocMap
	ref2ee3ccb7.maxTaskWorkGroupInvocations, cmaxTaskWorkGroupInvocations_allocs = (C.uint32_t)(x.MaxTaskWorkGroupInvocations), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxTaskWorkGroupInvocations_allocs)

	var cmaxTaskWorkGroupSize_allocs *cgoAllocMap
	ref2ee3ccb7.maxTaskWorkGroupSize, cmaxTaskWorkGroupSize_allocs = *(*[3]C.uint32_t)(unsafe.Pointer(&x.MaxTaskWorkGroupSize)), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxTaskWorkGroupSize_allocs)

	var cmaxTaskTotalMemorySize_allocs *cgoAllocMap
	ref2ee3ccb7.maxTaskTotalMemorySize, cmaxTaskTotalMemorySize_allocs = (C.uint32_t)(x.MaxTaskTotalMemorySize), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxTaskTotalMemorySize_allocs)

	var cmaxTaskOutputCount_allocs *cgoAllocMap
	ref2ee3ccb7.maxTaskOutputCount, cmaxTaskOutputCount_allocs = (C.uint32_t)(x.MaxTaskOutputCount), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxTaskOutputCount_allocs)

	var cmaxMeshWorkGroupInvocations_allocs *cgoAllocMap
	ref2ee3ccb7.maxMeshWorkGroupInvocations, cmaxMeshWorkGroupInvocations_allocs = (C.uint32_t)(x.MaxMeshWorkGroupInvocations), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxMeshWorkGroupInvocations_allocs)

	var cmaxMeshWorkGroupSize_allocs *cgoAllocMap
	ref2ee3ccb7.maxMeshWorkGroupSize, cmaxMeshWorkGroupSize_allocs = *(*[3]C.uint32_t)(unsafe.Pointer(&x.MaxMeshWorkGroupSize)), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxMeshWorkGroupSize_allocs)

	var cmaxMeshTotalMemorySize_allocs *cgoAllocMap
	ref2ee3ccb7.maxMeshTotalMemorySize, cmaxMeshTotalMemorySize_allocs = (C.uint32_t)(x.MaxMeshTotalMemorySize), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxMeshTotalMemorySize_allocs)

	var cmaxMeshOutputVertices_allocs *cgoAllocMap
	ref2ee3ccb7.maxMeshOutputVertices, cmaxMeshOutputVertices_allocs = (C.uint32_t)(x.MaxMeshOutputVertices), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxMeshOutputVertices_allocs)

	var cmaxMeshOutputPrimitives_allocs *cgoAllocMap
	ref2ee3ccb7.maxMeshOutputPrimitives, cmaxMeshOutputPrimitives_allocs = (C.uint32_t)(x.MaxMeshOutputPrimitives), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxMeshOutputPrimitives_allocs)

	var cmaxMeshMultiviewViewCount_allocs *cgoAllocMap
	ref2ee3ccb7.maxMeshMultiviewViewCount, cmaxMeshMultiviewViewCount_allocs = (C.uint32_t)(x.MaxMeshMultiviewViewCount), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmaxMeshMultiviewViewCount_allocs)

	var cmeshOutputPerVertexGranularity_allocs *cgoAllocMap
	ref2ee3ccb7.meshOutputPerVertexGranularity, cmeshOutputPerVertexGranularity_allocs = (C.uint32_t)(x.MeshOutputPerVertexGranularity), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmeshOutputPerVertexGranularity_allocs)

	var cmeshOutputPerPrimitiveGranularity_allocs *cgoAllocMap
	ref2ee3ccb7.meshOutputPerPrimitiveGranularity, cmeshOutputPerPrimitiveGranularity_allocs = (C.uint32_t)(x.MeshOutputPerPrimitiveGranularity), cgoAllocsUnknown
	allocs2ee3ccb7.Borrow(cmeshOutputPerPrimitiveGranularity_allocs)

	x.ref2ee3ccb7 = ref2ee3ccb7
	x.allocs2ee3ccb7 = allocs2ee3ccb7
	return ref2ee3ccb7, allocs2ee3ccb7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceMeshShaderPropertiesNV) PassValue() (C.VkPhysicalDeviceMeshShaderPropertiesNV, *cgoAllocMap) {
	if x.ref2ee3ccb7 != nil {
		return *x.ref2ee3ccb7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceMeshShaderPropertiesNV) Deref() {
	if x.ref2ee3ccb7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2ee3ccb7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2ee3ccb7.pNext))
	x.MaxDrawMeshTasksCount = (uint32)(x.ref2ee3ccb7.maxDrawMeshTasksCount)
	x.MaxTaskWorkGroupInvocations = (uint32)(x.ref2ee3ccb7.maxTaskWorkGroupInvocations)
	x.MaxTaskWorkGroupSize = *(*[3]uint32)(unsafe.Pointer(&x.ref2ee3ccb7.maxTaskWorkGroupSize))
	x.MaxTaskTotalMemorySize = (uint32)(x.ref2ee3ccb7.maxTaskTotalMemorySize)
	x.MaxTaskOutputCount = (uint32)(x.ref2ee3ccb7.maxTaskOutputCount)
	x.MaxMeshWorkGroupInvocations = (uint32)(x.ref2ee3ccb7.maxMeshWorkGroupInvocations)
	x.MaxMeshWorkGroupSize = *(*[3]uint32)(unsafe.Pointer(&x.ref2ee3ccb7.maxMeshWorkGroupSize))
	x.MaxMeshTotalMemorySize = (uint32)(x.ref2ee3ccb7.maxMeshTotalMemorySize)
	x.MaxMeshOutputVertices = (uint32)(x.ref2ee3ccb7.maxMeshOutputVertices)
	x.MaxMeshOutputPrimitives = (uint32)(x.ref2ee3ccb7.maxMeshOutputPrimitives)
	x.MaxMeshMultiviewViewCount = (uint32)(x.ref2ee3ccb7.maxMeshMultiviewViewCount)
	x.MeshOutputPerVertexGranularity = (uint32)(x.ref2ee3ccb7.meshOutputPerVertexGranularity)
	x.MeshOutputPerPrimitiveGranularity = (uint32)(x.ref2ee3ccb7.meshOutputPerPrimitiveGranularity)
}

// allocDrawMeshTasksIndirectCommandNVMemory allocates memory for type C.VkDrawMeshTasksIndirectCommandNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrawMeshTasksIndirectCommandNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrawMeshTasksIndirectCommandNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDrawMeshTasksIndirectCommandNVValue = unsafe.Sizeof([1]C.VkDrawMeshTasksIndirectCommandNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DrawMeshTasksIndirectCommandNV) Ref() *C.VkDrawMeshTasksIndirectCommandNV {
	if x == nil {
		return nil
	}
	return x.refda6c46ea
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DrawMeshTasksIndirectCommandNV) Free() {
	if x != nil && x.allocsda6c46ea != nil {
		x.allocsda6c46ea.(*cgoAllocMap).Free()
		x.refda6c46ea = nil
	}
}

// NewDrawMeshTasksIndirectCommandNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDrawMeshTasksIndirectCommandNVRef(ref unsafe.Pointer) *DrawMeshTasksIndirectCommandNV {
	if ref == nil {
		return nil
	}
	obj := new(DrawMeshTasksIndirectCommandNV)
	obj.refda6c46ea = (*C.VkDrawMeshTasksIndirectCommandNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DrawMeshTasksIndirectCommandNV) PassRef() (*C.VkDrawMeshTasksIndirectCommandNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refda6c46ea != nil {
		return x.refda6c46ea, nil
	}
	memda6c46ea := allocDrawMeshTasksIndirectCommandNVMemory(1)
	refda6c46ea := (*C.VkDrawMeshTasksIndirectCommandNV)(memda6c46ea)
	allocsda6c46ea := new(cgoAllocMap)
	allocsda6c46ea.Add(memda6c46ea)

	var ctaskCount_allocs *cgoAllocMap
	refda6c46ea.taskCount, ctaskCount_allocs = (C.uint32_t)(x.TaskCount), cgoAllocsUnknown
	allocsda6c46ea.Borrow(ctaskCount_allocs)

	var cfirstTask_allocs *cgoAllocMap
	refda6c46ea.firstTask, cfirstTask_allocs = (C.uint32_t)(x.FirstTask), cgoAllocsUnknown
	allocsda6c46ea.Borrow(cfirstTask_allocs)

	x.refda6c46ea = refda6c46ea
	x.allocsda6c46ea = allocsda6c46ea
	return refda6c46ea, allocsda6c46ea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DrawMeshTasksIndirectCommandNV) PassValue() (C.VkDrawMeshTasksIndirectCommandNV, *cgoAllocMap) {
	if x.refda6c46ea != nil {
		return *x.refda6c46ea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DrawMeshTasksIndirectCommandNV) Deref() {
	if x.refda6c46ea == nil {
		return
	}
	x.TaskCount = (uint32)(x.refda6c46ea.taskCount)
	x.FirstTask = (uint32)(x.refda6c46ea.firstTask)
}

// allocPhysicalDeviceFragmentShaderBarycentricFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFragmentShaderBarycentricFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFragmentShaderBarycentricFeaturesNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceFragmentShaderBarycentricFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceFragmentShaderBarycentricFeaturesNV) Ref() *C.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV {
	if x == nil {
		return nil
	}
	return x.ref191b97c6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceFragmentShaderBarycentricFeaturesNV) Free() {
	if x != nil && x.allocs191b97c6 != nil {
		x.allocs191b97c6.(*cgoAllocMap).Free()
		x.ref191b97c6 = nil
	}
}

// NewPhysicalDeviceFragmentShaderBarycentricFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceFragmentShaderBarycentricFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceFragmentShaderBarycentricFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceFragmentShaderBarycentricFeaturesNV)
	obj.ref191b97c6 = (*C.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceFragmentShaderBarycentricFeaturesNV) PassRef() (*C.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref191b97c6 != nil {
		return x.ref191b97c6, nil
	}
	mem191b97c6 := allocPhysicalDeviceFragmentShaderBarycentricFeaturesNVMemory(1)
	ref191b97c6 := (*C.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV)(mem191b97c6)
	allocs191b97c6 := new(cgoAllocMap)
	allocs191b97c6.Add(mem191b97c6)

	var csType_allocs *cgoAllocMap
	ref191b97c6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs191b97c6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref191b97c6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs191b97c6.Borrow(cpNext_allocs)

	var cfragmentShaderBarycentric_allocs *cgoAllocMap
	ref191b97c6.fragmentShaderBarycentric, cfragmentShaderBarycentric_allocs = (C.VkBool32)(x.FragmentShaderBarycentric), cgoAllocsUnknown
	allocs191b97c6.Borrow(cfragmentShaderBarycentric_allocs)

	x.ref191b97c6 = ref191b97c6
	x.allocs191b97c6 = allocs191b97c6
	return ref191b97c6, allocs191b97c6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceFragmentShaderBarycentricFeaturesNV) PassValue() (C.VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV, *cgoAllocMap) {
	if x.ref191b97c6 != nil {
		return *x.ref191b97c6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceFragmentShaderBarycentricFeaturesNV) Deref() {
	if x.ref191b97c6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref191b97c6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref191b97c6.pNext))
	x.FragmentShaderBarycentric = (Bool32)(x.ref191b97c6.fragmentShaderBarycentric)
}

// allocPhysicalDeviceShaderImageFootprintFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceShaderImageFootprintFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceShaderImageFootprintFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceShaderImageFootprintFeaturesNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceShaderImageFootprintFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceShaderImageFootprintFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceShaderImageFootprintFeaturesNV) Ref() *C.VkPhysicalDeviceShaderImageFootprintFeaturesNV {
	if x == nil {
		return nil
	}
	return x.ref9d61e1b2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceShaderImageFootprintFeaturesNV) Free() {
	if x != nil && x.allocs9d61e1b2 != nil {
		x.allocs9d61e1b2.(*cgoAllocMap).Free()
		x.ref9d61e1b2 = nil
	}
}

// NewPhysicalDeviceShaderImageFootprintFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceShaderImageFootprintFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceShaderImageFootprintFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceShaderImageFootprintFeaturesNV)
	obj.ref9d61e1b2 = (*C.VkPhysicalDeviceShaderImageFootprintFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceShaderImageFootprintFeaturesNV) PassRef() (*C.VkPhysicalDeviceShaderImageFootprintFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9d61e1b2 != nil {
		return x.ref9d61e1b2, nil
	}
	mem9d61e1b2 := allocPhysicalDeviceShaderImageFootprintFeaturesNVMemory(1)
	ref9d61e1b2 := (*C.VkPhysicalDeviceShaderImageFootprintFeaturesNV)(mem9d61e1b2)
	allocs9d61e1b2 := new(cgoAllocMap)
	allocs9d61e1b2.Add(mem9d61e1b2)

	var csType_allocs *cgoAllocMap
	ref9d61e1b2.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs9d61e1b2.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref9d61e1b2.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs9d61e1b2.Borrow(cpNext_allocs)

	var cimageFootprint_allocs *cgoAllocMap
	ref9d61e1b2.imageFootprint, cimageFootprint_allocs = (C.VkBool32)(x.ImageFootprint), cgoAllocsUnknown
	allocs9d61e1b2.Borrow(cimageFootprint_allocs)

	x.ref9d61e1b2 = ref9d61e1b2
	x.allocs9d61e1b2 = allocs9d61e1b2
	return ref9d61e1b2, allocs9d61e1b2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceShaderImageFootprintFeaturesNV) PassValue() (C.VkPhysicalDeviceShaderImageFootprintFeaturesNV, *cgoAllocMap) {
	if x.ref9d61e1b2 != nil {
		return *x.ref9d61e1b2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceShaderImageFootprintFeaturesNV) Deref() {
	if x.ref9d61e1b2 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9d61e1b2.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9d61e1b2.pNext))
	x.ImageFootprint = (Bool32)(x.ref9d61e1b2.imageFootprint)
}

// allocPipelineViewportExclusiveScissorStateCreateInfoNVMemory allocates memory for type C.VkPipelineViewportExclusiveScissorStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportExclusiveScissorStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportExclusiveScissorStateCreateInfoNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPipelineViewportExclusiveScissorStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineViewportExclusiveScissorStateCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportExclusiveScissorStateCreateInfoNV) Ref() *C.VkPipelineViewportExclusiveScissorStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refa8715ba6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportExclusiveScissorStateCreateInfoNV) Free() {
	if x != nil && x.allocsa8715ba6 != nil {
		x.allocsa8715ba6.(*cgoAllocMap).Free()
		x.refa8715ba6 = nil
	}
}

// NewPipelineViewportExclusiveScissorStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportExclusiveScissorStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineViewportExclusiveScissorStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportExclusiveScissorStateCreateInfoNV)
	obj.refa8715ba6 = (*C.VkPipelineViewportExclusiveScissorStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportExclusiveScissorStateCreateInfoNV) PassRef() (*C.VkPipelineViewportExclusiveScissorStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa8715ba6 != nil {
		return x.refa8715ba6, nil
	}
	mema8715ba6 := allocPipelineViewportExclusiveScissorStateCreateInfoNVMemory(1)
	refa8715ba6 := (*C.VkPipelineViewportExclusiveScissorStateCreateInfoNV)(mema8715ba6)
	allocsa8715ba6 := new(cgoAllocMap)
	allocsa8715ba6.Add(mema8715ba6)

	var csType_allocs *cgoAllocMap
	refa8715ba6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsa8715ba6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refa8715ba6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsa8715ba6.Borrow(cpNext_allocs)

	var cexclusiveScissorCount_allocs *cgoAllocMap
	refa8715ba6.exclusiveScissorCount, cexclusiveScissorCount_allocs = (C.uint32_t)(x.ExclusiveScissorCount), cgoAllocsUnknown
	allocsa8715ba6.Borrow(cexclusiveScissorCount_allocs)

	var cpExclusiveScissors_allocs *cgoAllocMap
	refa8715ba6.pExclusiveScissors, cpExclusiveScissors_allocs = unpackSRect2D(x.PExclusiveScissors)
	allocsa8715ba6.Borrow(cpExclusiveScissors_allocs)

	x.refa8715ba6 = refa8715ba6
	x.allocsa8715ba6 = allocsa8715ba6
	return refa8715ba6, allocsa8715ba6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportExclusiveScissorStateCreateInfoNV) PassValue() (C.VkPipelineViewportExclusiveScissorStateCreateInfoNV, *cgoAllocMap) {
	if x.refa8715ba6 != nil {
		return *x.refa8715ba6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportExclusiveScissorStateCreateInfoNV) Deref() {
	if x.refa8715ba6 == nil {
		return
	}
	x.SType = (StructureType)(x.refa8715ba6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa8715ba6.pNext))
	x.ExclusiveScissorCount = (uint32)(x.refa8715ba6.exclusiveScissorCount)
	packSRect2D(x.PExclusiveScissors, x.refa8715ba6.pExclusiveScissors)
}

// allocPhysicalDeviceExclusiveScissorFeaturesNVMemory allocates memory for type C.VkPhysicalDeviceExclusiveScissorFeaturesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceExclusiveScissorFeaturesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceExclusiveScissorFeaturesNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDeviceExclusiveScissorFeaturesNVValue = unsafe.Sizeof([1]C.VkPhysicalDeviceExclusiveScissorFeaturesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceExclusiveScissorFeaturesNV) Ref() *C.VkPhysicalDeviceExclusiveScissorFeaturesNV {
	if x == nil {
		return nil
	}
	return x.ref52c9fcfc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceExclusiveScissorFeaturesNV) Free() {
	if x != nil && x.allocs52c9fcfc != nil {
		x.allocs52c9fcfc.(*cgoAllocMap).Free()
		x.ref52c9fcfc = nil
	}
}

// NewPhysicalDeviceExclusiveScissorFeaturesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceExclusiveScissorFeaturesNVRef(ref unsafe.Pointer) *PhysicalDeviceExclusiveScissorFeaturesNV {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceExclusiveScissorFeaturesNV)
	obj.ref52c9fcfc = (*C.VkPhysicalDeviceExclusiveScissorFeaturesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceExclusiveScissorFeaturesNV) PassRef() (*C.VkPhysicalDeviceExclusiveScissorFeaturesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref52c9fcfc != nil {
		return x.ref52c9fcfc, nil
	}
	mem52c9fcfc := allocPhysicalDeviceExclusiveScissorFeaturesNVMemory(1)
	ref52c9fcfc := (*C.VkPhysicalDeviceExclusiveScissorFeaturesNV)(mem52c9fcfc)
	allocs52c9fcfc := new(cgoAllocMap)
	allocs52c9fcfc.Add(mem52c9fcfc)

	var csType_allocs *cgoAllocMap
	ref52c9fcfc.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs52c9fcfc.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref52c9fcfc.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs52c9fcfc.Borrow(cpNext_allocs)

	var cexclusiveScissor_allocs *cgoAllocMap
	ref52c9fcfc.exclusiveScissor, cexclusiveScissor_allocs = (C.VkBool32)(x.ExclusiveScissor), cgoAllocsUnknown
	allocs52c9fcfc.Borrow(cexclusiveScissor_allocs)

	x.ref52c9fcfc = ref52c9fcfc
	x.allocs52c9fcfc = allocs52c9fcfc
	return ref52c9fcfc, allocs52c9fcfc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceExclusiveScissorFeaturesNV) PassValue() (C.VkPhysicalDeviceExclusiveScissorFeaturesNV, *cgoAllocMap) {
	if x.ref52c9fcfc != nil {
		return *x.ref52c9fcfc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceExclusiveScissorFeaturesNV) Deref() {
	if x.ref52c9fcfc == nil {
		return
	}
	x.SType = (StructureType)(x.ref52c9fcfc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref52c9fcfc.pNext))
	x.ExclusiveScissor = (Bool32)(x.ref52c9fcfc.exclusiveScissor)
}

// allocQueueFamilyCheckpointPropertiesNVMemory allocates memory for type C.VkQueueFamilyCheckpointPropertiesNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueueFamilyCheckpointPropertiesNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueueFamilyCheckpointPropertiesNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfQueueFamilyCheckpointPropertiesNVValue = unsafe.Sizeof([1]C.VkQueueFamilyCheckpointPropertiesNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueueFamilyCheckpointPropertiesNV) Ref() *C.VkQueueFamilyCheckpointPropertiesNV {
	if x == nil {
		return nil
	}
	return x.ref351f58c6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueueFamilyCheckpointPropertiesNV) Free() {
	if x != nil && x.allocs351f58c6 != nil {
		x.allocs351f58c6.(*cgoAllocMap).Free()
		x.ref351f58c6 = nil
	}
}

// NewQueueFamilyCheckpointPropertiesNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueueFamilyCheckpointPropertiesNVRef(ref unsafe.Pointer) *QueueFamilyCheckpointPropertiesNV {
	if ref == nil {
		return nil
	}
	obj := new(QueueFamilyCheckpointPropertiesNV)
	obj.ref351f58c6 = (*C.VkQueueFamilyCheckpointPropertiesNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueueFamilyCheckpointPropertiesNV) PassRef() (*C.VkQueueFamilyCheckpointPropertiesNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref351f58c6 != nil {
		return x.ref351f58c6, nil
	}
	mem351f58c6 := allocQueueFamilyCheckpointPropertiesNVMemory(1)
	ref351f58c6 := (*C.VkQueueFamilyCheckpointPropertiesNV)(mem351f58c6)
	allocs351f58c6 := new(cgoAllocMap)
	allocs351f58c6.Add(mem351f58c6)

	var csType_allocs *cgoAllocMap
	ref351f58c6.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocs351f58c6.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	ref351f58c6.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocs351f58c6.Borrow(cpNext_allocs)

	var ccheckpointExecutionStageMask_allocs *cgoAllocMap
	ref351f58c6.checkpointExecutionStageMask, ccheckpointExecutionStageMask_allocs = (C.VkPipelineStageFlags)(x.CheckpointExecutionStageMask), cgoAllocsUnknown
	allocs351f58c6.Borrow(ccheckpointExecutionStageMask_allocs)

	x.ref351f58c6 = ref351f58c6
	x.allocs351f58c6 = allocs351f58c6
	return ref351f58c6, allocs351f58c6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueueFamilyCheckpointPropertiesNV) PassValue() (C.VkQueueFamilyCheckpointPropertiesNV, *cgoAllocMap) {
	if x.ref351f58c6 != nil {
		return *x.ref351f58c6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueueFamilyCheckpointPropertiesNV) Deref() {
	if x.ref351f58c6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref351f58c6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref351f58c6.pNext))
	x.CheckpointExecutionStageMask = (PipelineStageFlags)(x.ref351f58c6.checkpointExecutionStageMask)
}

// allocCheckpointDataNVMemory allocates memory for type C.VkCheckpointDataNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCheckpointDataNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCheckpointDataNVValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCheckpointDataNVValue = unsafe.Sizeof([1]C.VkCheckpointDataNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CheckpointDataNV) Ref() *C.VkCheckpointDataNV {
	if x == nil {
		return nil
	}
	return x.refd1c9224b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CheckpointDataNV) Free() {
	if x != nil && x.allocsd1c9224b != nil {
		x.allocsd1c9224b.(*cgoAllocMap).Free()
		x.refd1c9224b = nil
	}
}

// NewCheckpointDataNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCheckpointDataNVRef(ref unsafe.Pointer) *CheckpointDataNV {
	if ref == nil {
		return nil
	}
	obj := new(CheckpointDataNV)
	obj.refd1c9224b = (*C.VkCheckpointDataNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CheckpointDataNV) PassRef() (*C.VkCheckpointDataNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd1c9224b != nil {
		return x.refd1c9224b, nil
	}
	memd1c9224b := allocCheckpointDataNVMemory(1)
	refd1c9224b := (*C.VkCheckpointDataNV)(memd1c9224b)
	allocsd1c9224b := new(cgoAllocMap)
	allocsd1c9224b.Add(memd1c9224b)

	var csType_allocs *cgoAllocMap
	refd1c9224b.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsd1c9224b.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refd1c9224b.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsd1c9224b.Borrow(cpNext_allocs)

	var cstage_allocs *cgoAllocMap
	refd1c9224b.stage, cstage_allocs = (C.VkPipelineStageFlagBits)(x.Stage), cgoAllocsUnknown
	allocsd1c9224b.Borrow(cstage_allocs)

	var cpCheckpointMarker_allocs *cgoAllocMap
	refd1c9224b.pCheckpointMarker, cpCheckpointMarker_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PCheckpointMarker)), cgoAllocsUnknown
	allocsd1c9224b.Borrow(cpCheckpointMarker_allocs)

	x.refd1c9224b = refd1c9224b
	x.allocsd1c9224b = allocsd1c9224b
	return refd1c9224b, allocsd1c9224b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CheckpointDataNV) PassValue() (C.VkCheckpointDataNV, *cgoAllocMap) {
	if x.refd1c9224b != nil {
		return *x.refd1c9224b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CheckpointDataNV) Deref() {
	if x.refd1c9224b == nil {
		return
	}
	x.SType = (StructureType)(x.refd1c9224b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd1c9224b.pNext))
	x.Stage = (PipelineStageFlagBits)(x.refd1c9224b.stage)
	x.PCheckpointMarker = (unsafe.Pointer)(unsafe.Pointer(x.refd1c9224b.pCheckpointMarker))
}

// allocPhysicalDevicePCIBusInfoPropertiesMemory allocates memory for type C.VkPhysicalDevicePCIBusInfoPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePCIBusInfoPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePCIBusInfoPropertiesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicalDevicePCIBusInfoPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDevicePCIBusInfoPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDevicePCIBusInfoProperties) Ref() *C.VkPhysicalDevicePCIBusInfoPropertiesEXT {
	if x == nil {
		return nil
	}
	return x.refdd9947ff
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDevicePCIBusInfoProperties) Free() {
	if x != nil && x.allocsdd9947ff != nil {
		x.allocsdd9947ff.(*cgoAllocMap).Free()
		x.refdd9947ff = nil
	}
}

// NewPhysicalDevicePCIBusInfoPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePCIBusInfoPropertiesRef(ref unsafe.Pointer) *PhysicalDevicePCIBusInfoProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDevicePCIBusInfoProperties)
	obj.refdd9947ff = (*C.VkPhysicalDevicePCIBusInfoPropertiesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDevicePCIBusInfoProperties) PassRef() (*C.VkPhysicalDevicePCIBusInfoPropertiesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdd9947ff != nil {
		return x.refdd9947ff, nil
	}
	memdd9947ff := allocPhysicalDevicePCIBusInfoPropertiesMemory(1)
	refdd9947ff := (*C.VkPhysicalDevicePCIBusInfoPropertiesEXT)(memdd9947ff)
	allocsdd9947ff := new(cgoAllocMap)
	allocsdd9947ff.Add(memdd9947ff)

	var csType_allocs *cgoAllocMap
	refdd9947ff.sType, csType_allocs = (C.VkStructureType)(x.SType), cgoAllocsUnknown
	allocsdd9947ff.Borrow(csType_allocs)

	var cpNext_allocs *cgoAllocMap
	refdd9947ff.pNext, cpNext_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext)), cgoAllocsUnknown
	allocsdd9947ff.Borrow(cpNext_allocs)

	var cpciDomain_allocs *cgoAllocMap
	refdd9947ff.pciDomain, cpciDomain_allocs = (C.uint16_t)(x.PciDomain), cgoAllocsUnknown
	allocsdd9947ff.Borrow(cpciDomain_allocs)

	var cpciBus_allocs *cgoAllocMap
	refdd9947ff.pciBus, cpciBus_allocs = (C.uint8_t)(x.PciBus), cgoAllocsUnknown
	allocsdd9947ff.Borrow(cpciBus_allocs)

	var cpciDevice_allocs *cgoAllocMap
	refdd9947ff.pciDevice, cpciDevice_allocs = (C.uint8_t)(x.PciDevice), cgoAllocsUnknown
	allocsdd9947ff.Borrow(cpciDevice_allocs)

	var cpciFunction_allocs *cgoAllocMap
	refdd9947ff.pciFunction, cpciFunction_allocs = (C.uint8_t)(x.PciFunction), cgoAllocsUnknown
	allocsdd9947ff.Borrow(cpciFunction_allocs)

	x.refdd9947ff = refdd9947ff
	x.allocsdd9947ff = allocsdd9947ff
	return refdd9947ff, allocsdd9947ff

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDevicePCIBusInfoProperties) PassValue() (C.VkPhysicalDevicePCIBusInfoPropertiesEXT, *cgoAllocMap) {
	if x.refdd9947ff != nil {
		return *x.refdd9947ff, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDevicePCIBusInfoProperties) Deref() {
	if x.refdd9947ff == nil {
		return
	}
	x.SType = (StructureType)(x.refdd9947ff.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdd9947ff.pNext))
	x.PciDomain = (uint16)(x.refdd9947ff.pciDomain)
	x.PciBus = (byte)(x.refdd9947ff.pciBus)
	x.PciDevice = (byte)(x.refdd9947ff.pciDevice)
	x.PciFunction = (byte)(x.refdd9947ff.pciFunction)
}

// unpackArgSQueueFamilyProperties transforms a sliced Go data structure into plain C format.
func unpackArgSQueueFamilyProperties(x []QueueFamilyProperties) (unpacked *C.VkQueueFamilyProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkQueueFamilyProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocQueueFamilyPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkQueueFamilyProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkQueueFamilyProperties)(h.Data)
	return
}

// packSQueueFamilyProperties reads sliced Go data structure out from plain C format.
func packSQueueFamilyProperties(v []QueueFamilyProperties, ptr0 *C.VkQueueFamilyProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfQueueFamilyPropertiesValue]C.VkQueueFamilyProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewQueueFamilyPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSExtensionProperties transforms a sliced Go data structure into plain C format.
func unpackArgSExtensionProperties(x []ExtensionProperties) (unpacked *C.VkExtensionProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkExtensionProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocExtensionPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkExtensionProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkExtensionProperties)(h.Data)
	return
}

// packSExtensionProperties reads sliced Go data structure out from plain C format.
func packSExtensionProperties(v []ExtensionProperties, ptr0 *C.VkExtensionProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfExtensionPropertiesValue]C.VkExtensionProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewExtensionPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSLayerProperties transforms a sliced Go data structure into plain C format.
func unpackArgSLayerProperties(x []LayerProperties) (unpacked *C.VkLayerProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkLayerProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocLayerPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkLayerProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkLayerProperties)(h.Data)
	return
}

// packSLayerProperties reads sliced Go data structure out from plain C format.
func packSLayerProperties(v []LayerProperties, ptr0 *C.VkLayerProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfLayerPropertiesValue]C.VkLayerProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewLayerPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSubmitInfo transforms a sliced Go data structure into plain C format.
func unpackArgSSubmitInfo(x []SubmitInfo) (unpacked *C.VkSubmitInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSubmitInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSubmitInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubmitInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubmitInfo)(h.Data)
	return
}

// packSSubmitInfo reads sliced Go data structure out from plain C format.
func packSSubmitInfo(v []SubmitInfo, ptr0 *C.VkSubmitInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubmitInfoValue]C.VkSubmitInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubmitInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMappedMemoryRange transforms a sliced Go data structure into plain C format.
func unpackArgSMappedMemoryRange(x []MappedMemoryRange) (unpacked *C.VkMappedMemoryRange, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkMappedMemoryRange) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMappedMemoryRangeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMappedMemoryRange)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMappedMemoryRange)(h.Data)
	return
}

// packSMappedMemoryRange reads sliced Go data structure out from plain C format.
func packSMappedMemoryRange(v []MappedMemoryRange, ptr0 *C.VkMappedMemoryRange) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMappedMemoryRangeValue]C.VkMappedMemoryRange)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMappedMemoryRangeRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSparseImageMemoryRequirements transforms a sliced Go data structure into plain C format.
func unpackArgSSparseImageMemoryRequirements(x []SparseImageMemoryRequirements) (unpacked *C.VkSparseImageMemoryRequirements, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageMemoryRequirements) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageMemoryRequirementsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageMemoryRequirements)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageMemoryRequirements)(h.Data)
	return
}

// packSSparseImageMemoryRequirements reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryRequirements(v []SparseImageMemoryRequirements, ptr0 *C.VkSparseImageMemoryRequirements) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryRequirementsValue]C.VkSparseImageMemoryRequirements)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryRequirementsRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSparseImageFormatProperties transforms a sliced Go data structure into plain C format.
func unpackArgSSparseImageFormatProperties(x []SparseImageFormatProperties) (unpacked *C.VkSparseImageFormatProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSparseImageFormatProperties) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageFormatPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageFormatProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageFormatProperties)(h.Data)
	return
}

// packSSparseImageFormatProperties reads sliced Go data structure out from plain C format.
func packSSparseImageFormatProperties(v []SparseImageFormatProperties, ptr0 *C.VkSparseImageFormatProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageFormatPropertiesValue]C.VkSparseImageFormatProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageFormatPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBindSparseInfo transforms a sliced Go data structure into plain C format.
func unpackArgSBindSparseInfo(x []BindSparseInfo) (unpacked *C.VkBindSparseInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkBindSparseInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBindSparseInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBindSparseInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBindSparseInfo)(h.Data)
	return
}

// packSBindSparseInfo reads sliced Go data structure out from plain C format.
func packSBindSparseInfo(v []BindSparseInfo, ptr0 *C.VkBindSparseInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBindSparseInfoValue]C.VkBindSparseInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBindSparseInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSGraphicsPipelineCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSGraphicsPipelineCreateInfo(x []GraphicsPipelineCreateInfo) (unpacked *C.VkGraphicsPipelineCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkGraphicsPipelineCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocGraphicsPipelineCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkGraphicsPipelineCreateInfo)(h.Data)
	return
}

// packSGraphicsPipelineCreateInfo reads sliced Go data structure out from plain C format.
func packSGraphicsPipelineCreateInfo(v []GraphicsPipelineCreateInfo, ptr0 *C.VkGraphicsPipelineCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfGraphicsPipelineCreateInfoValue]C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewGraphicsPipelineCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSComputePipelineCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSComputePipelineCreateInfo(x []ComputePipelineCreateInfo) (unpacked *C.VkComputePipelineCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkComputePipelineCreateInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocComputePipelineCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkComputePipelineCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkComputePipelineCreateInfo)(h.Data)
	return
}

// packSComputePipelineCreateInfo reads sliced Go data structure out from plain C format.
func packSComputePipelineCreateInfo(v []ComputePipelineCreateInfo, ptr0 *C.VkComputePipelineCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfComputePipelineCreateInfoValue]C.VkComputePipelineCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewComputePipelineCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSWriteDescriptorSet transforms a sliced Go data structure into plain C format.
func unpackArgSWriteDescriptorSet(x []WriteDescriptorSet) (unpacked *C.VkWriteDescriptorSet, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkWriteDescriptorSet) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocWriteDescriptorSetMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkWriteDescriptorSet)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkWriteDescriptorSet)(h.Data)
	return
}

// packSWriteDescriptorSet reads sliced Go data structure out from plain C format.
func packSWriteDescriptorSet(v []WriteDescriptorSet, ptr0 *C.VkWriteDescriptorSet) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfWriteDescriptorSetValue]C.VkWriteDescriptorSet)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewWriteDescriptorSetRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCopyDescriptorSet transforms a sliced Go data structure into plain C format.
func unpackArgSCopyDescriptorSet(x []CopyDescriptorSet) (unpacked *C.VkCopyDescriptorSet, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkCopyDescriptorSet) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCopyDescriptorSetMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCopyDescriptorSet)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCopyDescriptorSet)(h.Data)
	return
}

// packSCopyDescriptorSet reads sliced Go data structure out from plain C format.
func packSCopyDescriptorSet(v []CopyDescriptorSet, ptr0 *C.VkCopyDescriptorSet) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCopyDescriptorSetValue]C.VkCopyDescriptorSet)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCopyDescriptorSetRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSViewport transforms a sliced Go data structure into plain C format.
func unpackArgSViewport(x []Viewport) (unpacked *C.VkViewport, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkViewport) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocViewportMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkViewport)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkViewport)(h.Data)
	return
}

// unpackArgSRect2D transforms a sliced Go data structure into plain C format.
func unpackArgSRect2D(x []Rect2D) (unpacked *C.VkRect2D, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkRect2D) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRect2DMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRect2D)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRect2D)(h.Data)
	return
}

// unpackArgSBufferCopy transforms a sliced Go data structure into plain C format.
func unpackArgSBufferCopy(x []BufferCopy) (unpacked *C.VkBufferCopy, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkBufferCopy) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBufferCopyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferCopy)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferCopy)(h.Data)
	return
}

// packSBufferCopy reads sliced Go data structure out from plain C format.
func packSBufferCopy(v []BufferCopy, ptr0 *C.VkBufferCopy) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferCopyValue]C.VkBufferCopy)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferCopyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageCopy transforms a sliced Go data structure into plain C format.
func unpackArgSImageCopy(x []ImageCopy) (unpacked *C.VkImageCopy, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageCopy) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageCopyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageCopy)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageCopy)(h.Data)
	return
}

// packSImageCopy reads sliced Go data structure out from plain C format.
func packSImageCopy(v []ImageCopy, ptr0 *C.VkImageCopy) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageCopyValue]C.VkImageCopy)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageCopyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageBlit transforms a sliced Go data structure into plain C format.
func unpackArgSImageBlit(x []ImageBlit) (unpacked *C.VkImageBlit, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageBlit) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageBlitMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageBlit)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageBlit)(h.Data)
	return
}

// packSImageBlit reads sliced Go data structure out from plain C format.
func packSImageBlit(v []ImageBlit, ptr0 *C.VkImageBlit) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageBlitValue]C.VkImageBlit)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageBlitRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBufferImageCopy transforms a sliced Go data structure into plain C format.
func unpackArgSBufferImageCopy(x []BufferImageCopy) (unpacked *C.VkBufferImageCopy, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkBufferImageCopy) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBufferImageCopyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferImageCopy)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferImageCopy)(h.Data)
	return
}

// packSBufferImageCopy reads sliced Go data structure out from plain C format.
func packSBufferImageCopy(v []BufferImageCopy, ptr0 *C.VkBufferImageCopy) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferImageCopyValue]C.VkBufferImageCopy)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferImageCopyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageSubresourceRange transforms a sliced Go data structure into plain C format.
func unpackArgSImageSubresourceRange(x []ImageSubresourceRange) (unpacked *C.VkImageSubresourceRange, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageSubresourceRange) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageSubresourceRangeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageSubresourceRange)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageSubresourceRange)(h.Data)
	return
}

// packSImageSubresourceRange reads sliced Go data structure out from plain C format.
func packSImageSubresourceRange(v []ImageSubresourceRange, ptr0 *C.VkImageSubresourceRange) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageSubresourceRangeValue]C.VkImageSubresourceRange)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageSubresourceRangeRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSClearAttachment transforms a sliced Go data structure into plain C format.
func unpackArgSClearAttachment(x []ClearAttachment) (unpacked *C.VkClearAttachment, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkClearAttachment) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocClearAttachmentMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkClearAttachment)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkClearAttachment)(h.Data)
	return
}

// packSClearAttachment reads sliced Go data structure out from plain C format.
func packSClearAttachment(v []ClearAttachment, ptr0 *C.VkClearAttachment) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfClearAttachmentValue]C.VkClearAttachment)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewClearAttachmentRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSClearRect transforms a sliced Go data structure into plain C format.
func unpackArgSClearRect(x []ClearRect) (unpacked *C.VkClearRect, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkClearRect) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocClearRectMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkClearRect)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkClearRect)(h.Data)
	return
}

// packSClearRect reads sliced Go data structure out from plain C format.
func packSClearRect(v []ClearRect, ptr0 *C.VkClearRect) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfClearRectValue]C.VkClearRect)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewClearRectRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageResolve transforms a sliced Go data structure into plain C format.
func unpackArgSImageResolve(x []ImageResolve) (unpacked *C.VkImageResolve, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageResolve) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageResolveMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageResolve)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageResolve)(h.Data)
	return
}

// packSImageResolve reads sliced Go data structure out from plain C format.
func packSImageResolve(v []ImageResolve, ptr0 *C.VkImageResolve) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageResolveValue]C.VkImageResolve)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageResolveRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMemoryBarrier transforms a sliced Go data structure into plain C format.
func unpackArgSMemoryBarrier(x []MemoryBarrier) (unpacked *C.VkMemoryBarrier, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkMemoryBarrier) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMemoryBarrierMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMemoryBarrier)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMemoryBarrier)(h.Data)
	return
}

// packSMemoryBarrier reads sliced Go data structure out from plain C format.
func packSMemoryBarrier(v []MemoryBarrier, ptr0 *C.VkMemoryBarrier) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMemoryBarrierValue]C.VkMemoryBarrier)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMemoryBarrierRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBufferMemoryBarrier transforms a sliced Go data structure into plain C format.
func unpackArgSBufferMemoryBarrier(x []BufferMemoryBarrier) (unpacked *C.VkBufferMemoryBarrier, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkBufferMemoryBarrier) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBufferMemoryBarrierMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferMemoryBarrier)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferMemoryBarrier)(h.Data)
	return
}

// packSBufferMemoryBarrier reads sliced Go data structure out from plain C format.
func packSBufferMemoryBarrier(v []BufferMemoryBarrier, ptr0 *C.VkBufferMemoryBarrier) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferMemoryBarrierValue]C.VkBufferMemoryBarrier)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferMemoryBarrierRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImageMemoryBarrier transforms a sliced Go data structure into plain C format.
func unpackArgSImageMemoryBarrier(x []ImageMemoryBarrier) (unpacked *C.VkImageMemoryBarrier, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkImageMemoryBarrier) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageMemoryBarrierMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageMemoryBarrier)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageMemoryBarrier)(h.Data)
	return
}

// packSImageMemoryBarrier reads sliced Go data structure out from plain C format.
func packSImageMemoryBarrier(v []ImageMemoryBarrier, ptr0 *C.VkImageMemoryBarrier) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageMemoryBarrierValue]C.VkImageMemoryBarrier)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageMemoryBarrierRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSurfaceFormat transforms a sliced Go data structure into plain C format.
func unpackArgSSurfaceFormat(x []SurfaceFormat) (unpacked *C.VkSurfaceFormatKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSurfaceFormatKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSurfaceFormatMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSurfaceFormatKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSurfaceFormatKHR)(h.Data)
	return
}

// packSSurfaceFormat reads sliced Go data structure out from plain C format.
func packSSurfaceFormat(v []SurfaceFormat, ptr0 *C.VkSurfaceFormatKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSurfaceFormatValue]C.VkSurfaceFormatKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSurfaceFormatRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayProperties transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayProperties(x []DisplayProperties) (unpacked *C.VkDisplayPropertiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayPropertiesKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayPropertiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayPropertiesKHR)(h.Data)
	return
}

// packSDisplayProperties reads sliced Go data structure out from plain C format.
func packSDisplayProperties(v []DisplayProperties, ptr0 *C.VkDisplayPropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPropertiesValue]C.VkDisplayPropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayPlaneProperties transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayPlaneProperties(x []DisplayPlaneProperties) (unpacked *C.VkDisplayPlanePropertiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayPlanePropertiesKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayPlanePropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayPlanePropertiesKHR)(h.Data)
	return
}

// packSDisplayPlaneProperties reads sliced Go data structure out from plain C format.
func packSDisplayPlaneProperties(v []DisplayPlaneProperties, ptr0 *C.VkDisplayPlanePropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPlanePropertiesValue]C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPlanePropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayModeProperties transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayModeProperties(x []DisplayModeProperties) (unpacked *C.VkDisplayModePropertiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkDisplayModePropertiesKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayModePropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayModePropertiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayModePropertiesKHR)(h.Data)
	return
}

// packSDisplayModeProperties reads sliced Go data structure out from plain C format.
func packSDisplayModeProperties(v []DisplayModeProperties, ptr0 *C.VkDisplayModePropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayModePropertiesValue]C.VkDisplayModePropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayModePropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSwapchainCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSSwapchainCreateInfo(x []SwapchainCreateInfo) (unpacked *C.VkSwapchainCreateInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.VkSwapchainCreateInfoKHR) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSwapchainCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSwapchainCreateInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSwapchainCreateInfoKHR)(h.Data)
	return
}

// packSSwapchainCreateInfo reads sliced Go data structure out from plain C format.
func packSSwapchainCreateInfo(v []SwapchainCreateInfo, ptr0 *C.VkSwapchainCreateInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSwapchainCreateInfoValue]C.VkSwapchainCreateInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSwapchainCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}
